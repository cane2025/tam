
> ungdomsstodet-v2@2.0.0 lint
> eslint . --ext .ts,.tsx --format json

[{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/.eslintrc.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/dist/assets/index-D5q8OXOq.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/complete-system-audit.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":166,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":13},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":587,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":587,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18718,18721],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18718,18721],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env tsx\n\n/**\n * Complete System Audit for Ungdomsstöd V2\n * Comprehensive audit that works even without backend running\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { execSync } from 'child_process';\n\n// Typdefinitioner\ninterface AuditResult {\n  score: number; // 0-100\n  criticalIssues: string[];\n  warnings: string[];\n  passed: string[];\n  notes: string[];\n}\n\ninterface AuditReport {\n  timestamp: string;\n  totalScore: number;\n  results: {\n    security: AuditResult;\n    performance: AuditResult;\n    codeQuality: AuditResult;\n    dataIntegrity: AuditResult;\n    errorHandling: AuditResult;\n    deployment: AuditResult;\n  };\n  criticalIssues: string[];\n  warnings: string[];\n  productionReady: boolean;\n}\n\n// 1. SÄKERHETSAUDIT (25% vikt)\nasync function auditSecurity(): Promise<AuditResult> {\n  const result: AuditResult = {\n    score: 0,\n    criticalIssues: [],\n    warnings: [],\n    passed: [],\n    notes: []\n  };\n\n  // Test 1: Kontrollera security headers i kod\n  const indexPath = 'server/index.ts';\n  if (fs.existsSync(indexPath)) {\n    const content = fs.readFileSync(indexPath, 'utf-8');\n    if (content.includes('helmet')) {\n      result.passed.push('Helmet security headers configured');\n      result.score += 20;\n    } else {\n      result.warnings.push('No helmet configuration found');\n    }\n  } else {\n    result.notes.push('Server file not found - N/A');\n    result.score = 60; // Neutral baseline\n  }\n\n  // Test 2: Kontrollera för hårdkodade secrets\n  try {\n    const srcFiles = execSync('find . -name \"*.ts\" -o -name \"*.tsx\" 2>/dev/null || true', { encoding: 'utf-8' });\n    const secretPatterns = [\n      /api[_-]?key\\s*=\\s*[\"'][^\"']+[\"']/gi,\n      /password\\s*=\\s*[\"'][^\"']+[\"']/gi,\n      /secret\\s*=\\s*[\"'][^\"']+[\"']/gi\n    ];\n    \n    let hardcodedSecrets = 0;\n    srcFiles.split('\\n').forEach(file => {\n      if (file && fs.existsSync(file) && !file.includes('node_modules')) {\n        const content = fs.readFileSync(file, 'utf-8');\n        secretPatterns.forEach(pattern => {\n          if (pattern.test(content)) hardcodedSecrets++;\n        });\n      }\n    });\n\n    if (hardcodedSecrets > 0) {\n      result.criticalIssues.push(`Found ${hardcodedSecrets} potential hardcoded secrets`);\n    } else {\n      result.passed.push('No hardcoded secrets detected');\n      result.score += 20;\n    }\n  } catch {\n    result.notes.push('Could not scan for secrets');\n  }\n\n  // Test 3: GDPR compliance check\n  if (fs.existsSync('server/utils/audit-logger.ts')) {\n    const auditContent = fs.readFileSync('server/utils/audit-logger.ts', 'utf-8');\n    if (auditContent.includes('anonymize') || auditContent.includes('hash')) {\n      result.passed.push('GDPR: Audit logs are anonymized');\n      result.score += 20;\n    } else {\n      result.warnings.push('GDPR: Audit logs may contain PII');\n    }\n  }\n\n  // Test 4: Auth implementation\n  if (fs.existsSync('server/routes/auth.ts')) {\n    const authContent = fs.readFileSync('server/routes/auth.ts', 'utf-8');\n    if (authContent.includes('bcrypt') && authContent.includes('jwt')) {\n      result.passed.push('Authentication properly implemented');\n      result.score += 20;\n    }\n  }\n\n  // Test 5: Migration safety\n  if (fs.existsSync('scripts/v1-to-v2-migration.ts')) {\n    const migrationContent = fs.readFileSync('scripts/v1-to-v2-migration.ts', 'utf-8');\n    if (migrationContent.includes('BEGIN TRANSACTION') && migrationContent.includes('ROLLBACK')) {\n      result.passed.push('Migration has transaction safety');\n      result.score += 20;\n    } else {\n      result.criticalIssues.push('Migration lacks transaction safety');\n    }\n  }\n\n  return result;\n}\n\n// 2. PERFORMANCE ANALYS (20% vikt)\nasync function analyzePerformance(): Promise<AuditResult> {\n  const result: AuditResult = {\n    score: 0,\n    criticalIssues: [],\n    warnings: [],\n    passed: [],\n    notes: []\n  };\n\n  // Test 1: Bundle size check\n  try {\n    execSync('npm run build', { stdio: 'ignore' });\n    const distPath = 'dist';\n    if (fs.existsSync(distPath)) {\n      const getDirSize = (dir: string): number => {\n        let size = 0;\n        const files = fs.readdirSync(dir);\n        files.forEach(file => {\n          const filePath = path.join(dir, file);\n          const stat = fs.statSync(filePath);\n          if (stat.isDirectory()) {\n            size += getDirSize(filePath);\n          } else {\n            size += stat.size;\n          }\n        });\n        return size;\n      };\n      \n      const bundleSize = getDirSize(distPath) / (1024 * 1024); // MB\n      if (bundleSize < 1) {\n        result.passed.push(`Bundle size optimal: ${bundleSize.toFixed(2)}MB`);\n        result.score += 40;\n      } else if (bundleSize < 5) {\n        result.warnings.push(`Bundle size large: ${bundleSize.toFixed(2)}MB`);\n        result.score += 20;\n      } else {\n        result.criticalIssues.push(`Bundle too large: ${bundleSize.toFixed(2)}MB`);\n      }\n    }\n  } catch (e) {\n    result.notes.push('Build failed - cannot measure bundle size');\n  }\n\n  // Test 2: Check for N+1 queries\n  try {\n    const apiFiles = execSync('find . -path \"*/server/*\" -name \"*.ts\" 2>/dev/null || true', { encoding: 'utf-8' });\n    let n1Patterns = 0;\n    apiFiles.split('\\n').forEach(file => {\n      if (file && fs.existsSync(file)) {\n        const content = fs.readFileSync(file, 'utf-8');\n        // Look for loops with DB queries\n        if (/for.*await.*db\\.|\\.map.*async.*db\\./g.test(content)) {\n          n1Patterns++;\n        }\n      }\n    });\n\n    if (n1Patterns > 0) {\n      result.warnings.push(`Found ${n1Patterns} potential N+1 query patterns`);\n      result.score += 20;\n    } else {\n      result.passed.push('No N+1 query patterns detected');\n      result.score += 40;\n    }\n  } catch {\n    result.notes.push('Could not analyze query patterns');\n  }\n\n  // Test 3: React optimization\n  try {\n    const componentFiles = execSync('find src -name \"*.tsx\" 2>/dev/null || true', { encoding: 'utf-8' });\n    let optimizedComponents = 0;\n    let totalComponents = 0;\n    \n    componentFiles.split('\\n').forEach(file => {\n      if (file && fs.existsSync(file)) {\n        totalComponents++;\n        const content = fs.readFileSync(file, 'utf-8');\n        if (content.includes('useMemo') || content.includes('useCallback') || content.includes('React.memo')) {\n          optimizedComponents++;\n        }\n      }\n    });\n\n    if (totalComponents > 0) {\n      const optimizationRate = (optimizedComponents / totalComponents) * 100;\n      if (optimizationRate > 30) {\n        result.passed.push(`${optimizationRate.toFixed(0)}% components optimized`);\n        result.score += 20;\n      } else {\n        result.warnings.push(`Only ${optimizationRate.toFixed(0)}% components optimized`);\n      }\n    }\n  } catch {\n    result.notes.push('Could not analyze React components');\n  }\n\n  return result;\n}\n\n// 3. KOD KVALITET (20% vikt)\nasync function analyzeCodeQuality(): Promise<AuditResult> {\n  const result: AuditResult = {\n    score: 0,\n    criticalIssues: [],\n    warnings: [],\n    passed: [],\n    notes: []\n  };\n\n  // Test 1: TypeScript strictness\n  if (fs.existsSync('tsconfig.json')) {\n    const tsconfig = JSON.parse(fs.readFileSync('tsconfig.json', 'utf-8'));\n    if (tsconfig.compilerOptions?.strict === true) {\n      result.passed.push('TypeScript strict mode enabled');\n      result.score += 30;\n    } else {\n      result.warnings.push('TypeScript strict mode disabled');\n    }\n  }\n\n  // Test 2: Count 'any' types\n  try {\n    const tsFiles = execSync('find . -name \"*.ts\" -o -name \"*.tsx\" 2>/dev/null || true', { encoding: 'utf-8' });\n    let anyCount = 0;\n    tsFiles.split('\\n').forEach(file => {\n      if (file && fs.existsSync(file) && !file.includes('node_modules')) {\n        const content = fs.readFileSync(file, 'utf-8');\n        const matches = content.match(/:\\s*any\\b/g);\n        if (matches) anyCount += matches.length;\n      }\n    });\n\n    if (anyCount === 0) {\n      result.passed.push('No \"any\" types found');\n      result.score += 30;\n    } else if (anyCount < 10) {\n      result.warnings.push(`Found ${anyCount} \"any\" types`);\n      result.score += 15;\n    } else {\n      result.criticalIssues.push(`Too many \"any\" types: ${anyCount}`);\n    }\n  } catch {\n    result.notes.push('Could not analyze TypeScript types');\n  }\n\n  // Test 3: ESLint\n  try {\n    const lintResult = execSync('npm run lint 2>&1 || true', { encoding: 'utf-8' });\n    if (lintResult.includes('0 errors')) {\n      result.passed.push('No ESLint errors');\n      result.score += 20;\n    } else {\n      const errorMatch = lintResult.match(/(\\d+) error/);\n      if (errorMatch) {\n        result.warnings.push(`ESLint: ${errorMatch[1]} errors`);\n      }\n    }\n  } catch {\n    result.notes.push('ESLint not configured');\n  }\n\n  // Test 4: Test coverage\n  if (fs.existsSync('coverage/coverage-summary.json')) {\n    const coverage = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf-8'));\n    const lines = coverage.total?.lines?.pct || 0;\n    if (lines > 80) {\n      result.passed.push(`Test coverage: ${lines}%`);\n      result.score += 20;\n    } else if (lines > 50) {\n      result.warnings.push(`Low test coverage: ${lines}%`);\n      result.score += 10;\n    } else {\n      result.criticalIssues.push(`Very low test coverage: ${lines}%`);\n    }\n  } else {\n    result.notes.push('No test coverage data available');\n  }\n\n  return result;\n}\n\n// 4. DATA INTEGRITET (15% vikt)\nasync function checkDataIntegrity(): Promise<AuditResult> {\n  const result: AuditResult = {\n    score: 60, // Start med neutral\n    criticalIssues: [],\n    warnings: [],\n    passed: [],\n    notes: []\n  };\n\n  // Test migration script\n  if (fs.existsSync('scripts/v1-to-v2-migration.ts')) {\n    try {\n      const dryRun = execSync('npm run migrate:v1-to-v2 -- --dry-run 2>&1', { encoding: 'utf-8' });\n      if (dryRun.includes('success') || dryRun.includes('complete')) {\n        result.passed.push('Migration dry-run successful');\n        result.score = 80;\n      }\n    } catch {\n      result.warnings.push('Migration dry-run failed');\n      result.score = 40;\n    }\n  }\n\n  // Check for LocalStorage cleanup\n  try {\n    const storageFiles = execSync('grep -r \"localStorage\" src 2>/dev/null || true', { encoding: 'utf-8' });\n    if (storageFiles.includes('cleanup') || storageFiles.includes('clear')) {\n      result.passed.push('LocalStorage cleanup implemented');\n      result.score += 20;\n    }\n  } catch {\n    result.notes.push('Could not check LocalStorage usage');\n  }\n\n  return result;\n}\n\n// 5. ERROR HANDLING (10% vikt)\nasync function auditErrorHandling(): Promise<AuditResult> {\n  const result: AuditResult = {\n    score: 0,\n    criticalIssues: [],\n    warnings: [],\n    passed: [],\n    notes: []\n  };\n\n  // Count try-catch blocks\n  try {\n    const codeFiles = execSync('find . -name \"*.ts\" -o -name \"*.tsx\" 2>/dev/null || true', { encoding: 'utf-8' });\n    let tryCatchCount = 0;\n    let asyncFunctionCount = 0;\n    \n    codeFiles.split('\\n').forEach(file => {\n      if (file && fs.existsSync(file) && !file.includes('node_modules')) {\n        const content = fs.readFileSync(file, 'utf-8');\n        tryCatchCount += (content.match(/try\\s*{/g) || []).length;\n        asyncFunctionCount += (content.match(/async\\s+(function|\\()/g) || []).length;\n      }\n    });\n\n    if (asyncFunctionCount > 0) {\n      const errorHandlingRate = (tryCatchCount / asyncFunctionCount) * 100;\n      if (errorHandlingRate > 50) {\n        result.passed.push(`Good error handling: ${errorHandlingRate.toFixed(0)}% async functions protected`);\n        result.score = 80;\n      } else {\n        result.warnings.push(`Poor error handling: only ${errorHandlingRate.toFixed(0)}% async functions protected`);\n        result.score = 40;\n      }\n    }\n  } catch {\n    result.notes.push('Could not analyze error handling');\n  }\n\n  // Check for Error Boundary\n  try {\n    const errorBoundary = execSync('grep -r \"ErrorBoundary\" src 2>/dev/null || true', { encoding: 'utf-8' });\n    if (errorBoundary) {\n      result.passed.push('React ErrorBoundary implemented');\n      result.score += 20;\n    }\n  } catch {\n    result.notes.push('Could not check for ErrorBoundary');\n  }\n\n  return result;\n}\n\n// 6. DEPLOYMENT READINESS (10% vikt)\nasync function checkDeploymentReadiness(): Promise<AuditResult> {\n  const result: AuditResult = {\n    score: 0,\n    criticalIssues: [],\n    warnings: [],\n    passed: [],\n    notes: []\n  };\n\n  // Check build\n  try {\n    execSync('npm run build', { stdio: 'ignore' });\n    result.passed.push('Build successful');\n    result.score += 30;\n  } catch {\n    result.criticalIssues.push('Build failed');\n  }\n\n  // Check env setup\n  if (fs.existsSync('.env.example')) {\n    result.passed.push('Environment variables documented');\n    result.score += 20;\n  }\n\n  // Check for CI/CD\n  if (fs.existsSync('.github/workflows')) {\n    result.passed.push('CI/CD configured');\n    result.score += 30;\n  }\n\n  // Check Docker\n  if (fs.existsSync('Dockerfile')) {\n    result.passed.push('Docker ready');\n    result.score += 20;\n  }\n\n  return result;\n}\n\n// HUVUD RAPPORT GENERATOR\nasync function generateCompleteReport() {\n  console.log('🔍 Starting Ungdomsstöd V2 System Audit...\\n');\n  \n  // Kör alla audits\n  const results = {\n    security: await auditSecurity(),\n    performance: await analyzePerformance(),\n    codeQuality: await analyzeCodeQuality(),\n    dataIntegrity: await checkDataIntegrity(),\n    errorHandling: await auditErrorHandling(),\n    deployment: await checkDeploymentReadiness()\n  };\n  \n  // Beräkna total score med vikter\n  const totalScore = Math.round(\n    results.security.score * 0.25 +\n    results.performance.score * 0.20 +\n    results.codeQuality.score * 0.20 +\n    results.dataIntegrity.score * 0.15 +\n    results.errorHandling.score * 0.10 +\n    results.deployment.score * 0.10\n  );\n  \n  // Visa resultat i konsolen\n  console.log('═══════════════════════════════════════════════════');\n  console.log('     UNGDOMSSTÖD V2 - SYSTEM AUDIT RESULTAT       ');\n  console.log('═══════════════════════════════════════════════════\\n');\n  \n  console.log(`📊 TOTAL SCORE: ${getColoredScore(totalScore)}%\\n`);\n  \n  console.log(`🔒 SÄKERHET: ${getColoredScore(results.security.score)}%`);\n  console.log(`   ✅ ${results.security.passed.length} passed`);\n  console.log(`   ⚠️  ${results.security.warnings.length} warnings`);\n  console.log(`   ❌ ${results.security.criticalIssues.length} critical\\n`);\n  \n  console.log(`⚡ PERFORMANCE: ${getColoredScore(results.performance.score)}%`);\n  console.log(`   ✅ ${results.performance.passed.length} passed`);\n  console.log(`   ⚠️  ${results.performance.warnings.length} warnings\\n`);\n  \n  console.log(`📝 KOD KVALITET: ${getColoredScore(results.codeQuality.score)}%`);\n  console.log(`   ✅ ${results.codeQuality.passed.length} passed`);\n  console.log(`   ⚠️  ${results.codeQuality.warnings.length} warnings\\n`);\n  \n  // Samla alla kritiska problem\n  const allCritical: string[] = [];\n  const allWarnings: string[] = [];\n  \n  Object.values(results).forEach(r => {\n    allCritical.push(...r.criticalIssues);\n    allWarnings.push(...r.warnings);\n  });\n  \n  if (allCritical.length > 0) {\n    console.log('❌ KRITISKA PROBLEM:');\n    allCritical.forEach(issue => console.log(`   - ${issue}`));\n    console.log('');\n  }\n  \n  if (allWarnings.length > 0 && allWarnings.length <= 5) {\n    console.log('⚠️  TOP VARNINGAR:');\n    allWarnings.slice(0, 5).forEach(warning => console.log(`   - ${warning}`));\n    console.log('');\n  }\n  \n  // Production readiness\n  console.log('═══════════════════════════════════════════════════');\n  if (totalScore >= 80) {\n    console.log('✅ SYSTEMET ÄR REDO FÖR PRODUKTION');\n  } else if (totalScore >= 60) {\n    console.log('⚠️  KAN DEPLOYAS MED FÖRSIKTIGHET');\n  } else {\n    console.log('❌ INTE REDO FÖR PRODUKTION');\n  }\n  console.log('═══════════════════════════════════════════════════\\n');\n  \n  // Spara JSON rapport\n  const report = {\n    timestamp: new Date().toISOString(),\n    totalScore,\n    results,\n    criticalIssues: allCritical,\n    warnings: allWarnings,\n    productionReady: totalScore >= 80\n  };\n  \n  fs.writeFileSync('audit-report.json', JSON.stringify(report, null, 2));\n  console.log('📄 Detaljerad rapport sparad: audit-report.json');\n  \n  // Generera HTML dashboard\n  generateHTMLDashboard(report);\n  console.log('📊 HTML Dashboard genererad: audit-dashboard.html');\n}\n\nfunction getColoredScore(score: number): string {\n  if (score >= 80) return `\\x1b[32m${score}\\x1b[0m`; // Green\n  if (score >= 60) return `\\x1b[33m${score}\\x1b[0m`; // Yellow\n  return `\\x1b[31m${score}\\x1b[0m`; // Red\n}\n\nfunction generateHTMLDashboard(report: AuditReport) {\n  const html = `<!DOCTYPE html>\n<html>\n<head>\n  <title>Ungdomsstöd V2 - Audit Dashboard</title>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; background: #f5f5f5; }\n    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n    h1 { color: #333; border-bottom: 3px solid #007bff; padding-bottom: 10px; }\n    .score-card { display: inline-block; padding: 20px; margin: 10px; border-radius: 8px; text-align: center; min-width: 150px; }\n    .score-high { background: #d4edda; color: #155724; }\n    .score-medium { background: #fff3cd; color: #856404; }\n    .score-low { background: #f8d7da; color: #721c24; }\n    .score-number { font-size: 48px; font-weight: bold; }\n    .score-label { font-size: 14px; text-transform: uppercase; margin-top: 10px; }\n    table { width: 100%; border-collapse: collapse; margin: 20px 0; }\n    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }\n    th { background: #f8f9fa; font-weight: 600; }\n    .passed { color: #28a745; }\n    .warning { color: #ffc107; }\n    .critical { color: #dc3545; }\n    .timestamp { color: #6c757d; font-size: 14px; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h1>🔍 Ungdomsstöd V2 - System Audit Dashboard</h1>\n    <p class=\"timestamp\">Generated: ${report.timestamp}</p>\n    \n    <div style=\"text-align: center; margin: 30px 0;\">\n      <div class=\"score-card ${report.totalScore >= 80 ? 'score-high' : report.totalScore >= 60 ? 'score-medium' : 'score-low'}\">\n        <div class=\"score-number\">${report.totalScore}%</div>\n        <div class=\"score-label\">Total Score</div>\n      </div>\n    </div>\n    \n    <h2>📊 Delresultat</h2>\n    <table>\n      <thead>\n        <tr>\n          <th>Kategori</th>\n          <th>Score</th>\n          <th>✅ Passed</th>\n          <th>⚠️ Warnings</th>\n          <th>❌ Critical</th>\n        </tr>\n      </thead>\n      <tbody>\n        ${Object.entries(report.results).map(([key, value]: [string, any]) => `\n          <tr>\n            <td>${key.charAt(0).toUpperCase() + key.slice(1)}</td>\n            <td><strong>${value.score}%</strong></td>\n            <td class=\"passed\">${value.passed.length}</td>\n            <td class=\"warning\">${value.warnings.length}</td>\n            <td class=\"critical\">${value.criticalIssues.length}</td>\n          </tr>\n        `).join('')}\n      </tbody>\n    </table>\n    \n    ${report.criticalIssues.length > 0 ? `\n      <h2>❌ Kritiska Problem</h2>\n      <ul>\n        ${report.criticalIssues.map((issue: string) => `<li>${issue}</li>`).join('')}\n      </ul>\n    ` : ''}\n    \n    <h2>📈 Production Readiness</h2>\n    <p style=\"font-size: 24px; font-weight: bold; color: ${report.productionReady ? '#28a745' : '#dc3545'}\">\n      ${report.productionReady ? '✅ Ready for Production' : '❌ Not Ready for Production'}\n    </p>\n  </div>\n</body>\n</html>`;\n  \n  fs.writeFileSync('audit-dashboard.html', html);\n}\n\n// Kör audit\ngenerateCompleteReport().catch(console.error);\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/migrate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/quick-security-check.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/security-validation.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fs' is defined but never used.","line":8,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":9,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'auditMiddleware' is defined but never used.","line":11,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'initDatabase' is defined but never used.","line":20,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'closeDatabase' is defined but never used.","line":20,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'staffIds' is assigned a value but never used.","line":429,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":429,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'migrationLock' is assigned a value but never used.","line":453,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":453,"endColumn":28}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Security Validation Script\n * Comprehensive security testing for all implemented features\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport Database from 'better-sqlite3';\nimport fs from 'fs';\nimport path from 'path';\nimport { randomUUID } from 'crypto';\nimport AuditLogger, { auditMiddleware, type AuditAction } from '../server/utils/audit-logger.js';\nimport FeatureFlagManager, { type FeatureFlag } from '../server/utils/feature-flags.js';\nimport { \n  generateIdempotencyKey,\n  checkIdempotencyKey,\n  storeIdempotencyKey,\n  cleanupExpiredIdempotencyKeys,\n  getIdempotencyStats\n} from '../server/utils/idempotency.js';\nimport { initDatabase, closeDatabase } from '../server/database/connection.js';\nimport type { Request, Response } from 'express';\n\n// Test database path\nconst TEST_DB_PATH = ':memory:';\n\ndescribe('Security Validation Suite', () => {\n  let db: Database.Database;\n  let auditLogger: AuditLogger;\n  let featureFlagManager: FeatureFlagManager;\n\n  beforeAll(async () => {\n    // Initialize test database\n    db = new Database(TEST_DB_PATH);\n    auditLogger = new AuditLogger(db);\n    featureFlagManager = new FeatureFlagManager(db);\n  });\n\n  afterAll(() => {\n    if (db) {\n      db.close();\n    }\n  });\n\n  beforeEach(() => {\n    // Clean up before each test\n    cleanupExpiredIdempotencyKeys();\n  });\n\n  describe('1. CSP Headers Validation', () => {\n    it('should block inline scripts in production mode', () => {\n      const NODE_ENV = process.env.NODE_ENV;\n      \n      // Test CSP configuration from server/index.ts\n      const helmetConfig = NODE_ENV === 'production'\n        ? ({\n            contentSecurityPolicy: {\n              directives: {\n                defaultSrc: [\"'self'\"],\n                scriptSrc: [\"'self'\", \"'unsafe-inline'\"], // This should be restricted\n                styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n                imgSrc: [\"'self'\", \"data:\", \"blob:\"],\n                connectSrc: [\"'self'\"],\n                fontSrc: [\"'self'\"],\n                objectSrc: [\"'none'\"],\n                mediaSrc: [\"'self'\"],\n                frameSrc: [\"'none'\"],\n                formAction: [\"'self'\"],\n                baseUri: [\"'self'\"],\n                manifestSrc: [\"'self'\"]\n              }\n            }\n          } as const)\n        : ({ contentSecurityPolicy: false as const });\n\n      // In production, we should NOT allow 'unsafe-inline' for scripts\n      if (NODE_ENV === 'production') {\n        const cspConfig = helmetConfig.contentSecurityPolicy;\n        if (cspConfig && typeof cspConfig !== 'boolean') {\n          expect(cspConfig.directives?.scriptSrc)\n            .not.toContain(\"'unsafe-inline'\");\n        }\n      }\n    });\n\n    it('should have proper security headers configured', () => {\n      const helmetConfig = {\n        hsts: {\n          maxAge: 31536000, // 1 year\n          includeSubDomains: true,\n          preload: true\n        },\n        xFrameOptions: { action: 'deny' },\n        xContentTypeOptions: true,\n        referrerPolicy: { policy: ['strict-origin-when-cross-origin'] },\n        permissionsPolicy: {\n          camera: [],\n          microphone: [],\n          geolocation: [],\n          payment: []\n        }\n      };\n\n      expect(helmetConfig.hsts.maxAge).toBe(31536000);\n      expect(helmetConfig.xFrameOptions.action).toBe('deny');\n      expect(helmetConfig.xContentTypeOptions).toBe(true);\n      expect(helmetConfig.permissionsPolicy.camera).toEqual([]);\n    });\n  });\n\n  describe('2. Audit Logging System', () => {\n    it('should log critical operations', async () => {\n      const mockReq = {\n        user: { userId: 'test-user', email: 'test@example.com' },\n        ip: '127.0.0.1',\n        connection: { remoteAddress: '127.0.0.1' },\n        get: (header: string) => header === 'User-Agent' ? 'Test-Agent' : undefined\n      } as unknown as Request;\n\n      const mockRes = {} as Response;\n\n      // Test logging different critical operations\n      const criticalActions: AuditAction[] = [\n        'LOGIN',\n        'LOGIN_FAILED',\n        'USER_CREATED',\n        'CLIENT_DELETED',\n        'ADMIN_ACTION',\n        'SECURITY_VIOLATION',\n        'DATA_EXPORT'\n      ];\n\n      for (const action of criticalActions) {\n        await auditLogger.logEvent(\n          mockReq,\n          mockRes,\n          action,\n          'test-resource',\n          { test: 'data' },\n          'test-id',\n          true\n        );\n      }\n\n      // Verify logs were created\n      const logs = auditLogger.getAuditLogs({ limit: 10 });\n      expect(logs.length).toBeGreaterThan(0);\n      \n      const loggedActions = logs.map(log => log.action);\n      for (const action of criticalActions) {\n        expect(loggedActions).toContain(action);\n      }\n    });\n\n    it('should sanitize sensitive data in audit logs', async () => {\n      const mockReq = {\n        user: { userId: 'test-user', email: 'test@example.com' },\n        ip: '127.0.0.1',\n        get: () => 'Test-Agent'\n      } as unknown as Request;\n\n      const mockRes = {} as Response;\n\n      const sensitiveData = {\n        password: 'secret123',\n        password_hash: 'hashed_password',\n        token: 'jwt_token',\n        secret: 'api_secret'\n      };\n\n      await auditLogger.logEvent(\n        mockReq,\n        mockRes,\n        'USER_CREATED',\n        'users',\n        sensitiveData,\n        'user-123',\n        true\n      );\n\n      const logs = auditLogger.getAuditLogs({ limit: 1 });\n      expect(logs).toHaveLength(1);\n      \n      const [firstLog] = logs;\n      if (!firstLog) {\n        throw new Error('Expected audit log entry');\n      }\n\n      const loggedDetails = firstLog.details;\n      expect(loggedDetails.password).toBe('[REDACTED]');\n      expect(loggedDetails.password_hash).toBe('[REDACTED]');\n      expect(loggedDetails.token).toBe('[REDACTED]');\n      expect(loggedDetails.secret).toBe('[REDACTED]');\n    });\n\n    it('should track security violations', async () => {\n      const mockReq = {\n        user: { userId: 'attacker', email: 'attacker@example.com' },\n        ip: '192.168.1.100',\n        get: () => 'Malicious-Agent'\n      } as unknown as Request;\n\n      const mockRes = {} as Response;\n\n      await auditLogger.logEvent(\n        mockReq,\n        mockRes,\n        'SECURITY_VIOLATION',\n        'system',\n        { \n          violation_type: 'sql_injection_attempt',\n          payload: \"'; DROP TABLE users; --\"\n        },\n        undefined,\n        false,\n        'SQL injection attempt detected'\n      );\n\n      const violations = auditLogger.getSecurityViolations();\n      expect(violations.length).toBeGreaterThan(0);\n      \n      const [violation] = violations;\n      if (!violation) {\n        throw new Error('Expected security violation entry');\n      }\n\n      expect(violation.action).toBe('SECURITY_VIOLATION');\n      expect(violation.success).toBe(false);\n      expect(violation.errorMessage).toBe('SQL injection attempt detected');\n    });\n\n    it('should provide audit statistics', () => {\n      const stats = auditLogger.getStats();\n      \n      expect(stats).toHaveProperty('totalLogs');\n      expect(stats).toHaveProperty('securityViolations');\n      expect(stats).toHaveProperty('failedLogins');\n      expect(stats).toHaveProperty('adminActions');\n      expect(stats).toHaveProperty('lastActivity');\n      \n      expect(typeof stats.totalLogs).toBe('number');\n      expect(typeof stats.securityViolations).toBe('number');\n      expect(typeof stats.failedLogins).toBe('number');\n      expect(typeof stats.adminActions).toBe('number');\n    });\n  });\n\n  describe('3. Feature Flags System', () => {\n    it('should evaluate flags correctly for different users', () => {\n      // Test environment-based evaluation\n      const devFlag = featureFlagManager.evaluateFlag('new_dashboard_ui', 'user1', 'admin', 'development');\n      const prodFlag = featureFlagManager.evaluateFlag('new_dashboard_ui', 'user1', 'admin', 'production');\n      \n      expect(devFlag.flagName).toBe('new_dashboard_ui');\n      expect(prodFlag.flagName).toBe('new_dashboard_ui');\n      \n      // Environment should affect flag evaluation\n      if (devFlag.enabled !== prodFlag.enabled) {\n        expect(devFlag.reason).toContain('Environment');\n        expect(prodFlag.reason).toContain('Environment');\n      }\n    });\n\n    it('should handle rollout percentages correctly', () => {\n      // Test percentage-based rollout\n      const flag = featureFlagManager.evaluateFlag('real_time_notifications', 'user1', 'staff', 'staging');\n      \n      expect(flag.flagName).toBe('real_time_notifications');\n      expect(typeof flag.enabled).toBe('boolean');\n      expect(flag.reason).toBeDefined();\n    });\n\n    it('should respect target users and roles', () => {\n      // Create a test flag with specific targets\n      const testFlag: Omit<FeatureFlag, 'id' | 'createdAt' | 'updatedAt'> = {\n        name: 'test_target_flag',\n        description: 'Test flag with targets',\n        enabled: true,\n        rolloutPercentage: 100,\n        targetUsers: ['specific-user'],\n        targetRoles: ['admin'],\n        environment: 'all',\n        createdBy: 'test',\n        metadata: {}\n      };\n\n      featureFlagManager.createFlag(testFlag);\n\n      // Test target user\n      const targetUserFlag = featureFlagManager.evaluateFlag('test_target_flag', 'specific-user', 'admin');\n      expect(targetUserFlag.enabled).toBe(true);\n      expect(targetUserFlag.reason).toBe('User in target list');\n\n      // Test non-target user\n      const nonTargetUserFlag = featureFlagManager.evaluateFlag('test_target_flag', 'other-user', 'staff');\n      expect(nonTargetUserFlag.enabled).toBe(false);\n      expect(nonTargetUserFlag.reason).toBe('User not in target list');\n\n      // Clean up\n      featureFlagManager.deleteFlag('test_target_flag');\n    });\n\n    it('should handle expired flags', () => {\n      // Create a flag that expires in the past\n      const expiredFlag: Omit<FeatureFlag, 'id' | 'createdAt' | 'updatedAt'> = {\n        name: 'expired_flag',\n        description: 'Expired test flag',\n        enabled: true,\n        rolloutPercentage: 100,\n        targetUsers: [],\n        targetRoles: [],\n        environment: 'all',\n        createdBy: 'test',\n        expiresAt: new Date(Date.now() - 1000).toISOString(), // 1 second ago\n        metadata: {}\n      };\n\n      featureFlagManager.createFlag(expiredFlag);\n\n      const evaluation = featureFlagManager.evaluateFlag('expired_flag');\n      expect(evaluation.enabled).toBe(false);\n      expect(evaluation.reason).toBe('Flag expired');\n\n      // Clean up\n      featureFlagManager.deleteFlag('expired_flag');\n    });\n\n    it('should cache flags for performance', () => {\n      // Evaluate flag multiple times\n      const start = Date.now();\n      for (let i = 0; i < 100; i++) {\n        featureFlagManager.evaluateFlag('advanced_reporting', `user${i}`, 'staff');\n      }\n      const duration = Date.now() - start;\n\n      // Should be fast due to caching (less than 100ms for 100 evaluations)\n      expect(duration).toBeLessThan(100);\n    });\n  });\n\n  describe('4. Migration Script Edge Cases', () => {\n    it('should handle corrupted V1 data gracefully', () => {\n      // Test data with missing required fields\n      const corruptedData = {\n        staff: [\n          { id: 'staff1' }, // Missing name\n          { id: 'staff2', name: 'Test Staff', invalidField: 'should be ignored' }\n        ],\n        clients: [\n          { id: 'client1', initials: 'AB' }, // Valid\n          { id: 'client2' }, // Missing initials\n          { id: 'client3', initials: '', name: 'Full Name' } // Empty initials\n        ],\n        carePlans: [\n          { id: 'plan1', clientId: 'client1', goals: [] }, // Valid\n          { id: 'plan2' }, // Missing clientId\n          { id: 'plan3', clientId: 'nonexistent', goals: ['goal1'] } // Invalid clientId\n        ]\n      };\n\n      // This should not throw errors\n      expect(() => {\n        // Simulate migration validation logic\n        const validStaff = corruptedData.staff.filter(s => s.name);\n        const validClients = corruptedData.clients.filter(c => c.initials && c.initials.trim());\n        const validPlans = corruptedData.carePlans.filter(p => \n          p.clientId && validClients.some(c => c.id === p.clientId)\n        );\n\n        expect(validStaff).toHaveLength(1);\n        expect(validClients).toHaveLength(1);\n        expect(validPlans).toHaveLength(1);\n      }).not.toThrow();\n    });\n\n    it('should handle large datasets efficiently', () => {\n      // Create large dataset\n      const largeDataset = {\n        staff: Array.from({ length: 1000 }, (_, i) => ({\n          id: `staff${i}`,\n          name: `Staff Member ${i}`,\n          email: `staff${i}@example.com`\n        })),\n        clients: Array.from({ length: 5000 }, (_, i) => ({\n          id: `client${i}`,\n          initials: `C${i}`,\n          name: `Client ${i}`\n        })),\n        carePlans: Array.from({ length: 10000 }, (_, i) => ({\n          id: `plan${i}`,\n          clientId: `client${i % 5000}`,\n          goals: [`Goal ${i}`]\n        }))\n      };\n\n      const start = Date.now();\n      \n      // Simulate migration processing\n      const processedStaff = largeDataset.staff.map(s => ({ ...s, v2Id: randomUUID() }));\n      const processedClients = largeDataset.clients.map(c => ({ ...c, v2Id: randomUUID() }));\n      const processedPlans = largeDataset.carePlans.map(p => ({ ...p, v2Id: randomUUID() }));\n      \n      const duration = Date.now() - start;\n\n      expect(processedStaff).toHaveLength(1000);\n      expect(processedClients).toHaveLength(5000);\n      expect(processedPlans).toHaveLength(10000);\n      \n      // Should process efficiently (less than 1 second for this dataset)\n      expect(duration).toBeLessThan(1000);\n    });\n\n    it('should validate data integrity during migration', () => {\n      const testData = {\n        staff: [\n          { id: 'staff1', name: 'Test Staff', email: 'staff@example.com' }\n        ],\n        clients: [\n          { id: 'client1', initials: 'AB', name: 'Test Client' }\n        ],\n        carePlans: [\n          { id: 'plan1', clientId: 'client1', goals: ['Goal 1', 'Goal 2'] }\n        ],\n        weeklyDocs: [\n          { id: 'doc1', clientId: 'client1', weekId: '2024-W01', content: 'Test content' }\n        ]\n      };\n\n      // Validate referential integrity\n      const staffIds = new Set(testData.staff.map(s => s.id));\n      const clientIds = new Set(testData.clients.map(c => c.id));\n      \n      const invalidCarePlans = testData.carePlans.filter(p => !clientIds.has(p.clientId));\n      const invalidWeeklyDocs = testData.weeklyDocs.filter(d => !clientIds.has(d.clientId));\n      \n      expect(invalidCarePlans).toHaveLength(0);\n      expect(invalidWeeklyDocs).toHaveLength(0);\n      \n      // Validate data completeness\n      const incompleteStaff = testData.staff.filter(s => !s.name || !s.email);\n      const incompleteClients = testData.clients.filter(c => !c.initials || !c.name);\n      \n      expect(incompleteStaff).toHaveLength(0);\n      expect(incompleteClients).toHaveLength(0);\n    });\n\n    it('should handle concurrent migration attempts', async () => {\n      // Simulate concurrent migration attempts\n      const migrationPromises = Array.from({ length: 5 }, async (_, i) => {\n        // Simulate migration process\n        const backupData = { timestamp: new Date().toISOString(), attempt: i };\n        \n        // Check if migration is already in progress\n        const migrationLock = `migration_in_progress_${i}`;\n        \n        // Simulate lock acquisition\n        const lockAcquired = Math.random() > 0.3; // 70% success rate\n        \n        if (lockAcquired) {\n          // Simulate migration work\n          await new Promise(resolve => setTimeout(resolve, 10));\n          return { success: true, attempt: i, backupData };\n        } else {\n          return { success: false, attempt: i, error: 'Migration already in progress' };\n        }\n      });\n\n      const results = await Promise.all(migrationPromises);\n      \n      const successful = results.filter(r => r.success);\n      const failed = results.filter(r => !r.success);\n      \n      expect(successful.length).toBeGreaterThan(0);\n      expect(failed.length).toBeGreaterThan(0);\n      \n      // At least one should succeed, at least one should fail due to concurrency\n      expect(successful.length + failed.length).toBe(5);\n    });\n  });\n\n  describe('5. Rate Limiting and Security', () => {\n    it('should enforce rate limits', () => {\n      // Test rate limiting configuration from server/index.ts\n      const rateLimitConfig = {\n        windowMs: 15 * 60 * 1000, // 15 minutes\n        max: 100, // 100 requests per window\n        message: {\n          success: false,\n          error: 'Too many requests',\n          message: 'Please try again later'\n        }\n      };\n\n      expect(rateLimitConfig.windowMs).toBe(15 * 60 * 1000);\n      expect(rateLimitConfig.max).toBe(100);\n      expect(rateLimitConfig.message.error).toBe('Too many requests');\n    });\n\n    it('should handle authentication properly', () => {\n      const validToken = 'valid-jwt-token';\n      const invalidToken = 'invalid-token';\n      const devToken = 'dev-token-for-testing';\n\n      // Test token validation logic\n      const isValidJWT = (token: string) => {\n        return token.startsWith('eyJ') && token.split('.').length === 3;\n      };\n\n      const isDevToken = (token: string) => {\n        return token === devToken;\n      };\n\n      expect(isValidJWT(validToken)).toBe(false); // Not a real JWT format\n      expect(isDevToken(devToken)).toBe(true);\n      expect(isDevToken(invalidToken)).toBe(false);\n    });\n  });\n\n  describe('6. Idempotency System', () => {\n    it('should prevent duplicate operations', () => {\n      const key = generateIdempotencyKey();\n      const operation = 'POST /api/clients';\n      const requestHash = 'test-hash-123';\n      const response = { success: true, data: { id: 'client-123' } };\n\n      // First operation\n      storeIdempotencyKey(key, operation, requestHash, response);\n      \n      // Duplicate operation should return same response\n      const duplicateResponse = checkIdempotencyKey(key);\n      expect(duplicateResponse).not.toBeNull();\n      expect(duplicateResponse!.response).toBe(JSON.stringify(response));\n    });\n\n    it('should handle idempotency key expiration', () => {\n      const stats = getIdempotencyStats();\n      expect(stats).toHaveProperty('total');\n      expect(stats).toHaveProperty('expired');\n      expect(stats).toHaveProperty('pending');\n      expect(stats).toHaveProperty('completed');\n      \n      // Cleanup should not throw errors\n      expect(() => cleanupExpiredIdempotencyKeys()).not.toThrow();\n    });\n\n    it('should handle concurrent idempotency operations', () => {\n      const keys = Array.from({ length: 10 }, () => generateIdempotencyKey());\n      \n      // Store multiple operations concurrently\n      keys.forEach((key, index) => {\n        storeIdempotencyKey(key, `POST /api/test/${index}`, `hash-${index}`, { id: index });\n      });\n\n      // Verify all operations are retrievable\n      keys.forEach((key, index) => {\n        const result = checkIdempotencyKey(key);\n        expect(result).not.toBeNull();\n        expect(result!.response).toBe(JSON.stringify({ id: index }));\n      });\n    });\n  });\n\n  describe('7. Data Validation and Sanitization', () => {\n    it('should sanitize user input', () => {\n      const maliciousInputs = [\n        \"<script>alert('xss')</script>\",\n        \"'; DROP TABLE users; --\",\n        \"../../etc/passwd\",\n        \"javascript:alert('xss')\",\n        \"<img src=x onerror=alert('xss')>\"\n      ];\n\n      const sanitizeInput = (input: string) => {\n        return input\n          .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n          .replace(/[<>]/g, '')\n          .replace(/javascript:/gi, '')\n          .replace(/\\.\\./g, '');\n      };\n\n      maliciousInputs.forEach(input => {\n        const sanitized = sanitizeInput(input);\n        expect(sanitized).not.toContain('<script>');\n        expect(sanitized).not.toContain('</script>');\n        expect(sanitized).not.toContain('javascript:');\n        expect(sanitized).not.toContain('..');\n      });\n    });\n\n    it('should validate data types and formats', () => {\n      const validators = {\n        email: (email: string) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email),\n        uuid: (id: string) => /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id),\n        weekId: (weekId: string) => /^\\d{4}-W\\d{2}$/.test(weekId),\n        monthId: (monthId: string) => /^\\d{4}-\\d{2}$/.test(monthId)\n      };\n\n      expect(validators.email('test@example.com')).toBe(true);\n      expect(validators.email('invalid-email')).toBe(false);\n      \n      expect(validators.uuid(randomUUID())).toBe(true);\n      expect(validators.uuid('invalid-uuid')).toBe(false);\n      \n      expect(validators.weekId('2024-W01')).toBe(true);\n      expect(validators.weekId('2024-01')).toBe(false);\n      \n      expect(validators.monthId('2024-01')).toBe(true);\n      expect(validators.monthId('2024-W01')).toBe(false);\n    });\n  });\n\n  describe('8. Performance and Scalability', () => {\n    it('should handle large audit log queries efficiently', () => {\n      const start = Date.now();\n      \n      // Query audit logs\n      const logs = auditLogger.getAuditLogs({ limit: 1000 });\n      \n      const duration = Date.now() - start;\n      \n      expect(duration).toBeLessThan(100); // Should be fast even with large datasets\n      expect(Array.isArray(logs)).toBe(true);\n    });\n\n    it('should handle feature flag evaluation at scale', () => {\n      const start = Date.now();\n      \n      // Evaluate flags for many users\n      const evaluations = Array.from({ length: 1000 }, (_, i) => \n        featureFlagManager.evaluateFlag('advanced_reporting', `user${i}`, 'staff')\n      );\n      \n      const duration = Date.now() - start;\n      \n      expect(evaluations).toHaveLength(1000);\n      expect(duration).toBeLessThan(200); // Should be fast due to caching\n    });\n\n    it('should handle concurrent database operations', async () => {\n      const start = Date.now();\n      \n      // Simulate concurrent database operations\n      const operations = Array.from({ length: 100 }, async (_, i) => {\n        const key = generateIdempotencyKey();\n        storeIdempotencyKey(key, `POST /api/test/${i}`, `hash-${i}`, { id: i });\n        return checkIdempotencyKey(key);\n      });\n      \n      const results = await Promise.all(operations);\n      const duration = Date.now() - start;\n      \n      expect(results).toHaveLength(100);\n      expect(results.every(r => r !== null)).toBe(true);\n      expect(duration).toBeLessThan(500); // Should handle concurrency efficiently\n    });\n  });\n\n  describe('9. Error Handling and Recovery', () => {\n    it('should handle database connection failures gracefully', () => {\n      // Test error handling for database operations\n      expect(() => {\n        try {\n          // Simulate database error\n          throw new Error('Database connection failed');\n        } catch (error: unknown) {\n          // Should handle gracefully\n          if (error instanceof Error) {\n            expect(error.message).toBe('Database connection failed');\n          } else {\n            throw error;\n          }\n        }\n      }).not.toThrow();\n    });\n\n    it('should handle malformed audit log data', () => {\n      // Test handling of invalid audit log data\n      const invalidLogData = {\n        id: null,\n        timestamp: 'invalid-date',\n        userId: undefined,\n        action: 'INVALID_ACTION',\n        details: 'not-json'\n      };\n\n      // Should handle gracefully without crashing\n      expect(() => {\n        // Simulate processing invalid data\n        const processed = {\n          ...invalidLogData,\n          id: invalidLogData.id || randomUUID(),\n          userId: invalidLogData.userId || 'unknown',\n          details: typeof invalidLogData.details === 'string' ? \n            { error: 'Invalid details' } : invalidLogData.details\n        };\n        \n        expect(processed.id).toBeDefined();\n        expect(processed.userId).toBe('unknown');\n      }).not.toThrow();\n    });\n\n    it('should handle feature flag evaluation errors', () => {\n      // Test evaluation of non-existent flag\n      const evaluation = featureFlagManager.evaluateFlag('non_existent_flag');\n      \n      expect(evaluation.enabled).toBe(false);\n      expect(evaluation.reason).toBe('Flag not found');\n      expect(evaluation.flagName).toBe('non_existent_flag');\n    });\n  });\n\n  describe('10. Security Headers Validation', () => {\n    it('should have all required security headers', () => {\n      const requiredHeaders = [\n        'Content-Security-Policy',\n        'X-Frame-Options',\n        'X-Content-Type-Options',\n        'Referrer-Policy',\n        'Permissions-Policy',\n        'Strict-Transport-Security'\n      ];\n\n      const securityHeaders = {\n        'Content-Security-Policy': \"default-src 'self'\",\n        'X-Frame-Options': 'DENY',\n        'X-Content-Type-Options': 'nosniff',\n        'Referrer-Policy': 'strict-origin-when-cross-origin',\n        'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',\n        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload'\n      };\n\n      requiredHeaders.forEach(header => {\n        expect(securityHeaders).toHaveProperty(header);\n        expect(securityHeaders[header as keyof typeof securityHeaders]).toBeDefined();\n      });\n    });\n\n    it('should block dangerous content types', () => {\n      const dangerousTypes = [\n        'application/javascript',\n        'text/javascript',\n        'application/x-javascript'\n      ];\n\n      const blockedTypes = dangerousTypes.filter(type => {\n        // Simulate CSP blocking\n        return type.includes('javascript');\n      });\n\n      expect(blockedTypes).toHaveLength(3);\n    });\n  });\n});\n\n// Export test results for reporting\nexport interface SecurityTestResults {\n  cspHeaders: boolean;\n  auditLogging: boolean;\n  featureFlags: boolean;\n  migrationScripts: boolean;\n  rateLimiting: boolean;\n  idempotency: boolean;\n  dataValidation: boolean;\n  performance: boolean;\n  errorHandling: boolean;\n  securityHeaders: boolean;\n}\n\nexport async function runSecurityValidation(): Promise<SecurityTestResults> {\n  // This would be called by the main validation script\n  // For now, return mock results\n  return {\n    cspHeaders: true,\n    auditLogging: true,\n    featureFlags: true,\n    migrationScripts: true,\n    rateLimiting: true,\n    idempotency: true,\n    dataValidation: true,\n    performance: true,\n    errorHandling: true,\n    securityHeaders: true\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/simple-migrate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/simple-seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/test-migration.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/test-security.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/scripts/v1-to-v2-migration.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7855,7858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7855,7858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env tsx\n\n/**\n * V1 → V2 Migration Script\n * Migrates data from localStorage-based V1 system to V2 SQLite database\n * Handles data validation, deduplication, and backup creation\n * \n * SÄKERHETSFIXAR:\n * - SQLite transactions för alla databas-operationer\n * - Record count validering före/efter migration\n * - --dry-run flag för säker testning\n * - Automatisk backup med timestamp före migration\n */\n\nimport Database from 'better-sqlite3';\nimport { readFileSync, writeFileSync, existsSync, copyFileSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport { mkdirSync } from 'fs';\nimport { randomUUID } from 'crypto';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst DB_PATH = join(__dirname, '..', 'data', 'ungdomsstod.db');\nconst BACKUP_DIR = join(__dirname, '..', 'backups');\nconst V1_DATA_FILE = join(__dirname, '..', 'v1-export.json');\n\ninterface V1Staff {\n  id: string;\n  name: string;\n  email: string;\n  role: 'admin' | 'staff';\n}\n\ninterface V1Client {\n  id: string;\n  initials: string;\n  name: string;\n  staffId: string;\n}\n\ninterface V1CarePlan {\n  id: string;\n  clientId: string;\n  carePlanDate: string;\n  hasGfp: boolean;\n  staffNotified: boolean;\n  notes?: string;\n}\n\ninterface V1WeeklyDoc {\n  id: string;\n  clientId: string;\n  weekId: string;\n  monday: boolean;\n  tuesday: boolean;\n  wednesday: boolean;\n  thursday: boolean;\n  friday: boolean;\n  saturday: boolean;\n  sunday: boolean;\n  status: 'pending' | 'approved' | 'rejected';\n}\n\ninterface V1MonthlyReport {\n  id: string;\n  clientId: string;\n  monthId: string;\n  sent: boolean;\n  status: 'pending' | 'approved' | 'rejected';\n}\n\ninterface V1VismaWeek {\n  id: string;\n  clientId: string;\n  weekId: string;\n  monday: boolean;\n  tuesday: boolean;\n  wednesday: boolean;\n  thursday: boolean;\n  friday: boolean;\n  status: 'pending' | 'approved' | 'rejected';\n}\n\ninterface V1Data {\n  version: string;\n  staff: V1Staff[];\n  clients: V1Client[];\n  carePlans: V1CarePlan[];\n  weeklyDocs: V1WeeklyDoc[];\n  monthlyReports: V1MonthlyReport[];\n  vismaWeeks: V1VismaWeek[];\n  selectedClientId?: string;\n  selectedStaffId?: string;\n  view: string;\n}\n\ninterface MigrationCounts {\n  staff: number;\n  clients: number;\n  carePlans: number;\n  weeklyDocs: number;\n  monthlyReports: number;\n  vismaWeeks: number;\n}\n\nclass V1ToV2Migrator {\n  private db: Database.Database;\n  private migrationLog: string[] = [];\n  private isDryRun: boolean = false;\n  private preCount: MigrationCounts = { staff: 0, clients: 0, carePlans: 0, weeklyDocs: 0, monthlyReports: 0, vismaWeeks: 0 };\n  private postCount: MigrationCounts = { staff: 0, clients: 0, carePlans: 0, weeklyDocs: 0, monthlyReports: 0, vismaWeeks: 0 };\n\n  constructor(isDryRun: boolean = false) {\n    this.isDryRun = isDryRun;\n    \n    // Create backup directory\n    mkdirSync(BACKUP_DIR, { recursive: true });\n    \n    // Initialize database\n    this.db = new Database(DB_PATH);\n    this.db.pragma('foreign_keys = ON');\n    \n    if (isDryRun) {\n      this.log('🧪 Starting V1 → V2 migration (DRY RUN - no changes will be made)...');\n    } else {\n      this.log('🚀 Starting V1 → V2 migration...');\n    }\n  }\n\n  private log(message: string): void {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${message}`;\n    console.log(logMessage);\n    this.migrationLog.push(logMessage);\n  }\n\n  private async createBackup(): Promise<void> {\n    const timestamp = new Date().toISOString().replace(/[:.-]/g, '').split('T')[0] + '_' + \n                     new Date().toISOString().replace(/[:.-]/g, '').split('T')[1]?.substring(0, 6) || '000000';\n    const backupPath = join(BACKUP_DIR, `database.backup.${timestamp}.db`);\n    \n    if (existsSync(DB_PATH)) {\n      if (this.isDryRun) {\n        this.log(`📦 [DRY RUN] Would create backup: ${backupPath}`);\n      } else {\n        copyFileSync(DB_PATH, backupPath);\n        this.log(`📦 Created backup: ${backupPath}`);\n      }\n    } else {\n      this.log('⚠️  No existing database found - skipping backup');\n    }\n  }\n\n  private async countRecords(): Promise<MigrationCounts> {\n    const counts: MigrationCounts = {\n      staff: 0,\n      clients: 0,\n      carePlans: 0,\n      weeklyDocs: 0,\n      monthlyReports: 0,\n      vismaWeeks: 0\n    };\n\n    try {\n      counts.staff = (this.db.prepare('SELECT COUNT(*) as count FROM users').get() as { count: number })?.count || 0;\n      counts.clients = (this.db.prepare('SELECT COUNT(*) as count FROM clients').get() as { count: number })?.count || 0;\n      counts.carePlans = (this.db.prepare('SELECT COUNT(*) as count FROM care_plans').get() as { count: number })?.count || 0;\n      counts.weeklyDocs = (this.db.prepare('SELECT COUNT(*) as count FROM weekly_docs').get() as { count: number })?.count || 0;\n      counts.monthlyReports = (this.db.prepare('SELECT COUNT(*) as count FROM monthly_reports').get() as { count: number })?.count || 0;\n      counts.vismaWeeks = (this.db.prepare('SELECT COUNT(*) as count FROM visma_time').get() as { count: number })?.count || 0;\n    } catch (error) {\n      this.log(`⚠️  Could not count existing records: ${error}`);\n    }\n\n    return counts;\n  }\n\n  private validateCounts(expectedStaff: number, expectedClients: number, expectedCarePlans: number, \n                        expectedWeeklyDocs: number, expectedMonthlyReports: number, expectedVismaWeeks: number): boolean {\n    const staffDiff = this.postCount.staff - this.preCount.staff;\n    const clientsDiff = this.postCount.clients - this.preCount.clients;\n    const carePlansDiff = this.postCount.carePlans - this.preCount.carePlans;\n    const weeklyDocsDiff = this.postCount.weeklyDocs - this.preCount.weeklyDocs;\n    const monthlyReportsDiff = this.postCount.monthlyReports - this.preCount.monthlyReports;\n    const vismaWeeksDiff = this.postCount.vismaWeeks - this.preCount.vismaWeeks;\n\n    this.log(`📊 Migration count validation:`);\n    this.log(`   Staff: expected +${expectedStaff}, actual +${staffDiff}`);\n    this.log(`   Clients: expected +${expectedClients}, actual +${clientsDiff}`);\n    this.log(`   Care Plans: expected +${expectedCarePlans}, actual +${carePlansDiff}`);\n    this.log(`   Weekly Docs: expected +${expectedWeeklyDocs}, actual +${weeklyDocsDiff}`);\n    this.log(`   Monthly Reports: expected +${expectedMonthlyReports}, actual +${monthlyReportsDiff}`);\n    this.log(`   Visma Weeks: expected +${expectedVismaWeeks}, actual +${vismaWeeksDiff}`);\n\n    const isValid = (\n      staffDiff === expectedStaff &&\n      clientsDiff === expectedClients &&\n      carePlansDiff === expectedCarePlans &&\n      weeklyDocsDiff === expectedWeeklyDocs &&\n      monthlyReportsDiff === expectedMonthlyReports &&\n      vismaWeeksDiff === expectedVismaWeeks\n    );\n\n    if (!isValid) {\n      this.log(`❌ Count validation FAILED! Expected vs actual counts do not match.`);\n    } else {\n      this.log(`✅ Count validation PASSED!`);\n    }\n\n    return isValid;\n  }\n\n  private validateV1Data(data: unknown): V1Data | null {\n    try {\n      // Basic structure validation\n      if (!data || typeof data !== 'object') {\n        throw new Error('Invalid data structure');\n      }\n\n      const dataObj = data as Record<string, unknown>;\n\n      if (!Array.isArray(dataObj.staff)) {\n        throw new Error('Staff data must be an array');\n      }\n\n      if (!Array.isArray(dataObj.clients)) {\n        throw new Error('Clients data must be an array');\n      }\n\n      // Validate required fields for staff\n      for (const staff of dataObj.staff) {\n        const staffObj = staff as Record<string, unknown>;\n        if (!staffObj.id || !staffObj.name || !staffObj.email) {\n          throw new Error(`Invalid staff record: ${JSON.stringify(staff)}`);\n        }\n        if (!['admin', 'staff'].includes(staffObj.role as string)) {\n          (staffObj as any).role = 'staff'; // Default fallback\n        }\n      }\n\n      // Validate required fields for clients\n      for (const client of dataObj.clients) {\n        const clientObj = client as Record<string, unknown>;\n        if (!clientObj.id || !clientObj.initials || !clientObj.name || !clientObj.staffId) {\n          throw new Error(`Invalid client record: ${JSON.stringify(client)}`);\n        }\n      }\n\n      this.log('✅ V1 data validation passed');\n      return data as V1Data;\n    } catch (error) {\n      this.log(`❌ V1 data validation failed: ${error}`);\n      return null;\n    }\n  }\n\n  private async migrateStaff(staffData: V1Staff[]): Promise<Map<string, string>> {\n    this.log(`👥 Migrating ${staffData.length} staff members...`);\n    const idMapping = new Map<string, string>();\n\n    if (this.isDryRun) {\n      // Dry run - just simulate the mapping\n      for (const staff of staffData) {\n        const newId = randomUUID();\n        idMapping.set(staff.id, newId);\n        this.log(`  🧪 [DRY RUN] Would migrate staff: ${staff.name} (${staff.email})`);\n      }\n      this.log(`✅ [DRY RUN] Staff migration simulation completed: ${idMapping.size} staff members`);\n      return idMapping;\n    }\n\n    const insertStaff = this.db.prepare(`\n      INSERT OR REPLACE INTO users (id, email, name, password_hash, role, is_active, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n\n    for (const staff of staffData) {\n      try {\n        // Generate new UUID for V2\n        const newId = randomUUID();\n        idMapping.set(staff.id, newId);\n        \n        // Hash password (default for migrated users - they'll need to reset)\n        const defaultPasswordHash = '$2a$10$default.hash.for.migrated.users';\n        \n        insertStaff.run(newId, staff.email, staff.name, defaultPasswordHash, staff.role, 1);\n        this.log(`  ✅ Migrated staff: ${staff.name} (${staff.email})`);\n      } catch (error) {\n        this.log(`  ❌ Failed to migrate staff ${staff.name}: ${error}`);\n        throw error; // Re-throw to trigger transaction rollback\n      }\n    }\n\n    this.log(`✅ Staff migration completed: ${idMapping.size} staff members`);\n    return idMapping;\n  }\n\n  private async migrateClients(clientData: V1Client[], staffIdMapping: Map<string, string>): Promise<Map<string, string>> {\n    this.log(`👤 Migrating ${clientData.length} clients...`);\n    const idMapping = new Map<string, string>();\n\n    if (this.isDryRun) {\n      // Dry run - just simulate the mapping\n      for (const client of clientData) {\n        const newStaffId = staffIdMapping.get(client.staffId);\n        if (!newStaffId) {\n          this.log(`  🧪 [DRY RUN] Would skip client ${client.name} - staff not found`);\n          continue;\n        }\n        const newId = randomUUID();\n        idMapping.set(client.id, newId);\n        this.log(`  🧪 [DRY RUN] Would migrate client: ${client.name} (${client.initials})`);\n      }\n      this.log(`✅ [DRY RUN] Client migration simulation completed: ${idMapping.size} clients`);\n      return idMapping;\n    }\n\n    const insertClient = this.db.prepare(`\n      INSERT OR REPLACE INTO clients (id, initials, name, staff_id, created_at, updated_at)\n      VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n\n    for (const client of clientData) {\n      try {\n        const newId = randomUUID();\n        const newStaffId = staffIdMapping.get(client.staffId);\n        \n        if (!newStaffId) {\n          this.log(`  ⚠️  Skipping client ${client.name} - staff not found`);\n          continue;\n        }\n\n        idMapping.set(client.id, newId);\n        insertClient.run(newId, client.initials, client.name, newStaffId);\n        this.log(`  ✅ Migrated client: ${client.name} (${client.initials})`);\n      } catch (error) {\n        this.log(`  ❌ Failed to migrate client ${client.name}: ${error}`);\n        throw error; // Re-throw to trigger transaction rollback\n      }\n    }\n\n    this.log(`✅ Client migration completed: ${idMapping.size} clients`);\n    return idMapping;\n  }\n\n  private async migrateCarePlans(carePlanData: V1CarePlan[], clientIdMapping: Map<string, string>): Promise<number> {\n    this.log(`📋 Migrating ${carePlanData.length} care plans...`);\n\n    let migrated = 0;\n    for (const carePlan of carePlanData) {\n      const newClientId = clientIdMapping.get(carePlan.clientId);\n      if (!newClientId) {\n        continue;\n      }\n      migrated++;\n    }\n\n    if (this.isDryRun) {\n      this.log(`✅ [DRY RUN] Care plans migration simulation completed: ${migrated} care plans`);\n      return migrated;\n    }\n\n    const insertCarePlan = this.db.prepare(`\n      INSERT OR REPLACE INTO care_plans (id, client_id, care_plan_date, has_gfp, staff_notified, notes, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n\n    migrated = 0;\n    for (const carePlan of carePlanData) {\n      try {\n        const newId = randomUUID();\n        const newClientId = clientIdMapping.get(carePlan.clientId);\n        \n        if (!newClientId) {\n          continue;\n        }\n\n        insertCarePlan.run(\n          newId,\n          newClientId,\n          carePlan.carePlanDate,\n          carePlan.hasGfp ? 1 : 0,\n          carePlan.staffNotified ? 1 : 0,\n          carePlan.notes || null\n        );\n        migrated++;\n      } catch (error) {\n        this.log(`  ❌ Failed to migrate care plan: ${error}`);\n        throw error; // Re-throw to trigger transaction rollback\n      }\n    }\n\n    this.log(`✅ Care plans migration completed: ${migrated} care plans`);\n    return migrated;\n  }\n\n  private async migrateWeeklyDocs(weeklyDocData: V1WeeklyDoc[], clientIdMapping: Map<string, string>): Promise<number> {\n    this.log(`📅 Migrating ${weeklyDocData.length} weekly documents...`);\n\n    let migrated = 0;\n    for (const weeklyDoc of weeklyDocData) {\n      const newClientId = clientIdMapping.get(weeklyDoc.clientId);\n      if (!newClientId) {\n        continue;\n      }\n      migrated++;\n    }\n\n    if (this.isDryRun) {\n      this.log(`✅ [DRY RUN] Weekly docs migration simulation completed: ${migrated} weekly documents`);\n      return migrated;\n    }\n\n    const insertWeeklyDoc = this.db.prepare(`\n      INSERT OR REPLACE INTO weekly_docs (id, client_id, week_id, monday, tuesday, wednesday, thursday, friday, saturday, sunday, status, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n\n    migrated = 0;\n    for (const weeklyDoc of weeklyDocData) {\n      try {\n        const newId = randomUUID();\n        const newClientId = clientIdMapping.get(weeklyDoc.clientId);\n        \n        if (!newClientId) {\n          continue;\n        }\n\n        insertWeeklyDoc.run(\n          newId,\n          newClientId,\n          weeklyDoc.weekId,\n          weeklyDoc.monday ? 1 : 0,\n          weeklyDoc.tuesday ? 1 : 0,\n          weeklyDoc.wednesday ? 1 : 0,\n          weeklyDoc.thursday ? 1 : 0,\n          weeklyDoc.friday ? 1 : 0,\n          weeklyDoc.saturday ? 1 : 0,\n          weeklyDoc.sunday ? 1 : 0,\n          weeklyDoc.status\n        );\n        migrated++;\n      } catch (error) {\n        this.log(`  ❌ Failed to migrate weekly doc: ${error}`);\n        throw error; // Re-throw to trigger transaction rollback\n      }\n    }\n\n    this.log(`✅ Weekly docs migration completed: ${migrated} weekly documents`);\n    return migrated;\n  }\n\n  private async migrateMonthlyReports(monthlyReportData: V1MonthlyReport[], clientIdMapping: Map<string, string>): Promise<number> {\n    this.log(`📊 Migrating ${monthlyReportData.length} monthly reports...`);\n\n    let migrated = 0;\n    for (const monthlyReport of monthlyReportData) {\n      const newClientId = clientIdMapping.get(monthlyReport.clientId);\n      if (!newClientId) {\n        continue;\n      }\n      migrated++;\n    }\n\n    if (this.isDryRun) {\n      this.log(`✅ [DRY RUN] Monthly reports migration simulation completed: ${migrated} monthly reports`);\n      return migrated;\n    }\n\n    const insertMonthlyReport = this.db.prepare(`\n      INSERT OR REPLACE INTO monthly_reports (id, client_id, month_id, sent, status, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n\n    migrated = 0;\n    for (const monthlyReport of monthlyReportData) {\n      try {\n        const newId = randomUUID();\n        const newClientId = clientIdMapping.get(monthlyReport.clientId);\n        \n        if (!newClientId) {\n          continue;\n        }\n\n        insertMonthlyReport.run(\n          newId,\n          newClientId,\n          monthlyReport.monthId,\n          monthlyReport.sent ? 1 : 0,\n          monthlyReport.status\n        );\n        migrated++;\n      } catch (error) {\n        this.log(`  ❌ Failed to migrate monthly report: ${error}`);\n        throw error; // Re-throw to trigger transaction rollback\n      }\n    }\n\n    this.log(`✅ Monthly reports migration completed: ${migrated} monthly reports`);\n    return migrated;\n  }\n\n  private async migrateVismaWeeks(vismaWeekData: V1VismaWeek[], clientIdMapping: Map<string, string>): Promise<number> {\n    this.log(`⏰ Migrating ${vismaWeekData.length} Visma weeks...`);\n\n    let migrated = 0;\n    for (const vismaWeek of vismaWeekData) {\n      const newClientId = clientIdMapping.get(vismaWeek.clientId);\n      if (!newClientId) {\n        continue;\n      }\n      migrated++;\n    }\n\n    if (this.isDryRun) {\n      this.log(`✅ [DRY RUN] Visma weeks migration simulation completed: ${migrated} Visma weeks`);\n      return migrated;\n    }\n\n    const insertVismaWeek = this.db.prepare(`\n      INSERT OR REPLACE INTO visma_time (id, client_id, week_id, monday, tuesday, wednesday, thursday, friday, status, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\n    `);\n\n    migrated = 0;\n    for (const vismaWeek of vismaWeekData) {\n      try {\n        const newId = randomUUID();\n        const newClientId = clientIdMapping.get(vismaWeek.clientId);\n        \n        if (!newClientId) {\n          continue;\n        }\n\n        insertVismaWeek.run(\n          newId,\n          newClientId,\n          vismaWeek.weekId,\n          vismaWeek.monday ? 1 : 0,\n          vismaWeek.tuesday ? 1 : 0,\n          vismaWeek.wednesday ? 1 : 0,\n          vismaWeek.thursday ? 1 : 0,\n          vismaWeek.friday ? 1 : 0,\n          vismaWeek.status\n        );\n        migrated++;\n      } catch (error) {\n        this.log(`  ❌ Failed to migrate Visma week: ${error}`);\n        throw error; // Re-throw to trigger transaction rollback\n      }\n    }\n\n    this.log(`✅ Visma weeks migration completed: ${migrated} Visma weeks`);\n    return migrated;\n  }\n\n  private async generateMigrationReport(): Promise<void> {\n    const reportPath = join(BACKUP_DIR, `migration-report-${new Date().toISOString().split('T')[0]}.txt`);\n    const report = this.migrationLog.join('\\n');\n    writeFileSync(reportPath, report);\n    this.log(`📄 Migration report saved: ${reportPath}`);\n  }\n\n  public async migrate(v1DataPath?: string): Promise<boolean> {\n    let transaction: Database.Transaction | null = null;\n    \n    try {\n      // Create backup\n      await this.createBackup();\n\n      // Load V1 data\n      const dataPath = v1DataPath || V1_DATA_FILE;\n      if (!existsSync(dataPath)) {\n        this.log(`❌ V1 data file not found: ${dataPath}`);\n        this.log('💡 Please export your V1 data first and place it in the expected location');\n        return false;\n      }\n\n      const rawData = JSON.parse(readFileSync(dataPath, 'utf-8'));\n      const v1Data = this.validateV1Data(rawData);\n      \n      if (!v1Data) {\n        return false;\n      }\n\n      this.log(`📊 Found V1 data: ${v1Data.staff.length} staff, ${v1Data.clients.length} clients`);\n\n      if (!this.isDryRun) {\n        // Count existing records before migration\n        this.preCount = await this.countRecords();\n        this.log(`📊 Pre-migration counts: Staff: ${this.preCount.staff}, Clients: ${this.preCount.clients}, Care Plans: ${this.preCount.carePlans}, Weekly Docs: ${this.preCount.weeklyDocs}, Monthly Reports: ${this.preCount.monthlyReports}, Visma Weeks: ${this.preCount.vismaWeeks}`);\n\n        // Start database transaction\n        this.log('🔄 Starting database transaction...');\n        transaction = this.db.transaction(() => {\n          // All migration logic will be executed within this transaction\n        });\n        \n        this.db.exec('BEGIN TRANSACTION');\n      }\n\n      // Start migration\n      const staffIdMapping = await this.migrateStaff(v1Data.staff);\n      const clientIdMapping = await this.migrateClients(v1Data.clients, staffIdMapping);\n      \n      const migratedCarePlans = await this.migrateCarePlans(v1Data.carePlans || [], clientIdMapping);\n      const migratedWeeklyDocs = await this.migrateWeeklyDocs(v1Data.weeklyDocs || [], clientIdMapping);\n      const migratedMonthlyReports = await this.migrateMonthlyReports(v1Data.monthlyReports || [], clientIdMapping);\n      const migratedVismaWeeks = await this.migrateVismaWeeks(v1Data.vismaWeeks || [], clientIdMapping);\n\n      if (!this.isDryRun) {\n        // Count records after migration\n        this.postCount = await this.countRecords();\n        this.log(`📊 Post-migration counts: Staff: ${this.postCount.staff}, Clients: ${this.postCount.clients}, Care Plans: ${this.postCount.carePlans}, Weekly Docs: ${this.postCount.weeklyDocs}, Monthly Reports: ${this.postCount.monthlyReports}, Visma Weeks: ${this.postCount.vismaWeeks}`);\n\n        // Validate migration counts\n        const isValid = this.validateCounts(\n          staffIdMapping.size,\n          clientIdMapping.size,\n          migratedCarePlans,\n          migratedWeeklyDocs,\n          migratedMonthlyReports,\n          migratedVismaWeeks\n        );\n\n        if (!isValid) {\n          this.log('🚫 Rolling back transaction due to count validation failure...');\n          this.db.exec('ROLLBACK');\n          this.log('❌ Migration failed - data integrity check failed');\n          return false;\n        }\n\n        // Commit transaction\n        this.log('✅ Committing transaction...');\n        this.db.exec('COMMIT');\n      }\n\n      // Generate migration report\n      await this.generateMigrationReport();\n\n      if (this.isDryRun) {\n        this.log('🧪 DRY RUN completed successfully! No changes were made to the database.');\n        this.log('💡 Run without --dry-run flag to perform actual migration.');\n      } else {\n        this.log('🎉 V1 → V2 migration completed successfully!');\n        this.log('🔐 All migrated users need to reset their passwords');\n      }\n      this.log('📋 Review the migration report for any issues');\n\n      return true;\n    } catch (error) {\n      this.log(`❌ Migration failed: ${error}`);\n      \n      if (!this.isDryRun && transaction) {\n        try {\n          this.log('🚫 Rolling back transaction...');\n          this.db.exec('ROLLBACK');\n          this.log('✅ Transaction rolled back successfully');\n        } catch (rollbackError) {\n          this.log(`❌ Failed to rollback transaction: ${rollbackError}`);\n        }\n      }\n      \n      return false;\n    } finally {\n      this.db.close();\n    }\n  }\n}\n\n// CLI interface\nasync function main(): Promise<void> {\n  const args = process.argv.slice(2);\n  let dataPath: string | undefined;\n  let isDryRun = false;\n\n  // Parse arguments\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (arg === '--dry-run') {\n      isDryRun = true;\n    } else if (!dataPath && arg && !arg.startsWith('--')) {\n      dataPath = arg;\n    }\n  }\n\n  console.log('🔄 V1 → V2 Data Migration Tool');\n  console.log('==============================');\n  \n  if (isDryRun) {\n    console.log('🧪 DRY RUN MODE - No changes will be made');\n  }\n  \n  if (dataPath) {\n    console.log(`📁 Using custom data path: ${dataPath}`);\n  } else {\n    console.log(`📁 Using default data path: ${V1_DATA_FILE}`);\n    console.log('💡 You can specify a custom path: npm run migrate:v1-to-v2 [path/to/your/v1-data.json] [--dry-run]');\n  }\n\n  console.log('\\n🔐 SÄKERHETSFUNKTIONER:');\n  console.log('  ✅ SQLite transactions (BEGIN/COMMIT/ROLLBACK)');\n  console.log('  ✅ Record count validering före/efter migration');\n  console.log('  ✅ Automatisk backup med timestamp');\n  console.log('  ✅ --dry-run för säker testning');\n  console.log('');\n\n  const migrator = new V1ToV2Migrator(isDryRun);\n  const success = await migrator.migrate(dataPath);\n  \n  process.exit(success ? 0 : 1);\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main().catch(console.error);\n}\n\nexport { V1ToV2Migrator };\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/database/connection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":162,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":162,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'next' is defined but never used.","line":210,"column":69,"nodeType":null,"messageId":"unusedVar","endLine":210,"endColumn":73}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Ungdomsstöd V2 API Server\n * Express server with TypeScript, authentication, and full CRUD operations\n */\n\nimport express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport jwt from 'jsonwebtoken';\n// import bcrypt from 'bcryptjs'; // Not used in main server file\nimport { initDatabase, closeDatabase } from './database/connection.js';\nimport { idempotencyMiddleware } from './utils/idempotency.js';\nimport { cleanupExpiredIdempotencyKeys } from './utils/idempotency.js';\nimport { nowInStockholm, getCurrentWeekId, getCurrentMonthId } from './utils/timezone.js';\nimport authRoutes from './routes/auth.js';\nimport userRoutes from './routes/users.js';\nimport clientRoutes from './routes/clients.js';\nimport carePlanRoutes from './routes/care-plans.js';\nimport weeklyDocRoutes from './routes/weekly-docs.js';\nimport monthlyReportRoutes from './routes/monthly-reports.js';\nimport vismaTimeRoutes from './routes/visma-time.js';\nimport dashboardRoutes from './routes/dashboard.js';\nimport { initializeAuditRoutes } from './routes/audit-logs.js';\nimport { initializeFeatureFlagRoutes } from './routes/feature-flags.js';\nimport AuditLogger, { auditMiddleware } from './utils/audit-logger.js';\nimport type { JwtPayload } from './types/database.js';\n\nconst app = express();\nconst PORT = process.env.PORT || 3001;\nconst JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-key-change-in-production';\nconst NODE_ENV = process.env.NODE_ENV || 'development';\n\n// Global audit logger instance\nlet auditLogger: AuditLogger;\n\n// Development token for testing\nconst DEV_TOKEN = 'dev-token-for-testing';\n\n// Middleware - Enhanced security headers\nconst productionHelmetConfig = {\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'unsafe-inline'\"], // Allow inline scripts for React\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"], // Allow inline styles\n      imgSrc: [\"'self'\", \"data:\", \"blob:\"],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n      formAction: [\"'self'\"],\n      baseUri: [\"'self'\"],\n      manifestSrc: [\"'self'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' as const },\n  xContentTypeOptions: true,\n  crossOriginEmbedderPolicy: false, // Disable for legacy integrations that rely on cross-origin embeds\n  xFrameOptions: { action: 'deny' as const }\n};\n\nconst developmentHelmetConfig = {\n  contentSecurityPolicy: false, // Disable CSP locally for DX\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' as const },\n  xContentTypeOptions: true,\n  crossOriginEmbedderPolicy: false\n};\n\napp.use(helmet(NODE_ENV === 'production' ? productionHelmetConfig : developmentHelmetConfig));\n\napp.use((_, res, next) => {\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n  next();\n});\n\napp.use(cors({\n  origin: process.env.CLIENT_URL || 'http://localhost:5175',\n  credentials: true\n}));\n\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true }));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: {\n    success: false,\n    error: 'Too many requests',\n    message: 'Please try again later'\n  }\n});\n\napp.use('/api/', limiter);\n\n// Idempotency middleware\napp.use('/api/', idempotencyMiddleware());\n\n// Audit logging middleware (will be initialized after database connection)\n\n// Request logging in development\nif (NODE_ENV === 'development') {\n  app.use((req, res, next) => {\n    console.log(`${new Date().toISOString()} ${req.method} ${req.path}`);\n    next();\n  });\n}\n\n// Health check endpoint\napp.get('/api/health', (req, res) => {\n  res.json({\n    success: true,\n    data: {\n      status: 'healthy',\n      timestamp: nowInStockholm().toISOString(),\n      timezone: 'Europe/Stockholm',\n      weekId: getCurrentWeekId(),\n      monthId: getCurrentMonthId(),\n      environment: NODE_ENV\n    }\n  });\n});\n\n// Authentication middleware\nfunction authenticateToken(req: express.Request, res: express.Response, next: express.NextFunction) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1];\n  const devToken = req.headers['x-dev-token'] as string;\n\n  // Allow dev token in development\n  if (NODE_ENV === 'development' && devToken === DEV_TOKEN) {\n    req.user = {\n      userId: 'dev-user',\n      email: 'dev@example.com',\n      role: 'admin',\n      iat: Date.now() / 1000,\n      exp: (Date.now() / 1000) + 3600\n    } as JwtPayload;\n    return next();\n  }\n\n  if (!token) {\n    return res.status(401).json({\n      success: false,\n      error: 'Access token required',\n      message: 'Please provide a valid authentication token'\n    });\n  }\n\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(403).json({\n      success: false,\n      error: 'Invalid token',\n      message: 'The provided token is invalid or expired'\n    });\n  }\n}\n\n// Admin middleware\nfunction requireAdmin(req: express.Request, res: express.Response, next: express.NextFunction) {\n  if (req.user?.role !== 'admin') {\n    return res.status(403).json({\n      success: false,\n      error: 'Admin access required',\n      message: 'This operation requires administrator privileges'\n    });\n  }\n  next();\n}\n\n// API routes\napp.use('/api/auth', authRoutes);\napp.use('/api/users', authenticateToken, userRoutes);\napp.use('/api/clients', authenticateToken, clientRoutes);\napp.use('/api/care-plans', authenticateToken, carePlanRoutes);\napp.use('/api/weekly-docs', authenticateToken, weeklyDocRoutes);\napp.use('/api/monthly-reports', authenticateToken, monthlyReportRoutes);\napp.use('/api/visma-time', authenticateToken, vismaTimeRoutes);\napp.use('/api/dashboard', authenticateToken, dashboardRoutes);\n\n// Admin routes\napp.use('/api/admin', authenticateToken, requireAdmin, async (req, res) => {\n  const idempotencyModule = await import('./utils/idempotency.js');\n  res.json({\n    success: true,\n    data: {\n      message: 'Admin panel',\n      stats: {\n        idempotency: idempotencyModule.getIdempotencyStats(),\n        timezone: 'Europe/Stockholm',\n        currentTime: nowInStockholm().toISOString()\n      }\n    }\n  });\n});\n\n// Error handling middleware\napp.use((error: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {\n  console.error('Server error:', error);\n  \n  res.status(500).json({\n    success: false,\n    error: 'Internal server error',\n    message: NODE_ENV === 'development' ? error.message : 'An unexpected error occurred'\n  });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({\n    success: false,\n    error: 'Not found',\n    message: `Route ${req.method} ${req.originalUrl} not found`\n  });\n});\n\n// Graceful shutdown\nprocess.on('SIGINT', () => {\n  console.log('\\n🛑 Shutting down server...');\n  closeDatabase();\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('\\n🛑 Shutting down server...');\n  closeDatabase();\n  process.exit(0);\n});\n\n// Start server\nasync function startServer() {\n  try {\n    // Initialize database\n    const db = await initDatabase();\n    \n    // Initialize audit logger\n    auditLogger = new AuditLogger(db);\n    \n    // Add audit middleware to API routes\n    app.use('/api/', auditMiddleware(auditLogger));\n    \n    // Initialize audit routes\n    const auditRoutes = initializeAuditRoutes(db);\n    app.use('/api/audit-logs', authenticateToken, auditRoutes);\n    \n    // Initialize feature flag routes\n    const featureRoutes = initializeFeatureFlagRoutes(db);\n    app.use('/api/feature-flags', authenticateToken, featureRoutes);\n    \n    // Clean up expired idempotency keys on startup\n    cleanupExpiredIdempotencyKeys();\n    \n    // Start server\n    app.listen(PORT, () => {\n      console.log(`🚀 Server running on port ${PORT}`);\n      console.log(`🌍 Environment: ${NODE_ENV}`);\n      console.log(`🕐 Timezone: Europe/Stockholm`);\n      console.log(`📅 Current week: ${getCurrentWeekId()}`);\n      console.log(`📅 Current month: ${getCurrentMonthId()}`);\n      console.log(`🔗 Health check: http://localhost:${PORT}/api/health`);\n      \n      if (NODE_ENV === 'development') {\n        console.log(`🔑 Dev token: ${DEV_TOKEN}`);\n      }\n    });\n    \n  } catch (error) {\n    console.error('❌ Failed to start server:', error);\n    process.exit(1);\n  }\n}\n\n// Schedule cleanup of expired idempotency keys every hour\nsetInterval(cleanupExpiredIdempotencyKeys, 60 * 60 * 1000);\n\n// Schedule GDPR-compliant audit log cleanup daily at 3:00 AM\nconst scheduleAuditCleanup = () => {\n  const now = new Date();\n  const next3AM = new Date(now);\n  next3AM.setHours(3, 0, 0, 0);\n  \n  // If it's already past 3 AM today, schedule for tomorrow\n  if (now > next3AM) {\n    next3AM.setDate(next3AM.getDate() + 1);\n  }\n  \n  const msUntil3AM = next3AM.getTime() - now.getTime();\n  \n  setTimeout(() => {\n    // Run cleanup\n    if (auditLogger) {\n      auditLogger.cleanupOldAuditLogs();\n    }\n    \n    // Schedule daily cleanup\n    setInterval(() => {\n      if (auditLogger) {\n        auditLogger.cleanupOldAuditLogs();\n      }\n    }, 24 * 60 * 60 * 1000); // Daily\n  }, msUntil3AM);\n  \n  console.log(`🕒 GDPR audit cleanup scheduled for ${next3AM.toISOString()}`);\n};\n\nscheduleAuditCleanup();\n\nstartServer();\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/audit-logs.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":25,"column":58,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":25,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[701,704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[701,704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":240,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6121,6124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6121,6124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Audit Logs API Routes\n * Provides access to audit logs for administrators\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport Database from 'better-sqlite3';\nimport AuditLogger, { type AuditAction } from '../utils/audit-logger.js';\nimport type { JwtPayload } from '../types/database.js';\n\nconst router = Router();\n\n// Get audit logger instance\nlet auditLogger: AuditLogger;\n\nexport function initializeAuditRoutes(db: Database.Database) {\n  auditLogger = new AuditLogger(db);\n  return router;\n}\n\nexport { auditLogger };\n\n// Middleware to ensure user is admin\nfunction requireAdmin(req: Request, res: Response, next: Function) {\n  const user = (req as any).user as JwtPayload;\n  if (user?.role !== 'admin') {\n    return res.status(403).json({\n      success: false,\n      error: 'Admin access required',\n      message: 'Only administrators can access audit logs'\n    });\n  }\n  next();\n}\n\n// Get audit logs with filtering\nrouter.get('/', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const {\n      userId,\n      action,\n      resource,\n      startDate,\n      endDate,\n      limit = 100,\n      offset = 0\n    } = req.query;\n\n    const filters = {\n      userId: userId as string,\n      action: action as AuditAction,\n      resource: resource as string,\n      startDate: startDate as string,\n      endDate: endDate as string,\n      limit: parseInt(limit as string),\n      offset: parseInt(offset as string)\n    };\n\n    const logs = auditLogger.getAuditLogs(filters);\n\n    res.json({\n      success: true,\n      data: {\n        logs,\n        filters,\n        count: logs.length\n      }\n    });\n  } catch (error) {\n    console.error('Failed to get audit logs:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve audit logs',\n      message: 'An error occurred while fetching audit logs'\n    });\n  }\n});\n\n// Get security violations\nrouter.get('/security-violations', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const limit = parseInt(req.query.limit as string) || 100;\n    const violations = auditLogger.getSecurityViolations(limit);\n\n    res.json({\n      success: true,\n      data: {\n        violations,\n        count: violations.length\n      }\n    });\n  } catch (error) {\n    console.error('Failed to get security violations:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve security violations',\n      message: 'An error occurred while fetching security violations'\n    });\n  }\n});\n\n// Get failed login attempts\nrouter.get('/failed-logins', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const limit = parseInt(req.query.limit as string) || 100;\n    const failedLogins = auditLogger.getFailedLogins(limit);\n\n    res.json({\n      success: true,\n      data: {\n        failedLogins,\n        count: failedLogins.length\n      }\n    });\n  } catch (error) {\n    console.error('Failed to get failed logins:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve failed logins',\n      message: 'An error occurred while fetching failed login attempts'\n    });\n  }\n});\n\n// Get admin actions\nrouter.get('/admin-actions', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const limit = parseInt(req.query.limit as string) || 100;\n    const adminActions = auditLogger.getAdminActions(limit);\n\n    res.json({\n      success: true,\n      data: {\n        adminActions,\n        count: adminActions.length\n      }\n    });\n  } catch (error) {\n    console.error('Failed to get admin actions:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve admin actions',\n      message: 'An error occurred while fetching admin actions'\n    });\n  }\n});\n\n// Get audit statistics\nrouter.get('/stats', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const stats = auditLogger.getStats();\n\n    res.json({\n      success: true,\n      data: stats\n    });\n  } catch (error) {\n    console.error('Failed to get audit stats:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve audit statistics',\n      message: 'An error occurred while fetching audit statistics'\n    });\n  }\n});\n\n// Export audit logs (CSV format)\nrouter.get('/export', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const {\n      startDate,\n      endDate,\n      action,\n      resource\n    } = req.query;\n\n    const filters = {\n      startDate: startDate as string,\n      endDate: endDate as string,\n      action: action as AuditAction,\n      resource: resource as string,\n      limit: 10000 // Large limit for export\n    };\n\n    const logs = auditLogger.getAuditLogs(filters);\n\n    // Generate CSV\n    const headers = [\n      'Timestamp',\n      'Actor ID (Anonymized)',\n      'Actor Role',\n      'Action',\n      'Resource',\n      'Resource ID',\n      'IP Address',\n      'User Agent',\n      'Success',\n      'Error Message',\n      'Details'\n    ];\n\n    const csvRows = logs.map(log => [\n      log.timestamp,\n      log.actorId,\n      log.actorRole,\n      log.action,\n      log.resource,\n      log.resourceId || '',\n      log.ipAddress,\n      log.userAgent,\n      log.success,\n      log.errorMessage || '',\n      JSON.stringify(log.details)\n    ]);\n\n    const csvContent = [headers, ...csvRows]\n      .map(row => row.map(field => `\"${field}\"`).join(','))\n      .join('\\n');\n\n    const filename = `audit-logs-${new Date().toISOString().split('T')[0]}.csv`;\n\n    res.setHeader('Content-Type', 'text/csv');\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n    res.send(csvContent);\n  } catch (error) {\n    console.error('Failed to export audit logs:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to export audit logs',\n      message: 'An error occurred while exporting audit logs'\n    });\n  }\n});\n\n// GDPR Data Portability: Export user's own audit logs (anonymized)\nrouter.get('/gdpr-export/:userRole', async (req: Request, res: Response) => {\n  try {\n    const { userRole } = req.params;\n    const user = (req as any).user as JwtPayload;\n    \n    // Users can only export their own role's data, admins can export any role\n    if (user.role !== 'admin' && user.role !== userRole) {\n      return res.status(403).json({\n        success: false,\n        error: 'Unauthorized',\n        message: 'You can only export your own audit data'\n      });\n    }\n\n    // Use the standalone GDPR export function\n    const { exportUserAuditLogs } = await import('../utils/audit-logger.js');\n    const logs = await exportUserAuditLogs(userRole || 'unknown');\n\n    const filename = `gdpr-audit-export-${userRole}-${new Date().toISOString().split('T')[0]}.json`;\n\n    res.setHeader('Content-Type', 'application/json');\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n    res.json({\n      success: true,\n      message: 'GDPR audit data export',\n      userRole,\n      totalLogs: logs.length,\n      exportDate: new Date().toISOString(),\n      gdprCompliant: true,\n      anonymized: true,\n      data: logs\n    });\n\n    // Log the export action\n    if (auditLogger) {\n      await auditLogger.logEvent(\n        req,\n        res,\n        'DATA_EXPORT',\n        'audit_logs',\n        { exportType: 'gdpr', userRole, recordCount: logs.length },\n        undefined,\n        true\n      );\n    }\n  } catch (error) {\n    console.error('Failed to export GDPR audit logs:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to export GDPR audit logs',\n      message: 'An error occurred while exporting your audit data'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'generateIdempotencyKey' is defined but never used.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Authentication Routes\n * Handles login, logout, and token management\n */\n\nimport { Router } from 'express';\nimport jwt, { type Secret, type SignOptions } from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { v4 as uuidv4 } from 'uuid';\nimport { safeQueryOne, safeExecute } from '../database/connection.js';\nimport { generateIdempotencyKey } from '../utils/idempotency.js';\nimport { nowInStockholm } from '../utils/timezone.js';\nimport type { LoginRequest, AuthResponse, CreateUserRequest, User, JwtPayload } from '../types/database.js';\n\nconst router = Router();\nconst JWT_SECRET: Secret = process.env.JWT_SECRET ?? 'dev-secret-key-change-in-production';\nconst JWT_EXPIRES_IN: SignOptions['expiresIn'] = (process.env.JWT_EXPIRES_IN ?? '24h') as SignOptions['expiresIn'];\nconst JWT_SIGN_OPTIONS: SignOptions = { expiresIn: JWT_EXPIRES_IN };\n\n/**\n * POST /api/auth/login\n * Authenticate user and return JWT token\n */\nrouter.post('/login', async (req, res) => {\n  try {\n    const { email, password }: LoginRequest = req.body;\n\n    // Validate input\n    if (!email || !password) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing credentials',\n        message: 'Email and password are required'\n      });\n    }\n\n    // Find user by email\n    const user = safeQueryOne<User>(\n      'SELECT * FROM users WHERE email = ? AND is_active = 1',\n      [email.toLowerCase()]\n    );\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        error: 'Invalid credentials',\n        message: 'Email or password is incorrect'\n      });\n    }\n\n    // Verify password\n    const isValidPassword = await bcrypt.compare(password, user.password_hash);\n    if (!isValidPassword) {\n      return res.status(401).json({\n        success: false,\n        error: 'Invalid credentials',\n        message: 'Email or password is incorrect'\n      });\n    }\n\n    // Generate JWT token\n    const payload: Omit<JwtPayload, 'iat' | 'exp'> = {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    };\n\n    const token = jwt.sign(payload, JWT_SECRET, JWT_SIGN_OPTIONS);\n\n    // Update last login\n    safeExecute(\n      'UPDATE users SET updated_at = ? WHERE id = ?',\n      [nowInStockholm().toISOString(), user.id]\n    );\n\n    const response: AuthResponse = {\n      token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role,\n        is_active: user.is_active,\n        created_at: user.created_at,\n        updated_at: user.updated_at\n      }\n    };\n\n    res.json({\n      success: true,\n      data: response\n    });\n\n  } catch (error) {\n    console.error('Login error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Login failed',\n      message: 'An error occurred during login'\n    });\n  }\n});\n\n/**\n * POST /api/auth/register\n * Register new user (admin only)\n */\nrouter.post('/register', async (req, res) => {\n  try {\n    const { email, name, password, role = 'staff' }: CreateUserRequest = req.body;\n\n    // Validate input\n    if (!email || !name || !password) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Email, name, and password are required'\n      });\n    }\n\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid email format',\n        message: 'Please provide a valid email address'\n      });\n    }\n\n    // Validate password strength\n    if (password.length < 8) {\n      return res.status(400).json({\n        success: false,\n        error: 'Weak password',\n        message: 'Password must be at least 8 characters long'\n      });\n    }\n\n    // Check if user already exists\n    const existingUser = safeQueryOne<User>(\n      'SELECT id FROM users WHERE email = ?',\n      [email.toLowerCase()]\n    );\n\n    if (existingUser) {\n      return res.status(409).json({\n        success: false,\n        error: 'User already exists',\n        message: 'A user with this email already exists'\n      });\n    }\n\n    // Hash password\n    const saltRounds = 12;\n    const passwordHash = await bcrypt.hash(password, saltRounds);\n\n    // Create user\n    const userId = uuidv4();\n    const now = nowInStockholm().toISOString();\n\n    safeExecute(\n      `INSERT INTO users (id, email, name, password_hash, role, created_at, updated_at)\n       VALUES (?, ?, ?, ?, ?, ?, ?)`,\n      [userId, email.toLowerCase(), name, passwordHash, role, now, now]\n    );\n\n    // Return user without password\n    const newUser = safeQueryOne<User>(\n      'SELECT * FROM users WHERE id = ?',\n      [userId]\n    );\n\n    if (!newUser) {\n      throw new Error('Failed to retrieve created user');\n    }\n\n    res.status(201).json({\n      success: true,\n      data: {\n        id: newUser.id,\n        email: newUser.email,\n        name: newUser.name,\n        role: newUser.role,\n        is_active: newUser.is_active,\n        created_at: newUser.created_at,\n        updated_at: newUser.updated_at\n      }\n    });\n\n  } catch (error) {\n    console.error('Registration error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Registration failed',\n      message: 'An error occurred during registration'\n    });\n  }\n});\n\n/**\n * POST /api/auth/verify\n * Verify JWT token\n */\nrouter.post('/verify', async (req, res) => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({\n        success: false,\n        error: 'No token provided',\n        message: 'Authorization token is required'\n      });\n    }\n\n    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;\n\n    // Get user from database\n    const user = safeQueryOne<User>(\n      'SELECT * FROM users WHERE id = ? AND is_active = 1',\n      [decoded.userId]\n    );\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        error: 'Invalid token',\n        message: 'User not found or inactive'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role,\n        is_active: user.is_active,\n        created_at: user.created_at,\n        updated_at: user.updated_at\n      }\n    });\n\n  } catch (error) {\n    console.error('Token verification error:', error);\n    res.status(401).json({\n      success: false,\n      error: 'Invalid token',\n      message: 'Token verification failed'\n    });\n  }\n});\n\n/**\n * POST /api/auth/refresh\n * Refresh JWT token\n */\nrouter.post('/refresh', async (req, res) => {\n  try {\n    const authHeader = req.headers['authorization'];\n    const token = authHeader && authHeader.split(' ')[1];\n\n    if (!token) {\n      return res.status(401).json({\n        success: false,\n        error: 'No token provided',\n        message: 'Authorization token is required'\n      });\n    }\n\n    // Verify token (even if expired)\n    const decoded = jwt.verify(token, JWT_SECRET, { ignoreExpiration: true }) as JwtPayload;\n\n    // Get user from database\n    const user = safeQueryOne<User>(\n      'SELECT * FROM users WHERE id = ? AND is_active = 1',\n      [decoded.userId]\n    );\n\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        error: 'Invalid token',\n        message: 'User not found or inactive'\n      });\n    }\n\n    // Generate new token\n    const payload: Omit<JwtPayload, 'iat' | 'exp'> = {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    };\n\n    const newToken = jwt.sign(payload, JWT_SECRET, JWT_SIGN_OPTIONS);\n\n    res.json({\n      success: true,\n      data: {\n        token: newToken\n      }\n    });\n\n  } catch (error) {\n    console.error('Token refresh error:', error);\n    res.status(401).json({\n      success: false,\n      error: 'Invalid token',\n      message: 'Token refresh failed'\n    });\n  }\n});\n\n/**\n * POST /api/auth/logout\n * Logout user (client-side token removal)\n */\nrouter.post('/logout', async (req, res) => {\n  // In a stateless JWT system, logout is handled client-side\n  // This endpoint exists for consistency and potential future enhancements\n  res.json({\n    success: true,\n    data: {\n      message: 'Logged out successfully'\n    }\n  });\n});\n\nexport default router;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/care-plans.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CarePlan' is defined but never used.","line":9,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Care Plans API Routes\n * Handle CRUD operations for care plans\n */\n\nimport express from 'express';\nimport { getDb } from '../database/connection.js';\nimport { nowInStockholm } from '../utils/timezone.js';\nimport type { CarePlan, CreateCarePlanRequest, UpdateCarePlanRequest } from '../types/database.js';\n\nconst router = express.Router();\n\n// Get all care plans for a client\nrouter.get('/client/:clientId', async (req, res) => {\n  try {\n    const { clientId } = req.params;\n    const db = getDb();\n    \n    const carePlans = db.prepare(`\n      SELECT * FROM care_plans \n      WHERE client_id = ? \n      ORDER BY created_at DESC\n    `).all(clientId);\n\n    res.json({\n      success: true,\n      data: carePlans\n    });\n  } catch (error) {\n    console.error('Error fetching care plans:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to fetch care plans'\n    });\n  }\n});\n\n// Get care plans for a staff member\nrouter.get('/staff/:staffId', async (req, res) => {\n  try {\n    const { staffId } = req.params;\n    const db = getDb();\n    \n    const carePlans = db.prepare(`\n      SELECT cp.*, c.name as client_name, c.initials as client_initials\n      FROM care_plans cp\n      JOIN clients c ON cp.client_id = c.id\n      WHERE c.assigned_staff_id = ?\n      ORDER BY cp.created_at DESC\n    `).all(staffId);\n\n    res.json({\n      success: true,\n      data: carePlans\n    });\n  } catch (error) {\n    console.error('Error fetching staff care plans:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to fetch care plans'\n    });\n  }\n});\n\n// Get a specific care plan\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const db = getDb();\n    \n    const carePlan = db.prepare(`\n      SELECT cp.*, c.name as client_name, c.initials as client_initials\n      FROM care_plans cp\n      JOIN clients c ON cp.client_id = c.id\n      WHERE cp.id = ?\n    `).get(id);\n\n    if (!carePlan) {\n      return res.status(404).json({\n        success: false,\n        error: 'Care plan not found',\n        message: 'The requested care plan does not exist'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: carePlan\n    });\n  } catch (error) {\n    console.error('Error fetching care plan:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to fetch care plan'\n    });\n  }\n});\n\n// Create a new care plan\nrouter.post('/', async (req, res) => {\n  try {\n    const { client_id, plan_date, goals, interventions, notes } = req.body as CreateCarePlanRequest;\n    \n    if (!client_id || !plan_date) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Client ID and plan date are required'\n      });\n    }\n\n    const db = getDb();\n    const now = nowInStockholm().toISOString();\n    \n    const result = db.prepare(`\n      INSERT INTO care_plans (client_id, plan_date, goals, interventions, notes, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?)\n    `).run(client_id, plan_date, goals || '', interventions || '', notes || '', now, now);\n\n    const carePlan = db.prepare(`\n      SELECT cp.*, c.name as client_name, c.initials as client_initials\n      FROM care_plans cp\n      JOIN clients c ON cp.client_id = c.id\n      WHERE cp.id = ?\n    `).get(result.lastInsertRowid);\n\n    res.status(201).json({\n      success: true,\n      data: carePlan,\n      message: 'Care plan created successfully'\n    });\n  } catch (error) {\n    console.error('Error creating care plan:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to create care plan'\n    });\n  }\n});\n\n// Update a care plan\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body as UpdateCarePlanRequest;\n    \n    const db = getDb();\n    const now = nowInStockholm().toISOString();\n    \n    // Check if care plan exists\n    const existing = db.prepare('SELECT id FROM care_plans WHERE id = ?').get(id);\n    if (!existing) {\n      return res.status(404).json({\n        success: false,\n        error: 'Care plan not found',\n        message: 'The requested care plan does not exist'\n      });\n    }\n\n    // Build update query dynamically\n    const updateFields = [];\n    const updateValues = [];\n    \n    if (updates.plan_date !== undefined) {\n      updateFields.push('plan_date = ?');\n      updateValues.push(updates.plan_date);\n    }\n    if (updates.goals !== undefined) {\n      updateFields.push('goals = ?');\n      updateValues.push(updates.goals);\n    }\n    if (updates.interventions !== undefined) {\n      updateFields.push('interventions = ?');\n      updateValues.push(updates.interventions);\n    }\n    if (updates.notes !== undefined) {\n      updateFields.push('notes = ?');\n      updateValues.push(updates.notes);\n    }\n    if (updates.status !== undefined) {\n      updateFields.push('status = ?');\n      updateValues.push(updates.status);\n    }\n    \n    updateFields.push('updated_at = ?');\n    updateValues.push(now);\n    updateValues.push(id);\n    \n    db.prepare(`\n      UPDATE care_plans \n      SET ${updateFields.join(', ')} \n      WHERE id = ?\n    `).run(...updateValues);\n\n    const carePlan = db.prepare(`\n      SELECT cp.*, c.name as client_name, c.initials as client_initials\n      FROM care_plans cp\n      JOIN clients c ON cp.client_id = c.id\n      WHERE cp.id = ?\n    `).get(id);\n\n    res.json({\n      success: true,\n      data: carePlan,\n      message: 'Care plan updated successfully'\n    });\n  } catch (error) {\n    console.error('Error updating care plan:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to update care plan'\n    });\n  }\n});\n\n// Delete a care plan\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const db = getDb();\n    \n    const result = db.prepare('DELETE FROM care_plans WHERE id = ?').run(id);\n    \n    if (result.changes === 0) {\n      return res.status(404).json({\n        success: false,\n        error: 'Care plan not found',\n        message: 'The requested care plan does not exist'\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Care plan deleted successfully'\n    });\n  } catch (error) {\n    console.error('Error deleting care plan:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to delete care plan'\n    });\n  }\n});\n\nexport default router;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/clients.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiResponse' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Client Routes\n * Handles client CRUD operations\n */\n\nimport { Router } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\nimport { safeQuery, safeQueryOne, safeExecute } from '../database/connection.js';\nimport { nowInStockholm } from '../utils/timezone.js';\nimport type { \n  Client, \n  ClientWithRelations, \n  CreateClientRequest, \n  ApiResponse, \n  PaginatedResponse,\n  JwtPayload,\n  CarePlan,\n  WeeklyDoc,\n  MonthlyReport,\n  VismaTime \n} from '../types/database.js';\n\nconst router = Router();\n\n/**\n * GET /api/clients\n * Get all clients for the authenticated user\n */\nrouter.get('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { page = 1, limit = 50, search } = req.query;\n    \n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT c.*, u.name as staff_name\n      FROM clients c\n      JOIN users u ON c.staff_id = u.id\n      WHERE c.staff_id = ?\n    `;\n    const params: (string | number)[] = [user.userId];\n    \n    if (search) {\n      query += ` AND (c.name LIKE ? OR c.initials LIKE ?)`;\n      params.push(`%${search}%`, `%${search}%`);\n    }\n    \n    query += ` ORDER BY c.name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const clients = safeQuery<Client & { staff_name: string }>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM clients c\n      WHERE c.staff_id = ?\n    `;\n    const countParams: (string | number)[] = [user.userId];\n    \n    if (search) {\n      countQuery += ` AND (c.name LIKE ? OR c.initials LIKE ?)`;\n      countParams.push(`%${search}%`, `%${search}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    const response: PaginatedResponse<Client & { staff_name: string }> = {\n      data: clients,\n      total,\n      page: Number(page),\n      limit: Number(limit),\n      totalPages: Math.ceil(total / Number(limit))\n    };\n    \n    res.json({\n      success: true,\n      data: response\n    });\n    \n  } catch (error) {\n    console.error('Get clients error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch clients',\n      message: 'An error occurred while fetching clients'\n    });\n  }\n});\n\n/**\n * GET /api/clients/all\n * Get all clients (admin only)\n */\nrouter.get('/all', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    \n    if (user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        error: 'Admin access required',\n        message: 'Only administrators can view all clients'\n      });\n    }\n    \n    const { page = 1, limit = 50, search, staff_id } = req.query;\n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT c.*, u.name as staff_name\n      FROM clients c\n      JOIN users u ON c.staff_id = u.id\n      WHERE 1=1\n    `;\n    const params: (string | number)[] = [];\n    \n    if (staff_id) {\n      query += ` AND c.staff_id = ?`;\n      params.push(String(staff_id));\n    }\n    \n    if (search) {\n      query += ` AND (c.name LIKE ? OR c.initials LIKE ? OR u.name LIKE ?)`;\n      params.push(`%${String(search)}%`, `%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    query += ` ORDER BY c.name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const clients = safeQuery<Client & { staff_name: string }>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM clients c\n      JOIN users u ON c.staff_id = u.id\n      WHERE 1=1\n    `;\n    const countParams: (string | number)[] = [];\n    \n    if (staff_id) {\n      countQuery += ` AND c.staff_id = ?`;\n      countParams.push(String(staff_id));\n    }\n    \n    if (search) {\n      countQuery += ` AND (c.name LIKE ? OR c.initials LIKE ? OR u.name LIKE ?)`;\n      countParams.push(`%${String(search)}%`, `%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    const response: PaginatedResponse<Client & { staff_name: string }> = {\n      data: clients,\n      total,\n      page: Number(page),\n      limit: Number(limit),\n      totalPages: Math.ceil(total / Number(limit))\n    };\n    \n    res.json({\n      success: true,\n      data: response\n    });\n    \n  } catch (error) {\n    console.error('Get all clients error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch clients',\n      message: 'An error occurred while fetching clients'\n    });\n  }\n});\n\n/**\n * GET /api/clients/:id\n * Get client by ID with all related data\n */\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    // Get client\n    const client = safeQueryOne<Client>(\n      'SELECT * FROM clients WHERE id = ?',\n      [id]\n    );\n    \n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        error: 'Client not found',\n        message: 'The requested client does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && client.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to view this client'\n      });\n    }\n    \n    // Get care plan\n    const carePlan = safeQueryOne<CarePlan>(\n      'SELECT * FROM care_plans WHERE client_id = ?',\n      [id]\n    );\n    \n    // Get weekly docs\n    const weeklyDocs = safeQuery<WeeklyDoc>(\n      'SELECT * FROM weekly_docs WHERE client_id = ? ORDER BY week_id DESC',\n      [id]\n    );\n    \n    // Get monthly reports\n    const monthlyReports = safeQuery<MonthlyReport>(\n      'SELECT * FROM monthly_reports WHERE client_id = ? ORDER BY month_id DESC',\n      [id]\n    );\n    \n    // Get visma time\n    const vismaTime = safeQuery<VismaTime>(\n      'SELECT * FROM visma_time WHERE client_id = ? ORDER BY week_id DESC',\n      [id]\n    );\n    \n    const clientWithRelations: ClientWithRelations = {\n      ...client,\n      care_plan: carePlan || undefined,\n      weekly_docs: weeklyDocs,\n      monthly_reports: monthlyReports,\n      visma_time: vismaTime\n    };\n    \n    res.json({\n      success: true,\n      data: clientWithRelations\n    });\n    \n  } catch (error) {\n    console.error('Get client error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch client',\n      message: 'An error occurred while fetching the client'\n    });\n  }\n});\n\n/**\n * POST /api/clients\n * Create new client\n */\nrouter.post('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { initials, name, staff_id }: CreateClientRequest = req.body;\n    \n    // Validate input\n    if (!initials || !name) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Initials and name are required'\n      });\n    }\n    \n    // Determine staff_id\n    const targetStaffId = staff_id || user.userId;\n    \n    // Check permissions\n    if (user.role !== 'admin' && targetStaffId !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Permission denied',\n        message: 'You can only create clients for yourself'\n      });\n    }\n    \n    // Check if staff exists\n    const staff = safeQueryOne(\n      'SELECT id FROM users WHERE id = ? AND is_active = 1',\n      [targetStaffId]\n    );\n    \n    if (!staff) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid staff member',\n        message: 'The specified staff member does not exist'\n      });\n    }\n    \n    // Check if initials already exist for this staff member\n    const existingClient = safeQueryOne(\n      'SELECT id FROM clients WHERE initials = ? AND staff_id = ?',\n      [initials, targetStaffId]\n    );\n    \n    if (existingClient) {\n      return res.status(409).json({\n        success: false,\n        error: 'Duplicate initials',\n        message: 'A client with these initials already exists for this staff member'\n      });\n    }\n    \n    // Create client\n    const clientId = uuidv4();\n    const now = nowInStockholm().toISOString();\n    \n    safeExecute(\n      `INSERT INTO clients (id, initials, name, staff_id, created_at, updated_at)\n       VALUES (?, ?, ?, ?, ?, ?)`,\n      [clientId, initials, name, targetStaffId, now, now]\n    );\n    \n    // Create empty care plan\n    const carePlanId = uuidv4();\n    safeExecute(\n      `INSERT INTO care_plans (id, client_id, created_at, updated_at)\n       VALUES (?, ?, ?, ?)`,\n      [carePlanId, clientId, now, now]\n    );\n    \n    // Get created client\n    const newClient = safeQueryOne<Client>(\n      'SELECT * FROM clients WHERE id = ?',\n      [clientId]\n    );\n    \n    if (!newClient) {\n      throw new Error('Failed to retrieve created client');\n    }\n    \n    res.status(201).json({\n      success: true,\n      data: newClient\n    });\n    \n  } catch (error) {\n    console.error('Create client error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create client',\n      message: 'An error occurred while creating the client'\n    });\n  }\n});\n\n/**\n * PUT /api/clients/:id\n * Update client\n */\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    const { initials, name, staff_id } = req.body;\n    \n    // Get existing client\n    const existingClient = safeQueryOne<Client>(\n      'SELECT * FROM clients WHERE id = ?',\n      [id]\n    );\n    \n    if (!existingClient) {\n      return res.status(404).json({\n        success: false,\n        error: 'Client not found',\n        message: 'The requested client does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && existingClient.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to update this client'\n      });\n    }\n    \n    // Validate input\n    if (!initials || !name) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Initials and name are required'\n      });\n    }\n    \n    // Determine new staff_id\n    const newStaffId = staff_id || existingClient.staff_id;\n    \n    // Check permissions for staff change\n    if (staff_id && user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        error: 'Permission denied',\n        message: 'Only administrators can reassign clients'\n      });\n    }\n    \n    // Check if new staff exists\n    if (newStaffId !== existingClient.staff_id) {\n      const staff = safeQueryOne(\n        'SELECT id FROM users WHERE id = ? AND is_active = 1',\n        [newStaffId]\n      );\n      \n      if (!staff) {\n        return res.status(400).json({\n          success: false,\n          error: 'Invalid staff member',\n          message: 'The specified staff member does not exist'\n        });\n      }\n    }\n    \n    // Check if initials already exist for the target staff member\n    if (initials !== existingClient.initials || newStaffId !== existingClient.staff_id) {\n      const duplicateClient = safeQueryOne(\n        'SELECT id FROM clients WHERE initials = ? AND staff_id = ? AND id != ?',\n        [initials, newStaffId, id]\n      );\n      \n      if (duplicateClient) {\n        return res.status(409).json({\n          success: false,\n          error: 'Duplicate initials',\n          message: 'A client with these initials already exists for this staff member'\n        });\n      }\n    }\n    \n    // Update client\n    const now = nowInStockholm().toISOString();\n    \n    safeExecute(\n      `UPDATE clients \n       SET initials = ?, name = ?, staff_id = ?, updated_at = ?\n       WHERE id = ?`,\n      [initials, name, newStaffId, now, id]\n    );\n    \n    // Get updated client\n    const updatedClient = safeQueryOne<Client>(\n      'SELECT * FROM clients WHERE id = ?',\n      [id]\n    );\n    \n    if (!updatedClient) {\n      throw new Error('Failed to retrieve updated client');\n    }\n    \n    res.json({\n      success: true,\n      data: updatedClient\n    });\n    \n  } catch (error) {\n    console.error('Update client error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to update client',\n      message: 'An error occurred while updating the client'\n    });\n  }\n});\n\n/**\n * DELETE /api/clients/:id\n * Delete client\n */\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    // Get existing client\n    const existingClient = safeQueryOne<Client>(\n      'SELECT * FROM clients WHERE id = ?',\n      [id]\n    );\n    \n    if (!existingClient) {\n      return res.status(404).json({\n        success: false,\n        error: 'Client not found',\n        message: 'The requested client does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && existingClient.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to delete this client'\n      });\n    }\n    \n    // Delete client (cascading will handle related records)\n    safeExecute('DELETE FROM clients WHERE id = ?', [id]);\n    \n    res.json({\n      success: true,\n      data: {\n        message: 'Client deleted successfully'\n      }\n    });\n    \n  } catch (error) {\n    console.error('Delete client error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to delete client',\n      message: 'An error occurred while deleting the client'\n    });\n  }\n});\n\nexport default router;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/dashboard.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiResponse' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dashboard Routes\n * Handles dashboard KPIs and analytics\n */\n\nimport { Router } from 'express';\nimport { safeQuery, safeQueryOne } from '../database/connection.js';\nimport { nowInStockholm, getCurrentWeekId, getCurrentMonthId } from '../utils/timezone.js';\nimport type { \n  KPIMetrics, \n  WeeklyStats, \n  MonthlyStats, \n  ApiResponse, \n  JwtPayload \n} from '../types/database.js';\n\nconst router = Router();\n\n/**\n * GET /api/dashboard/kpis\n * Get KPI metrics for dashboard\n */\nrouter.get('/kpis', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const currentWeek = getCurrentWeekId();\n    const currentMonth = getCurrentMonthId();\n    const today = nowInStockholm().toISOString().split('T')[0] as string;\n    \n    let kpis: KPIMetrics;\n    \n    if (user.role === 'admin') {\n      // Admin sees all data\n      const totalClients = safeQueryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM clients'\n      );\n      \n      const totalStaff = safeQueryOne<{ count: number }>(\n        \"SELECT COUNT(*) as count FROM users WHERE role = 'staff' AND is_active = 1\"\n      );\n      \n      const activeCarePlans = safeQueryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM care_plans WHERE has_gfp = 1'\n      );\n      \n      const waitingCarePlans = safeQueryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM care_plans WHERE has_gfp = 0'\n      );\n      \n      const delayedCarePlans = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM care_plans cp\n         WHERE cp.has_gfp = 0 \n         AND cp.care_plan_date IS NOT NULL \n         AND date(cp.care_plan_date, '+21 days') < ?`,\n        [today]\n      );\n      \n      const completedThisWeek = safeQueryOne<{ count: number }>(\n        \"SELECT COUNT(*) as count FROM weekly_docs WHERE week_id = ? AND status = 'approved'\",\n        [currentWeek]\n      );\n      \n      const delayedWeeklyDocs = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM weekly_docs wd\n         WHERE wd.week_id < ? AND wd.status != 'approved'`,\n        [currentWeek]\n      );\n      \n      const delayedMonthlyReports = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM monthly_reports mr\n         WHERE mr.month_id < ? AND (mr.sent = 0 OR mr.status != 'approved')`,\n        [currentMonth]\n      );\n      \n      const delayedVismaTime = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM visma_time vt\n         WHERE vt.week_id < ? AND vt.status != 'approved'`,\n        [currentWeek]\n      );\n      \n      kpis = {\n        totalClients: totalClients?.count || 0,\n        totalStaff: totalStaff?.count || 0,\n        activeCarePlans: activeCarePlans?.count || 0,\n        waitingCarePlans: waitingCarePlans?.count || 0,\n        delayedCarePlans: delayedCarePlans?.count || 0,\n        completedThisWeek: completedThisWeek?.count || 0,\n        delayedWeeklyDocs: delayedWeeklyDocs?.count || 0,\n        delayedMonthlyReports: delayedMonthlyReports?.count || 0,\n        delayedVismaTime: delayedVismaTime?.count || 0\n      };\n    } else {\n      // Staff sees only their own data\n      const totalClients = safeQueryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM clients WHERE staff_id = ?',\n        [user.userId]\n      );\n      \n      const activeCarePlans = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM care_plans cp\n         JOIN clients c ON cp.client_id = c.id\n         WHERE c.staff_id = ? AND cp.has_gfp = 1`,\n        [user.userId]\n      );\n      \n      const waitingCarePlans = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM care_plans cp\n         JOIN clients c ON cp.client_id = c.id\n         WHERE c.staff_id = ? AND cp.has_gfp = 0`,\n        [user.userId]\n      );\n      \n      const delayedCarePlans = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM care_plans cp\n         JOIN clients c ON cp.client_id = c.id\n         WHERE c.staff_id = ? AND cp.has_gfp = 0 \n         AND cp.care_plan_date IS NOT NULL \n         AND date(cp.care_plan_date, '+21 days') < ?`,\n        [user.userId, today]\n      );\n      \n      const completedThisWeek = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM weekly_docs wd\n         JOIN clients c ON wd.client_id = c.id\n         WHERE c.staff_id = ? AND wd.week_id = ? AND wd.status = 'approved'`,\n        [user.userId, currentWeek]\n      );\n      \n      const delayedWeeklyDocs = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM weekly_docs wd\n         JOIN clients c ON wd.client_id = c.id\n         WHERE c.staff_id = ? AND wd.week_id < ? AND wd.status != 'approved'`,\n        [user.userId, currentWeek]\n      );\n      \n      const delayedMonthlyReports = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM monthly_reports mr\n         JOIN clients c ON mr.client_id = c.id\n         WHERE c.staff_id = ? AND mr.month_id < ? AND (mr.sent = 0 OR mr.status != 'approved')`,\n        [user.userId, currentMonth]\n      );\n      \n      const delayedVismaTime = safeQueryOne<{ count: number }>(\n        `SELECT COUNT(*) as count FROM visma_time vt\n         JOIN clients c ON vt.client_id = c.id\n         WHERE c.staff_id = ? AND vt.week_id < ? AND vt.status != 'approved'`,\n        [user.userId, currentWeek]\n      );\n      \n      kpis = {\n        totalClients: totalClients?.count || 0,\n        totalStaff: 0, // Staff don't see total staff count\n        activeCarePlans: activeCarePlans?.count || 0,\n        waitingCarePlans: waitingCarePlans?.count || 0,\n        delayedCarePlans: delayedCarePlans?.count || 0,\n        completedThisWeek: completedThisWeek?.count || 0,\n        delayedWeeklyDocs: delayedWeeklyDocs?.count || 0,\n        delayedMonthlyReports: delayedMonthlyReports?.count || 0,\n        delayedVismaTime: delayedVismaTime?.count || 0\n      };\n    }\n    \n    res.json({\n      success: true,\n      data: kpis\n    });\n    \n  } catch (error) {\n    console.error('Get KPIs error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch KPIs',\n      message: 'An error occurred while fetching dashboard KPIs'\n    });\n  }\n});\n\n/**\n * GET /api/dashboard/weekly-stats\n * Get weekly statistics\n */\nrouter.get('/weekly-stats', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { weeks = 8 } = req.query;\n    const limit = Math.min(Number(weeks), 52); // Max 52 weeks\n    \n    let query: string;\n    let params: (string | number)[];\n    \n    if (user.role === 'admin') {\n      query = `\n        SELECT week_id, \n               COUNT(*) as total_docs,\n               SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as completed_docs\n        FROM weekly_docs \n        WHERE week_id >= (\n          SELECT week_id FROM weekly_docs \n          ORDER BY week_id DESC \n          LIMIT 1 OFFSET ?\n        )\n        GROUP BY week_id \n        ORDER BY week_id DESC\n        LIMIT ?\n      `;\n      params = [limit - 1, limit];\n    } else {\n      query = `\n        SELECT wd.week_id, \n               COUNT(*) as total_docs,\n               SUM(CASE WHEN wd.status = 'approved' THEN 1 ELSE 0 END) as completed_docs\n        FROM weekly_docs wd\n        JOIN clients c ON wd.client_id = c.id\n        WHERE c.staff_id = ?\n        AND wd.week_id >= (\n          SELECT wd2.week_id FROM weekly_docs wd2\n          JOIN clients c2 ON wd2.client_id = c2.id\n          WHERE c2.staff_id = ?\n          ORDER BY wd2.week_id DESC \n          LIMIT 1 OFFSET ?\n        )\n        GROUP BY wd.week_id \n        ORDER BY wd.week_id DESC\n        LIMIT ?\n      `;\n      params = [user.userId, user.userId, limit - 1, limit];\n    }\n    \n    const weeklyStats = safeQuery<WeeklyStats & { week_id: string; total_docs: number; completed_docs: number }>(query, params);\n    \n    const stats: WeeklyStats[] = weeklyStats.map(stat => ({\n      weekId: stat.week_id,\n      completedDocs: stat.completed_docs,\n      totalDocs: stat.total_docs,\n      completionRate: stat.total_docs > 0 ? stat.completed_docs / stat.total_docs : 0\n    }));\n    \n    res.json({\n      success: true,\n      data: stats\n    });\n    \n  } catch (error) {\n    console.error('Get weekly stats error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch weekly statistics',\n      message: 'An error occurred while fetching weekly statistics'\n    });\n  }\n});\n\n/**\n * GET /api/dashboard/monthly-stats\n * Get monthly statistics\n */\nrouter.get('/monthly-stats', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { months = 6 } = req.query;\n    const limit = Math.min(Number(months), 24); // Max 24 months\n    \n    let query: string;\n    let params: (string | number)[];\n    \n    if (user.role === 'admin') {\n      query = `\n        SELECT month_id, \n               COUNT(*) as total_reports,\n               SUM(CASE WHEN sent = 1 THEN 1 ELSE 0 END) as sent_reports\n        FROM monthly_reports \n        WHERE month_id >= (\n          SELECT month_id FROM monthly_reports \n          ORDER BY month_id DESC \n          LIMIT 1 OFFSET ?\n        )\n        GROUP BY month_id \n        ORDER BY month_id DESC\n        LIMIT ?\n      `;\n      params = [limit - 1, limit];\n    } else {\n      query = `\n        SELECT mr.month_id, \n               COUNT(*) as total_reports,\n               SUM(CASE WHEN mr.sent = 1 THEN 1 ELSE 0 END) as sent_reports\n        FROM monthly_reports mr\n        JOIN clients c ON mr.client_id = c.id\n        WHERE c.staff_id = ?\n        AND mr.month_id >= (\n          SELECT mr2.month_id FROM monthly_reports mr2\n          JOIN clients c2 ON mr2.client_id = c2.id\n          WHERE c2.staff_id = ?\n          ORDER BY mr2.month_id DESC \n          LIMIT 1 OFFSET ?\n        )\n        GROUP BY mr.month_id \n        ORDER BY mr.month_id DESC\n        LIMIT ?\n      `;\n      params = [user.userId, user.userId, limit - 1, limit];\n    }\n    \n    const monthlyStats = safeQuery<MonthlyStats & { month_id: string; total_reports: number; sent_reports: number }>(query, params);\n    \n    const stats: MonthlyStats[] = monthlyStats.map(stat => ({\n      monthId: stat.month_id,\n      sentReports: stat.sent_reports,\n      totalReports: stat.total_reports,\n      sentRate: stat.total_reports > 0 ? stat.sent_reports / stat.total_reports : 0\n    }));\n    \n    res.json({\n      success: true,\n      data: stats\n    });\n    \n  } catch (error) {\n    console.error('Get monthly stats error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch monthly statistics',\n      message: 'An error occurred while fetching monthly statistics'\n    });\n  }\n});\n\n/**\n * GET /api/dashboard/recent-activity\n * Get recent activity across all modules\n */\nrouter.get('/recent-activity', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { limit = 20 } = req.query;\n    \n    let query: string;\n    let params: (string | number)[];\n    \n    if (user.role === 'admin') {\n      query = `\n        SELECT 'care_plan' as type, cp.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Care plan updated' as description\n        FROM care_plans cp\n        JOIN clients c ON cp.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        \n        UNION ALL\n        \n        SELECT 'weekly_doc' as type, wd.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Weekly documentation updated' as description\n        FROM weekly_docs wd\n        JOIN clients c ON wd.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        \n        UNION ALL\n        \n        SELECT 'monthly_report' as type, mr.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Monthly report updated' as description\n        FROM monthly_reports mr\n        JOIN clients c ON mr.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        \n        UNION ALL\n        \n        SELECT 'visma_time' as type, vt.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Visma time updated' as description\n        FROM visma_time vt\n        JOIN clients c ON vt.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        \n        ORDER BY updated_at DESC\n        LIMIT ?\n      `;\n      params = [Number(limit)];\n    } else {\n      query = `\n        SELECT 'care_plan' as type, cp.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Care plan updated' as description\n        FROM care_plans cp\n        JOIN clients c ON cp.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ?\n        \n        UNION ALL\n        \n        SELECT 'weekly_doc' as type, wd.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Weekly documentation updated' as description\n        FROM weekly_docs wd\n        JOIN clients c ON wd.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ?\n        \n        UNION ALL\n        \n        SELECT 'monthly_report' as type, mr.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Monthly report updated' as description\n        FROM monthly_reports mr\n        JOIN clients c ON mr.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ?\n        \n        UNION ALL\n        \n        SELECT 'visma_time' as type, vt.updated_at, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               'Visma time updated' as description\n        FROM visma_time vt\n        JOIN clients c ON vt.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ?\n        \n        ORDER BY updated_at DESC\n        LIMIT ?\n      `;\n      params = [user.userId, user.userId, user.userId, user.userId, Number(limit)];\n    }\n    \n    const recentActivity = safeQuery<{\n      type: string;\n      updated_at: string;\n      client_name: string;\n      client_initials: string;\n      staff_name: string;\n      description: string;\n    }>(query, params);\n    \n    res.json({\n      success: true,\n      data: recentActivity\n    });\n    \n  } catch (error) {\n    console.error('Get recent activity error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch recent activity',\n      message: 'An error occurred while fetching recent activity'\n    });\n  }\n});\n\n/**\n * GET /api/dashboard/overdue-items\n * Get overdue items that need attention\n */\nrouter.get('/overdue-items', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const currentWeek = getCurrentWeekId();\n    const currentMonth = getCurrentMonthId();\n    const today = nowInStockholm().toISOString().split('T')[0] as string;\n    \n    let query: string;\n    let params: (string | number)[];\n    \n    if (user.role === 'admin') {\n      query = `\n        SELECT 'care_plan' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               cp.care_plan_date, 'Care plan overdue - GFP needed' as description\n        FROM care_plans cp\n        JOIN clients c ON cp.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE cp.has_gfp = 0 AND cp.care_plan_date IS NOT NULL \n        AND date(cp.care_plan_date, '+21 days') < ?\n        \n        UNION ALL\n        \n        SELECT 'weekly_doc' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               wd.week_id, 'Weekly documentation overdue' as description\n        FROM weekly_docs wd\n        JOIN clients c ON wd.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE wd.week_id < ? AND wd.status != 'approved'\n        \n        UNION ALL\n        \n        SELECT 'monthly_report' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               mr.month_id, 'Monthly report overdue' as description\n        FROM monthly_reports mr\n        JOIN clients c ON mr.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE mr.month_id < ? AND (mr.sent = 0 OR mr.status != 'approved')\n        \n        UNION ALL\n        \n        SELECT 'visma_time' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               vt.week_id, 'Visma time overdue' as description\n        FROM visma_time vt\n        JOIN clients c ON vt.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE vt.week_id < ? AND vt.status != 'approved'\n        \n        ORDER BY client_name\n      `;\n      params = [today, currentWeek, currentMonth, currentWeek];\n    } else {\n      query = `\n        SELECT 'care_plan' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               cp.care_plan_date, 'Care plan overdue - GFP needed' as description\n        FROM care_plans cp\n        JOIN clients c ON cp.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ? AND cp.has_gfp = 0 AND cp.care_plan_date IS NOT NULL \n        AND date(cp.care_plan_date, '+21 days') < ?\n        \n        UNION ALL\n        \n        SELECT 'weekly_doc' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               wd.week_id, 'Weekly documentation overdue' as description\n        FROM weekly_docs wd\n        JOIN clients c ON wd.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ? AND wd.week_id < ? AND wd.status != 'approved'\n        \n        UNION ALL\n        \n        SELECT 'monthly_report' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               mr.month_id, 'Monthly report overdue' as description\n        FROM monthly_reports mr\n        JOIN clients c ON mr.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ? AND mr.month_id < ? AND (mr.sent = 0 OR mr.status != 'approved')\n        \n        UNION ALL\n        \n        SELECT 'visma_time' as type, c.name as client_name, c.initials as client_initials, u.name as staff_name,\n               vt.week_id, 'Visma time overdue' as description\n        FROM visma_time vt\n        JOIN clients c ON vt.client_id = c.id\n        JOIN users u ON c.staff_id = u.id\n        WHERE c.staff_id = ? AND vt.week_id < ? AND vt.status != 'approved'\n        \n        ORDER BY client_name\n      `;\n      params = [user.userId, today, user.userId, currentWeek, user.userId, currentMonth, user.userId, currentWeek];\n    }\n    \n    const overdueItems = safeQuery<{\n      type: string;\n      client_name: string;\n      client_initials: string;\n      staff_name: string;\n      date_field: string;\n      description: string;\n    }>(query, params);\n    \n    res.json({\n      success: true,\n      data: overdueItems\n    });\n    \n  } catch (error) {\n    console.error('Get overdue items error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch overdue items',\n      message: 'An error occurred while fetching overdue items'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/feature-flags.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'FeatureFlag' is defined but never used.","line":9,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":23,"column":58,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":23,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[728,731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[728,731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1177,1180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1177,1180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1898,1901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1898,1901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4294,4297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4294,4297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Feature Flags API Routes\n * Provides management interface for feature flags\n */\n\nimport { Router } from 'express';\nimport type { Request, Response } from 'express';\nimport Database from 'better-sqlite3';\nimport FeatureFlagManager, { type FeatureFlag } from '../utils/feature-flags.js';\nimport type { JwtPayload } from '../types/database.js';\n\nconst router = Router();\n\n// Get feature flag manager instance\nlet featureFlagManager: FeatureFlagManager;\n\nexport function initializeFeatureFlagRoutes(db: Database.Database) {\n  featureFlagManager = new FeatureFlagManager(db);\n  return router;\n}\n\n// Middleware to ensure user is admin\nfunction requireAdmin(req: Request, res: Response, next: Function) {\n  const user = (req as any).user as JwtPayload;\n  if (user?.role !== 'admin') {\n    return res.status(403).json({\n      success: false,\n      error: 'Admin access required',\n      message: 'Only administrators can manage feature flags'\n    });\n  }\n  next();\n}\n\n// Evaluate a feature flag for the current user\nrouter.get('/evaluate/:flagName', (req: Request, res: Response) => {\n  try {\n    const { flagName } = req.params as { flagName: string };\n    const user = (req as any).user as JwtPayload;\n    const environment = process.env.NODE_ENV || 'development';\n\n    const evaluation = featureFlagManager.evaluateFlag(\n      flagName,\n      user?.userId,\n      user?.role,\n      environment\n    );\n\n    res.json({\n      success: true,\n      data: evaluation\n    });\n  } catch (error) {\n    console.error('Failed to evaluate feature flag:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to evaluate feature flag',\n      message: 'An error occurred while evaluating the feature flag'\n    });\n  }\n});\n\n// Evaluate multiple feature flags\nrouter.post('/evaluate', (req: Request, res: Response) => {\n  try {\n    const { flagNames } = req.body;\n    const user = (req as any).user as JwtPayload;\n    const environment = process.env.NODE_ENV || 'development';\n\n    if (!Array.isArray(flagNames)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid request',\n        message: 'flagNames must be an array'\n      });\n    }\n\n    const evaluations = flagNames.map((flagName: string) =>\n      featureFlagManager.evaluateFlag(flagName, user?.userId, user?.role, environment)\n    );\n\n    res.json({\n      success: true,\n      data: evaluations\n    });\n  } catch (error) {\n    console.error('Failed to evaluate feature flags:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to evaluate feature flags',\n      message: 'An error occurred while evaluating the feature flags'\n    });\n  }\n});\n\n// Get all feature flags (admin only)\nrouter.get('/', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const environment = req.query.environment as string;\n    const flags = environment \n      ? featureFlagManager.getFlagsForEnvironment(environment)\n      : featureFlagManager.getAllFlags();\n\n    res.json({\n      success: true,\n      data: {\n        flags,\n        count: flags.length\n      }\n    });\n  } catch (error) {\n    console.error('Failed to get feature flags:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve feature flags',\n      message: 'An error occurred while fetching feature flags'\n    });\n  }\n});\n\n// Get a specific feature flag (admin only)\nrouter.get('/:flagName', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const { flagName } = req.params as { flagName: string };\n    const flags = featureFlagManager.getAllFlags();\n    const flag = flags.find(f => f.name === flagName);\n\n    if (!flag) {\n      return res.status(404).json({\n        success: false,\n        error: 'Feature flag not found',\n        message: `Feature flag '${flagName}' does not exist`\n      });\n    }\n\n    res.json({\n      success: true,\n      data: flag\n    });\n  } catch (error) {\n    console.error('Failed to get feature flag:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to retrieve feature flag',\n      message: 'An error occurred while fetching the feature flag'\n    });\n  }\n});\n\n// Create a new feature flag (admin only)\nrouter.post('/', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const user = (req as any).user as JwtPayload;\n    const {\n      name,\n      description,\n      enabled = false,\n      rolloutPercentage = 0,\n      targetUsers = [],\n      targetRoles = [],\n      environment = 'all',\n      expiresAt,\n      metadata = {}\n    } = req.body;\n\n    if (!name || !description) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid request',\n        message: 'Name and description are required'\n      });\n    }\n\n    // Check if flag already exists\n    const existingFlags = featureFlagManager.getAllFlags();\n    if (existingFlags.find(f => f.name === name)) {\n      return res.status(409).json({\n        success: false,\n        error: 'Feature flag already exists',\n        message: `Feature flag '${name}' already exists`\n      });\n    }\n\n    const newFlag = featureFlagManager.createFlag({\n      name,\n      description,\n      enabled,\n      rolloutPercentage,\n      targetUsers,\n      targetRoles,\n      environment,\n      createdBy: user.userId,\n      expiresAt,\n      metadata\n    });\n\n    res.status(201).json({\n      success: true,\n      data: newFlag\n    });\n  } catch (error) {\n    console.error('Failed to create feature flag:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create feature flag',\n      message: 'An error occurred while creating the feature flag'\n    });\n  }\n});\n\n// Update a feature flag (admin only)\nrouter.put('/:flagName', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const { flagName } = req.params as { flagName: string };\n    const updates = req.body;\n\n    // Remove fields that shouldn't be updated\n    delete updates.id;\n    delete updates.createdAt;\n    delete updates.createdBy;\n\n    const updatedFlag = featureFlagManager.updateFlag(flagName, updates);\n\n    if (!updatedFlag) {\n      return res.status(404).json({\n        success: false,\n        error: 'Feature flag not found',\n        message: `Feature flag '${flagName}' does not exist`\n      });\n    }\n\n    res.json({\n      success: true,\n      data: updatedFlag\n    });\n  } catch (error) {\n    console.error('Failed to update feature flag:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to update feature flag',\n      message: 'An error occurred while updating the feature flag'\n    });\n  }\n});\n\n// Delete a feature flag (admin only)\nrouter.delete('/:flagName', requireAdmin, (req: Request, res: Response) => {\n  try {\n    const { flagName } = req.params as { flagName: string };\n    const deleted = featureFlagManager.deleteFlag(flagName);\n\n    if (!deleted) {\n      return res.status(404).json({\n        success: false,\n        error: 'Feature flag not found',\n        message: `Feature flag '${flagName}' does not exist`\n      });\n    }\n\n    res.json({\n      success: true,\n      data: {\n        message: `Feature flag '${flagName}' deleted successfully`\n      }\n    });\n  } catch (error) {\n    console.error('Failed to delete feature flag:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to delete feature flag',\n      message: 'An error occurred while deleting the feature flag'\n    });\n  }\n});\n\n// Refresh feature flags cache (admin only)\nrouter.post('/refresh', requireAdmin, (req: Request, res: Response) => {\n  try {\n    featureFlagManager.refreshCache();\n    \n    res.json({\n      success: true,\n      data: {\n        message: 'Feature flags cache refreshed successfully'\n      }\n    });\n  } catch (error) {\n    console.error('Failed to refresh feature flags cache:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to refresh cache',\n      message: 'An error occurred while refreshing the feature flags cache'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/monthly-reports.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiResponse' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PaginatedResponse' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Monthly Reports Routes\n * Handles monthly reports CRUD operations\n */\n\nimport { Router } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\nimport { safeQuery, safeQueryOne, safeExecute } from '../database/connection.js';\nimport { nowInStockholm, isValidMonthId } from '../utils/timezone.js';\nimport type { \n  MonthlyReport, \n  CreateMonthlyReportRequest, \n  ApiResponse, \n  PaginatedResponse, \n  JwtPayload \n} from '../types/database.js';\n\nconst router = Router();\n\n/**\n * GET /api/monthly-reports\n * Get all monthly reports for the authenticated user's clients\n */\nrouter.get('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { page = 1, limit = 50, search, client_id, month_id } = req.query;\n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT mr.*, c.name as client_name, c.initials as client_initials, u.name as staff_name\n      FROM monthly_reports mr\n      JOIN clients c ON mr.client_id = c.id\n      JOIN users u ON c.staff_id = u.id\n      WHERE c.staff_id = ?\n    `;\n    const params: (string | number)[] = [user.userId];\n    \n    if (client_id) {\n      query += ` AND mr.client_id = ?`;\n      params.push(String(client_id));\n    }\n    \n    if (month_id) {\n      query += ` AND mr.month_id = ?`;\n      params.push(String(month_id));\n    }\n    \n    if (search) {\n      query += ` AND (c.name LIKE ? OR c.initials LIKE ?)`;\n      params.push(`%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    query += ` ORDER BY mr.month_id DESC, c.name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const monthlyReports = safeQuery<MonthlyReport & { \n      client_name: string; \n      client_initials: string; \n      staff_name: string; \n    }>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM monthly_reports mr\n      JOIN clients c ON mr.client_id = c.id\n      WHERE c.staff_id = ?\n    `;\n    const countParams: (string | number)[] = [user.userId];\n    \n    if (client_id) {\n      countQuery += ` AND mr.client_id = ?`;\n      countParams.push(String(client_id));\n    }\n    \n    if (month_id) {\n      countQuery += ` AND mr.month_id = ?`;\n      countParams.push(String(month_id));\n    }\n    \n    if (search) {\n      countQuery += ` AND (c.name LIKE ? OR c.initials LIKE ?)`;\n      countParams.push(`%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    res.json({\n      success: true,\n      data: {\n        data: monthlyReports,\n        total,\n        page: Number(page),\n        limit: Number(limit),\n        totalPages: Math.ceil(total / Number(limit))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Get monthly reports error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch monthly reports',\n      message: 'An error occurred while fetching monthly reports'\n    });\n  }\n});\n\n/**\n * GET /api/monthly-reports/all\n * Get all monthly reports (admin only)\n */\nrouter.get('/all', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    \n    if (user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        error: 'Admin access required',\n        message: 'Only administrators can view all monthly reports'\n      });\n    }\n    \n    const { page = 1, limit = 50, search, client_id, month_id, staff_id } = req.query;\n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT mr.*, c.name as client_name, c.initials as client_initials, u.name as staff_name\n      FROM monthly_reports mr\n      JOIN clients c ON mr.client_id = c.id\n      JOIN users u ON c.staff_id = u.id\n      WHERE 1=1\n    `;\n    const params: (string | number)[] = [];\n    \n    if (client_id) {\n      query += ` AND mr.client_id = ?`;\n      params.push(String(client_id));\n    }\n    \n    if (month_id) {\n      query += ` AND mr.month_id = ?`;\n      params.push(String(month_id));\n    }\n    \n    if (staff_id) {\n      query += ` AND c.staff_id = ?`;\n      params.push(String(staff_id));\n    }\n    \n    if (search) {\n      query += ` AND (c.name LIKE ? OR c.initials LIKE ? OR u.name LIKE ?)`;\n      params.push(`%${String(search)}%`, `%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    query += ` ORDER BY mr.month_id DESC, c.name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const monthlyReports = safeQuery<MonthlyReport & { \n      client_name: string; \n      client_initials: string; \n      staff_name: string; \n    }>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM monthly_reports mr\n      JOIN clients c ON mr.client_id = c.id\n      WHERE 1=1\n    `;\n    const countParams: (string | number)[] = [];\n    \n    if (client_id) {\n      countQuery += ` AND mr.client_id = ?`;\n      countParams.push(String(client_id));\n    }\n    \n    if (month_id) {\n      countQuery += ` AND mr.month_id = ?`;\n      countParams.push(String(month_id));\n    }\n    \n    if (staff_id) {\n      countQuery += ` AND c.staff_id = ?`;\n      countParams.push(String(staff_id));\n    }\n    \n    if (search) {\n      countQuery += ` AND (c.name LIKE ? OR c.initials LIKE ? OR u.name LIKE ?)`;\n      countParams.push(`%${String(search)}%`, `%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    res.json({\n      success: true,\n      data: {\n        data: monthlyReports,\n        total,\n        page: Number(page),\n        limit: Number(limit),\n        totalPages: Math.ceil(total / Number(limit))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Get all monthly reports error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch monthly reports',\n      message: 'An error occurred while fetching monthly reports'\n    });\n  }\n});\n\n/**\n * GET /api/monthly-reports/:id\n * Get monthly report by ID\n */\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    const monthlyReport = safeQueryOne<MonthlyReport & { \n      client_name: string; \n      client_initials: string; \n      staff_name: string; \n      staff_id: string;\n    }>(`\n      SELECT mr.*, c.name as client_name, c.initials as client_initials, \n             u.name as staff_name, c.staff_id\n      FROM monthly_reports mr\n      JOIN clients c ON mr.client_id = c.id\n      JOIN users u ON c.staff_id = u.id\n      WHERE mr.id = ?\n    `, [id]);\n    \n    if (!monthlyReport) {\n      return res.status(404).json({\n        success: false,\n        error: 'Monthly report not found',\n        message: 'The requested monthly report does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && monthlyReport.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to view this monthly report'\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: monthlyReport\n    });\n    \n  } catch (error) {\n    console.error('Get monthly report error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch monthly report',\n      message: 'An error occurred while fetching the monthly report'\n    });\n  }\n});\n\n/**\n * POST /api/monthly-reports\n * Create new monthly report\n */\nrouter.post('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { client_id, month_id, sent, status }: CreateMonthlyReportRequest & { client_id: string } = req.body;\n    \n    // Validate input\n    if (!client_id || !month_id) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Client ID and month ID are required'\n      });\n    }\n    \n    // Validate month ID format\n    if (!isValidMonthId(month_id)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid month ID format',\n        message: 'Month ID must be in YYYY-MM format'\n      });\n    }\n    \n    // Check if client exists and user has access\n    const client = safeQueryOne<{ id: string; staff_id: string; name: string }>(\n      'SELECT id, staff_id, name FROM clients WHERE id = ?',\n      [client_id]\n    );\n    \n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        error: 'Client not found',\n        message: 'The specified client does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && client.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to create monthly reports for this client'\n      });\n    }\n    \n    // Check if monthly report already exists for this client and month\n    const existingMonthlyReport = safeQueryOne<MonthlyReport>(\n      'SELECT id FROM monthly_reports WHERE client_id = ? AND month_id = ?',\n      [client_id, month_id]\n    );\n    \n    if (existingMonthlyReport) {\n      return res.status(409).json({\n        success: false,\n        error: 'Monthly report already exists',\n        message: 'Monthly report already exists for this client and month'\n      });\n    }\n    \n    // Create monthly report\n    const monthlyReportId = uuidv4();\n    const now = nowInStockholm().toISOString();\n    \n    safeExecute(\n      `INSERT INTO monthly_reports (id, client_id, month_id, sent, status, created_at, updated_at)\n       VALUES (?, ?, ?, ?, ?, ?, ?)`,\n      [\n        monthlyReportId,\n        client_id,\n        month_id,\n        sent ? 1 : 0,\n        status || 'pending',\n        now,\n        now\n      ]\n    );\n    \n    // Get created monthly report\n    const newMonthlyReport = safeQueryOne<MonthlyReport>(\n      'SELECT * FROM monthly_reports WHERE id = ?',\n      [monthlyReportId]\n    );\n    \n    if (!newMonthlyReport) {\n      throw new Error('Failed to retrieve created monthly report');\n    }\n    \n    res.status(201).json({\n      success: true,\n      data: newMonthlyReport\n    });\n    \n  } catch (error) {\n    console.error('Create monthly report error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create monthly report',\n      message: 'An error occurred while creating the monthly report'\n    });\n  }\n});\n\n/**\n * PUT /api/monthly-reports/:id\n * Update monthly report\n */\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    const { month_id, sent, status } = req.body;\n    \n    // Get existing monthly report with client info\n    const existingMonthlyReport = safeQueryOne<MonthlyReport & { \n      client_name: string; \n      staff_id: string;\n    }>(`\n      SELECT mr.*, c.name as client_name, c.staff_id\n      FROM monthly_reports mr\n      JOIN clients c ON mr.client_id = c.id\n      WHERE mr.id = ?\n    `, [id]);\n    \n    if (!existingMonthlyReport) {\n      return res.status(404).json({\n        success: false,\n        error: 'Monthly report not found',\n        message: 'The requested monthly report does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && existingMonthlyReport.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to update this monthly report'\n      });\n    }\n    \n    // Validate month ID format if provided\n    if (month_id && !isValidMonthId(month_id)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid month ID format',\n        message: 'Month ID must be in YYYY-MM format'\n      });\n    }\n    \n    // Check if new month_id already exists for this client\n    if (month_id && month_id !== existingMonthlyReport.month_id) {\n      const duplicateMonthlyReport = safeQueryOne<MonthlyReport>(\n        'SELECT id FROM monthly_reports WHERE client_id = ? AND month_id = ? AND id != ?',\n        [existingMonthlyReport.client_id, month_id, id]\n      );\n      \n      if (duplicateMonthlyReport) {\n        return res.status(409).json({\n          success: false,\n          error: 'Monthly report already exists',\n          message: 'Monthly report already exists for this client and month'\n        });\n      }\n    }\n    \n    // Build update query\n    const updates: string[] = [];\n    const params: (string | number)[] = [];\n    \n    if (month_id !== undefined) {\n      updates.push('month_id = ?');\n      params.push(String(month_id));\n    }\n    \n    if (sent !== undefined) {\n      updates.push('sent = ?');\n      params.push(sent ? 1 : 0);\n    }\n    \n    if (status !== undefined) {\n      updates.push('status = ?');\n      params.push(status);\n    }\n    \n    if (updates.length === 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'No changes provided',\n        message: 'No valid fields to update'\n      });\n    }\n    \n    updates.push('updated_at = ?');\n    params.push(nowInStockholm().toISOString());\n    params.push(id);\n    \n    const query = `UPDATE monthly_reports SET ${updates.join(', ')} WHERE id = ?`;\n    safeExecute(query, params);\n    \n    // Get updated monthly report\n    const updatedMonthlyReport = safeQueryOne<MonthlyReport>(\n      'SELECT * FROM monthly_reports WHERE id = ?',\n      [id]\n    );\n    \n    if (!updatedMonthlyReport) {\n      throw new Error('Failed to retrieve updated monthly report');\n    }\n    \n    res.json({\n      success: true,\n      data: updatedMonthlyReport\n    });\n    \n  } catch (error) {\n    console.error('Update monthly report error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to update monthly report',\n      message: 'An error occurred while updating the monthly report'\n    });\n  }\n});\n\n/**\n * DELETE /api/monthly-reports/:id\n * Delete monthly report\n */\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    // Get existing monthly report with client info\n    const existingMonthlyReport = safeQueryOne<MonthlyReport & { staff_id: string }>(\n      `SELECT mr.*, c.staff_id\n       FROM monthly_reports mr\n       JOIN clients c ON mr.client_id = c.id\n       WHERE mr.id = ?`,\n      [id]\n    );\n    \n    if (!existingMonthlyReport) {\n      return res.status(404).json({\n        success: false,\n        error: 'Monthly report not found',\n        message: 'The requested monthly report does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && existingMonthlyReport.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to delete this monthly report'\n      });\n    }\n    \n    // Delete monthly report\n    safeExecute('DELETE FROM monthly_reports WHERE id = ?', [id]);\n    \n    res.json({\n      success: true,\n      data: {\n        message: 'Monthly report deleted successfully'\n      }\n    });\n    \n  } catch (error) {\n    console.error('Delete monthly report error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to delete monthly report',\n      message: 'An error occurred while deleting the monthly report'\n    });\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/users.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CreateUserRequest' is defined but never used.","line":10,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiResponse' is defined but never used.","line":10,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":51}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * User Routes\n * Handles user management operations\n */\n\nimport { Router } from 'express';\nimport bcrypt from 'bcryptjs';\nimport { safeQuery, safeQueryOne, safeExecute } from '../database/connection.js';\nimport { nowInStockholm } from '../utils/timezone.js';\nimport type { User, CreateUserRequest, ApiResponse, PaginatedResponse, JwtPayload } from '../types/database.js';\n\nconst router = Router();\n\n/**\n * GET /api/users\n * Get all users (admin only)\n */\nrouter.get('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    \n    if (user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        error: 'Admin access required',\n        message: 'Only administrators can view all users'\n      });\n    }\n    \n    const { page = 1, limit = 50, search, role } = req.query;\n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT id, email, name, role, is_active, created_at, updated_at\n      FROM users\n      WHERE 1=1\n    `;\n    const params: (string | number)[] = [];\n    \n    if (role) {\n      query += ` AND role = ?`;\n      params.push(String(role));\n    }\n    \n    if (search) {\n      query += ` AND (name LIKE ? OR email LIKE ?)`;\n      params.push(`%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    query += ` ORDER BY name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const users = safeQuery<Omit<User, 'password_hash'>>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM users\n      WHERE 1=1\n    `;\n    const countParams: (string | number)[] = [];\n    \n    if (role) {\n      countQuery += ` AND role = ?`;\n      countParams.push(String(role));\n    }\n    \n    if (search) {\n      countQuery += ` AND (name LIKE ? OR email LIKE ?)`;\n      countParams.push(`%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    const response: PaginatedResponse<Omit<User, 'password_hash'>> = {\n      data: users,\n      total,\n      page: Number(page),\n      limit: Number(limit),\n      totalPages: Math.ceil(total / Number(limit))\n    };\n    \n    res.json({\n      success: true,\n      data: response\n    });\n    \n  } catch (error) {\n    console.error('Get users error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch users',\n      message: 'An error occurred while fetching users'\n    });\n  }\n});\n\n/**\n * GET /api/users/:id\n * Get user by ID\n */\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    // Check permissions\n    if (user.role !== 'admin' && user.userId !== id) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You can only view your own profile'\n      });\n    }\n    \n    const targetUser = safeQueryOne<Omit<User, 'password_hash'>>(\n      `SELECT id, email, name, role, is_active, created_at, updated_at\n       FROM users WHERE id = ?`,\n      [id]\n    );\n    \n    if (!targetUser) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n        message: 'The requested user does not exist'\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: targetUser\n    });\n    \n  } catch (error) {\n    console.error('Get user error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch user',\n      message: 'An error occurred while fetching the user'\n    });\n  }\n});\n\n/**\n * PUT /api/users/:id\n * Update user\n */\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    const { name, email, role, is_active } = req.body;\n    \n    // Check permissions\n    if (user.role !== 'admin' && user.userId !== id) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You can only update your own profile'\n      });\n    }\n    \n    // Get existing user\n    const existingUser = safeQueryOne<User>(\n      'SELECT * FROM users WHERE id = ?',\n      [id]\n    );\n    \n    if (!existingUser) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n        message: 'The requested user does not exist'\n      });\n    }\n    \n    // Check if email is being changed and if it's already taken\n    if (email && email !== existingUser.email) {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(email)) {\n        return res.status(400).json({\n          success: false,\n          error: 'Invalid email format',\n          message: 'Please provide a valid email address'\n        });\n      }\n      \n      const existingEmail = safeQueryOne<User>(\n        'SELECT id FROM users WHERE email = ? AND id != ?',\n        [email.toLowerCase(), id]\n      );\n      \n      if (existingEmail) {\n        return res.status(409).json({\n          success: false,\n          error: 'Email already exists',\n          message: 'A user with this email already exists'\n        });\n      }\n    }\n    \n    // Check role change permissions\n    if (role && role !== existingUser.role) {\n      if (user.role !== 'admin') {\n        return res.status(403).json({\n          success: false,\n          error: 'Permission denied',\n          message: 'Only administrators can change user roles'\n        });\n      }\n    }\n    \n    // Check is_active change permissions\n    if (typeof is_active === 'boolean' && is_active !== existingUser.is_active) {\n      if (user.role !== 'admin') {\n        return res.status(403).json({\n          success: false,\n          error: 'Permission denied',\n          message: 'Only administrators can activate/deactivate users'\n        });\n      }\n    }\n    \n    // Build update query\n    const updates: string[] = [];\n    const params: (string | number)[] = [];\n    \n    if (name !== undefined) {\n      updates.push('name = ?');\n      params.push(name);\n    }\n    \n    if (email !== undefined) {\n      updates.push('email = ?');\n      params.push(email.toLowerCase());\n    }\n    \n    if (role !== undefined && user.role === 'admin') {\n      updates.push('role = ?');\n      params.push(role);\n    }\n    \n    if (typeof is_active === 'boolean' && user.role === 'admin') {\n      updates.push('is_active = ?');\n      params.push(is_active ? 1 : 0);\n    }\n    \n    if (updates.length === 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'No changes provided',\n        message: 'No valid fields to update'\n      });\n    }\n    \n    updates.push('updated_at = ?');\n    params.push(nowInStockholm().toISOString());\n    params.push(id);\n    \n    const query = `UPDATE users SET ${updates.join(', ')} WHERE id = ?`;\n    safeExecute(query, params);\n    \n    // Get updated user\n    const updatedUser = safeQueryOne<Omit<User, 'password_hash'>>(\n      `SELECT id, email, name, role, is_active, created_at, updated_at\n       FROM users WHERE id = ?`,\n      [id]\n    );\n    \n    if (!updatedUser) {\n      throw new Error('Failed to retrieve updated user');\n    }\n    \n    res.json({\n      success: true,\n      data: updatedUser\n    });\n    \n  } catch (error) {\n    console.error('Update user error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to update user',\n      message: 'An error occurred while updating the user'\n    });\n  }\n});\n\n/**\n * PUT /api/users/:id/password\n * Change user password\n */\nrouter.put('/:id/password', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    const { currentPassword, newPassword } = req.body;\n    \n    // Check permissions\n    if (user.role !== 'admin' && user.userId !== id) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You can only change your own password'\n      });\n    }\n    \n    // Validate input\n    if (!newPassword) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing new password',\n        message: 'New password is required'\n      });\n    }\n    \n    if (newPassword.length < 8) {\n      return res.status(400).json({\n        success: false,\n        error: 'Weak password',\n        message: 'Password must be at least 8 characters long'\n      });\n    }\n    \n    // Get existing user\n    const existingUser = safeQueryOne<User>(\n      'SELECT * FROM users WHERE id = ?',\n      [id]\n    );\n    \n    if (!existingUser) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n        message: 'The requested user does not exist'\n      });\n    }\n    \n    // Verify current password (unless admin changing someone else's password)\n    if (user.role !== 'admin' || user.userId === id) {\n      if (!currentPassword) {\n        return res.status(400).json({\n          success: false,\n          error: 'Current password required',\n          message: 'Current password is required to change password'\n        });\n      }\n      \n      const isValidPassword = await bcrypt.compare(currentPassword, existingUser.password_hash);\n      if (!isValidPassword) {\n        return res.status(401).json({\n          success: false,\n          error: 'Invalid current password',\n          message: 'The current password is incorrect'\n        });\n      }\n    }\n    \n    // Hash new password\n    const saltRounds = 12;\n    const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);\n    \n    // Update password\n    const now = nowInStockholm().toISOString();\n    safeExecute(\n      'UPDATE users SET password_hash = ?, updated_at = ? WHERE id = ?',\n      [newPasswordHash, now, id]\n    );\n    \n    res.json({\n      success: true,\n      data: {\n        message: 'Password updated successfully'\n      }\n    });\n    \n  } catch (error) {\n    console.error('Change password error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to change password',\n      message: 'An error occurred while changing the password'\n    });\n  }\n});\n\n/**\n * DELETE /api/users/:id\n * Delete user (admin only)\n */\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    // Only admins can delete users\n    if (user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        error: 'Admin access required',\n        message: 'Only administrators can delete users'\n      });\n    }\n    \n    // Cannot delete self\n    if (user.userId === id) {\n      return res.status(400).json({\n        success: false,\n        error: 'Cannot delete self',\n        message: 'You cannot delete your own account'\n      });\n    }\n    \n    // Get existing user\n    const existingUser = safeQueryOne<User>(\n      'SELECT * FROM users WHERE id = ?',\n      [id]\n    );\n    \n    if (!existingUser) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n        message: 'The requested user does not exist'\n      });\n    }\n    \n    // Check if user has clients\n    const clientCount = safeQueryOne<{ count: number }>(\n      'SELECT COUNT(*) as count FROM clients WHERE staff_id = ?',\n      [id]\n    );\n    \n    if (clientCount && clientCount.count > 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'User has clients',\n        message: 'Cannot delete user with assigned clients. Please reassign clients first.'\n      });\n    }\n    \n    // Delete user\n    safeExecute('DELETE FROM users WHERE id = ?', [id]);\n    \n    res.json({\n      success: true,\n      data: {\n        message: 'User deleted successfully'\n      }\n    });\n    \n  } catch (error) {\n    console.error('Delete user error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to delete user',\n      message: 'An error occurred while deleting the user'\n    });\n  }\n});\n\nexport default router;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/visma-time.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ApiResponse' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PaginatedResponse' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Visma Time Routes\n * Handles Visma time tracking CRUD operations\n */\n\nimport { Router } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\nimport { safeQuery, safeQueryOne, safeExecute } from '../database/connection.js';\nimport { nowInStockholm, isValidWeekId } from '../utils/timezone.js';\nimport type { \n  VismaTime, \n  CreateVismaTimeRequest, \n  ApiResponse, \n  PaginatedResponse, \n  JwtPayload \n} from '../types/database.js';\n\nconst router = Router();\n\n/**\n * GET /api/visma-time\n * Get all Visma time entries for the authenticated user's clients\n */\nrouter.get('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { page = 1, limit = 50, search, client_id, week_id } = req.query;\n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT vt.*, c.name as client_name, c.initials as client_initials, u.name as staff_name\n      FROM visma_time vt\n      JOIN clients c ON vt.client_id = c.id\n      JOIN users u ON c.staff_id = u.id\n      WHERE c.staff_id = ?\n    `;\n    const params: (string | number)[] = [user.userId];\n    \n    if (client_id) {\n      query += ` AND vt.client_id = ?`;\n      params.push(String(client_id));\n    }\n    \n    if (week_id) {\n      query += ` AND vt.week_id = ?`;\n      params.push(String(week_id));\n    }\n    \n    if (search) {\n      query += ` AND (c.name LIKE ? OR c.initials LIKE ?)`;\n      params.push(`%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    query += ` ORDER BY vt.week_id DESC, c.name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const vismaTime = safeQuery<VismaTime & { \n      client_name: string; \n      client_initials: string; \n      staff_name: string; \n    }>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM visma_time vt\n      JOIN clients c ON vt.client_id = c.id\n      WHERE c.staff_id = ?\n    `;\n    const countParams: (string | number)[] = [user.userId];\n    \n    if (client_id) {\n      countQuery += ` AND vt.client_id = ?`;\n      countParams.push(String(client_id));\n    }\n    \n    if (week_id) {\n      countQuery += ` AND vt.week_id = ?`;\n      countParams.push(String(week_id));\n    }\n    \n    if (search) {\n      countQuery += ` AND (c.name LIKE ? OR c.initials LIKE ?)`;\n      countParams.push(`%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    res.json({\n      success: true,\n      data: {\n        data: vismaTime,\n        total,\n        page: Number(page),\n        limit: Number(limit),\n        totalPages: Math.ceil(total / Number(limit))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Get Visma time error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch Visma time entries',\n      message: 'An error occurred while fetching Visma time entries'\n    });\n  }\n});\n\n/**\n * GET /api/visma-time/all\n * Get all Visma time entries (admin only)\n */\nrouter.get('/all', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    \n    if (user.role !== 'admin') {\n      return res.status(403).json({\n        success: false,\n        error: 'Admin access required',\n        message: 'Only administrators can view all Visma time entries'\n      });\n    }\n    \n    const { page = 1, limit = 50, search, client_id, week_id, staff_id } = req.query;\n    const offset = (Number(page) - 1) * Number(limit);\n    \n    let query = `\n      SELECT vt.*, c.name as client_name, c.initials as client_initials, u.name as staff_name\n      FROM visma_time vt\n      JOIN clients c ON vt.client_id = c.id\n      JOIN users u ON c.staff_id = u.id\n      WHERE 1=1\n    `;\n    const params: (string | number)[] = [];\n    \n    if (client_id) {\n      query += ` AND vt.client_id = ?`;\n      params.push(String(client_id));\n    }\n    \n    if (week_id) {\n      query += ` AND vt.week_id = ?`;\n      params.push(String(week_id));\n    }\n    \n    if (staff_id) {\n      query += ` AND c.staff_id = ?`;\n      params.push(String(staff_id));\n    }\n    \n    if (search) {\n      query += ` AND (c.name LIKE ? OR c.initials LIKE ? OR u.name LIKE ?)`;\n      params.push(`%${String(search)}%`, `%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    query += ` ORDER BY vt.week_id DESC, c.name ASC LIMIT ? OFFSET ?`;\n    params.push(Number(limit), offset);\n    \n    const vismaTime = safeQuery<VismaTime & { \n      client_name: string; \n      client_initials: string; \n      staff_name: string; \n    }>(query, params);\n    \n    // Get total count\n    let countQuery = `\n      SELECT COUNT(*) as total\n      FROM visma_time vt\n      JOIN clients c ON vt.client_id = c.id\n      WHERE 1=1\n    `;\n    const countParams: (string | number)[] = [];\n    \n    if (client_id) {\n      countQuery += ` AND vt.client_id = ?`;\n      countParams.push(String(client_id));\n    }\n    \n    if (week_id) {\n      countQuery += ` AND vt.week_id = ?`;\n      countParams.push(String(week_id));\n    }\n    \n    if (staff_id) {\n      countQuery += ` AND c.staff_id = ?`;\n      countParams.push(String(staff_id));\n    }\n    \n    if (search) {\n      countQuery += ` AND (c.name LIKE ? OR c.initials LIKE ? OR u.name LIKE ?)`;\n      countParams.push(`%${String(search)}%`, `%${String(search)}%`, `%${String(search)}%`);\n    }\n    \n    const totalResult = safeQueryOne<{ total: number }>(countQuery, countParams);\n    const total = totalResult?.total || 0;\n    \n    res.json({\n      success: true,\n      data: {\n        data: vismaTime,\n        total,\n        page: Number(page),\n        limit: Number(limit),\n        totalPages: Math.ceil(total / Number(limit))\n      }\n    });\n    \n  } catch (error) {\n    console.error('Get all Visma time error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch Visma time entries',\n      message: 'An error occurred while fetching Visma time entries'\n    });\n  }\n});\n\n/**\n * GET /api/visma-time/:id\n * Get Visma time entry by ID\n */\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    const vismaTime = safeQueryOne<VismaTime & { \n      client_name: string; \n      client_initials: string; \n      staff_name: string; \n      staff_id: string;\n    }>(`\n      SELECT vt.*, c.name as client_name, c.initials as client_initials, \n             u.name as staff_name, c.staff_id\n      FROM visma_time vt\n      JOIN clients c ON vt.client_id = c.id\n      JOIN users u ON c.staff_id = u.id\n      WHERE vt.id = ?\n    `, [id]);\n    \n    if (!vismaTime) {\n      return res.status(404).json({\n        success: false,\n        error: 'Visma time entry not found',\n        message: 'The requested Visma time entry does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && vismaTime.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to view this Visma time entry'\n      });\n    }\n    \n    res.json({\n      success: true,\n      data: vismaTime\n    });\n    \n  } catch (error) {\n    console.error('Get Visma time entry error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to fetch Visma time entry',\n      message: 'An error occurred while fetching the Visma time entry'\n    });\n  }\n});\n\n/**\n * POST /api/visma-time\n * Create new Visma time entry\n */\nrouter.post('/', async (req, res) => {\n  try {\n    const user = req.user as JwtPayload;\n    const { client_id, week_id, monday, tuesday, wednesday, thursday, friday, status }: CreateVismaTimeRequest & { client_id: string } = req.body;\n    \n    // Validate input\n    if (!client_id || !week_id) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Client ID and week ID are required'\n      });\n    }\n    \n    // Validate week ID format\n    if (!isValidWeekId(week_id)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid week ID format',\n        message: 'Week ID must be in YYYY-WXX format'\n      });\n    }\n    \n    // Check if client exists and user has access\n    const client = safeQueryOne<{ id: string; staff_id: string; name: string }>(\n      'SELECT id, staff_id, name FROM clients WHERE id = ?',\n      [client_id]\n    );\n    \n    if (!client) {\n      return res.status(404).json({\n        success: false,\n        error: 'Client not found',\n        message: 'The specified client does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && client.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to create Visma time entries for this client'\n      });\n    }\n    \n    // Check if Visma time entry already exists for this client and week\n    const existingVismaTime = safeQueryOne<VismaTime>(\n      'SELECT id FROM visma_time WHERE client_id = ? AND week_id = ?',\n      [client_id, week_id]\n    );\n    \n    if (existingVismaTime) {\n      return res.status(409).json({\n        success: false,\n        error: 'Visma time entry already exists',\n        message: 'Visma time entry already exists for this client and week'\n      });\n    }\n    \n    // Create Visma time entry\n    const vismaTimeId = uuidv4();\n    const now = nowInStockholm().toISOString();\n    \n    safeExecute(\n      `INSERT INTO visma_time (id, client_id, week_id, monday, tuesday, wednesday, thursday, friday, status, created_at, updated_at)\n       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n      [\n        vismaTimeId,\n        client_id,\n        week_id,\n        monday ? 1 : 0,\n        tuesday ? 1 : 0,\n        wednesday ? 1 : 0,\n        thursday ? 1 : 0,\n        friday ? 1 : 0,\n        status || 'pending',\n        now,\n        now\n      ]\n    );\n    \n    // Get created Visma time entry\n    const newVismaTime = safeQueryOne<VismaTime>(\n      'SELECT * FROM visma_time WHERE id = ?',\n      [vismaTimeId]\n    );\n    \n    if (!newVismaTime) {\n      throw new Error('Failed to retrieve created Visma time entry');\n    }\n    \n    res.status(201).json({\n      success: true,\n      data: newVismaTime\n    });\n    \n  } catch (error) {\n    console.error('Create Visma time entry error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to create Visma time entry',\n      message: 'An error occurred while creating the Visma time entry'\n    });\n  }\n});\n\n/**\n * PUT /api/visma-time/:id\n * Update Visma time entry\n */\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    const { week_id, monday, tuesday, wednesday, thursday, friday, status } = req.body;\n    \n    // Get existing Visma time entry with client info\n    const existingVismaTime = safeQueryOne<VismaTime & { \n      client_name: string; \n      staff_id: string;\n    }>(`\n      SELECT vt.*, c.name as client_name, c.staff_id\n      FROM visma_time vt\n      JOIN clients c ON vt.client_id = c.id\n      WHERE vt.id = ?\n    `, [id]);\n    \n    if (!existingVismaTime) {\n      return res.status(404).json({\n        success: false,\n        error: 'Visma time entry not found',\n        message: 'The requested Visma time entry does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && existingVismaTime.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to update this Visma time entry'\n      });\n    }\n    \n    // Validate week ID format if provided\n    if (week_id && !isValidWeekId(week_id)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid week ID format',\n        message: 'Week ID must be in YYYY-WXX format'\n      });\n    }\n    \n    // Check if new week_id already exists for this client\n    if (week_id && week_id !== existingVismaTime.week_id) {\n      const duplicateVismaTime = safeQueryOne<VismaTime>(\n        'SELECT id FROM visma_time WHERE client_id = ? AND week_id = ? AND id != ?',\n        [existingVismaTime.client_id, week_id, id]\n      );\n      \n      if (duplicateVismaTime) {\n        return res.status(409).json({\n          success: false,\n          error: 'Visma time entry already exists',\n          message: 'Visma time entry already exists for this client and week'\n        });\n      }\n    }\n    \n    // Build update query\n    const updates: string[] = [];\n    const params: (string | number)[] = [];\n    \n    if (week_id !== undefined) {\n      updates.push('week_id = ?');\n      params.push(String(week_id));\n    }\n    \n    if (monday !== undefined) {\n      updates.push('monday = ?');\n      params.push(monday ? 1 : 0);\n    }\n    \n    if (tuesday !== undefined) {\n      updates.push('tuesday = ?');\n      params.push(tuesday ? 1 : 0);\n    }\n    \n    if (wednesday !== undefined) {\n      updates.push('wednesday = ?');\n      params.push(wednesday ? 1 : 0);\n    }\n    \n    if (thursday !== undefined) {\n      updates.push('thursday = ?');\n      params.push(thursday ? 1 : 0);\n    }\n    \n    if (friday !== undefined) {\n      updates.push('friday = ?');\n      params.push(friday ? 1 : 0);\n    }\n    \n    if (status !== undefined) {\n      updates.push('status = ?');\n      params.push(status);\n    }\n    \n    if (updates.length === 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'No changes provided',\n        message: 'No valid fields to update'\n      });\n    }\n    \n    updates.push('updated_at = ?');\n    params.push(nowInStockholm().toISOString());\n    params.push(id);\n    \n    const query = `UPDATE visma_time SET ${updates.join(', ')} WHERE id = ?`;\n    safeExecute(query, params);\n    \n    // Get updated Visma time entry\n    const updatedVismaTime = safeQueryOne<VismaTime>(\n      'SELECT * FROM visma_time WHERE id = ?',\n      [id]\n    );\n    \n    if (!updatedVismaTime) {\n      throw new Error('Failed to retrieve updated Visma time entry');\n    }\n    \n    res.json({\n      success: true,\n      data: updatedVismaTime\n    });\n    \n  } catch (error) {\n    console.error('Update Visma time entry error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to update Visma time entry',\n      message: 'An error occurred while updating the Visma time entry'\n    });\n  }\n});\n\n/**\n * DELETE /api/visma-time/:id\n * Delete Visma time entry\n */\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const user = req.user as JwtPayload;\n    \n    // Get existing Visma time entry with client info\n    const existingVismaTime = safeQueryOne<VismaTime & { staff_id: string }>(\n      `SELECT vt.*, c.staff_id\n       FROM visma_time vt\n       JOIN clients c ON vt.client_id = c.id\n       WHERE vt.id = ?`,\n      [id]\n    );\n    \n    if (!existingVismaTime) {\n      return res.status(404).json({\n        success: false,\n        error: 'Visma time entry not found',\n        message: 'The requested Visma time entry does not exist'\n      });\n    }\n    \n    // Check permissions\n    if (user.role !== 'admin' && existingVismaTime.staff_id !== user.userId) {\n      return res.status(403).json({\n        success: false,\n        error: 'Access denied',\n        message: 'You do not have permission to delete this Visma time entry'\n      });\n    }\n    \n    // Delete Visma time entry\n    safeExecute('DELETE FROM visma_time WHERE id = ?', [id]);\n    \n    res.json({\n      success: true,\n      data: {\n        message: 'Visma time entry deleted successfully'\n      }\n    });\n    \n  } catch (error) {\n    console.error('Delete Visma time entry error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Failed to delete Visma time entry',\n      message: 'An error occurred while deleting the Visma time entry'\n    });\n  }\n});\n\nexport default router;\n\n\n\n\n\n\n\n\n\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/routes/weekly-docs.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getCurrentWeekId' is defined but never used.","line":8,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'WeeklyDoc' is defined but never used.","line":9,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":24}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Weekly Documentation API Routes\n * Handle CRUD operations for weekly documentation\n */\n\nimport express from 'express';\nimport { getDb } from '../database/connection.js';\nimport { nowInStockholm, getCurrentWeekId } from '../utils/timezone.js';\nimport type { WeeklyDoc, CreateWeeklyDocRequest, UpdateWeeklyDocRequest } from '../types/database.js';\n\nconst router = express.Router();\n\n// Get all weekly docs for a client\nrouter.get('/client/:clientId', async (req, res) => {\n  try {\n    const { clientId } = req.params;\n    const { week_id } = req.query;\n    \n    const db = getDb();\n    let query = 'SELECT * FROM weekly_docs WHERE client_id = ?';\n    const params = [clientId];\n    \n    if (week_id) {\n      query += ' AND week_id = ?';\n      params.push(week_id as string);\n    }\n    \n    query += ' ORDER BY week_id DESC';\n    \n    const weeklyDocs = db.prepare(query).all(...params);\n\n    res.json({\n      success: true,\n      data: weeklyDocs\n    });\n  } catch (error) {\n    console.error('Error fetching weekly docs:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to fetch weekly documentation'\n    });\n  }\n});\n\n// Get weekly docs for a staff member\nrouter.get('/staff/:staffId', async (req, res) => {\n  try {\n    const { staffId } = req.params;\n    const { week_id } = req.query;\n    \n    const db = getDb();\n    let query = `\n      SELECT wd.*, c.name as client_name, c.initials as client_initials\n      FROM weekly_docs wd\n      JOIN clients c ON wd.client_id = c.id\n      WHERE c.assigned_staff_id = ?\n    `;\n    const params = [staffId];\n    \n    if (week_id) {\n      query += ' AND wd.week_id = ?';\n      params.push(week_id as string);\n    }\n    \n    query += ' ORDER BY wd.week_id DESC, c.name ASC';\n    \n    const weeklyDocs = db.prepare(query).all(...params);\n\n    res.json({\n      success: true,\n      data: weeklyDocs\n    });\n  } catch (error) {\n    console.error('Error fetching staff weekly docs:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to fetch weekly documentation'\n    });\n  }\n});\n\n// Get a specific weekly doc\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const db = getDb();\n    \n    const weeklyDoc = db.prepare(`\n      SELECT wd.*, c.name as client_name, c.initials as client_initials\n      FROM weekly_docs wd\n      JOIN clients c ON wd.client_id = c.id\n      WHERE wd.id = ?\n    `).get(id);\n\n    if (!weeklyDoc) {\n      return res.status(404).json({\n        success: false,\n        error: 'Weekly documentation not found',\n        message: 'The requested weekly documentation does not exist'\n      });\n    }\n\n    res.json({\n      success: true,\n      data: weeklyDoc\n    });\n  } catch (error) {\n    console.error('Error fetching weekly doc:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to fetch weekly documentation'\n    });\n  }\n});\n\n// Create a new weekly doc\nrouter.post('/', async (req, res) => {\n  try {\n    const { \n      client_id, \n      week_id, \n      monday, \n      tuesday, \n      wednesday, \n      thursday, \n      friday, \n      saturday, \n      sunday,\n      notes,\n      status = 'pending'\n    } = req.body as CreateWeeklyDocRequest;\n    \n    if (!client_id || !week_id) {\n      return res.status(400).json({\n        success: false,\n        error: 'Missing required fields',\n        message: 'Client ID and week ID are required'\n      });\n    }\n\n    const db = getDb();\n    const now = nowInStockholm().toISOString();\n    \n    // Check if weekly doc already exists for this client and week\n    const existing = db.prepare(\n      'SELECT id FROM weekly_docs WHERE client_id = ? AND week_id = ?'\n    ).get(client_id, week_id);\n    \n    if (existing) {\n      return res.status(409).json({\n        success: false,\n        error: 'Weekly documentation already exists',\n        message: 'Weekly documentation for this client and week already exists'\n      });\n    }\n    \n    const result = db.prepare(`\n      INSERT INTO weekly_docs (\n        client_id, week_id, monday, tuesday, wednesday, thursday, friday, saturday, sunday,\n        notes, status, created_at, updated_at\n      )\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).run(\n      client_id, week_id, \n      monday || false, tuesday || false, wednesday || false, thursday || false, friday || false,\n      saturday || false, sunday || false,\n      notes || '', status, now, now\n    );\n\n    const weeklyDoc = db.prepare(`\n      SELECT wd.*, c.name as client_name, c.initials as client_initials\n      FROM weekly_docs wd\n      JOIN clients c ON wd.client_id = c.id\n      WHERE wd.id = ?\n    `).get(result.lastInsertRowid);\n\n    res.status(201).json({\n      success: true,\n      data: weeklyDoc,\n      message: 'Weekly documentation created successfully'\n    });\n  } catch (error) {\n    console.error('Error creating weekly doc:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to create weekly documentation'\n    });\n  }\n});\n\n// Update a weekly doc\nrouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body as UpdateWeeklyDocRequest;\n    \n    const db = getDb();\n    const now = nowInStockholm().toISOString();\n    \n    // Check if weekly doc exists\n    const existing = db.prepare('SELECT id FROM weekly_docs WHERE id = ?').get(id);\n    if (!existing) {\n      return res.status(404).json({\n        success: false,\n        error: 'Weekly documentation not found',\n        message: 'The requested weekly documentation does not exist'\n      });\n    }\n\n    // Build update query dynamically\n    const updateFields = [];\n    const updateValues = [];\n    \n    const booleanFields = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n    const stringFields = ['notes', 'status'];\n    \n    booleanFields.forEach(field => {\n      if (updates[field as keyof UpdateWeeklyDocRequest] !== undefined) {\n        updateFields.push(`${field} = ?`);\n        updateValues.push(updates[field as keyof UpdateWeeklyDocRequest]);\n      }\n    });\n    \n    stringFields.forEach(field => {\n      if (updates[field as keyof UpdateWeeklyDocRequest] !== undefined) {\n        updateFields.push(`${field} = ?`);\n        updateValues.push(updates[field as keyof UpdateWeeklyDocRequest]);\n      }\n    });\n    \n    updateFields.push('updated_at = ?');\n    updateValues.push(now);\n    updateValues.push(id);\n    \n    db.prepare(`\n      UPDATE weekly_docs \n      SET ${updateFields.join(', ')} \n      WHERE id = ?\n    `).run(...updateValues);\n\n    const weeklyDoc = db.prepare(`\n      SELECT wd.*, c.name as client_name, c.initials as client_initials\n      FROM weekly_docs wd\n      JOIN clients c ON wd.client_id = c.id\n      WHERE wd.id = ?\n    `).get(id);\n\n    res.json({\n      success: true,\n      data: weeklyDoc,\n      message: 'Weekly documentation updated successfully'\n    });\n  } catch (error) {\n    console.error('Error updating weekly doc:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to update weekly documentation'\n    });\n  }\n});\n\n// Delete a weekly doc\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const db = getDb();\n    \n    const result = db.prepare('DELETE FROM weekly_docs WHERE id = ?').run(id);\n    \n    if (result.changes === 0) {\n      return res.status(404).json({\n        success: false,\n        error: 'Weekly documentation not found',\n        message: 'The requested weekly documentation does not exist'\n      });\n    }\n\n    res.json({\n      success: true,\n      message: 'Weekly documentation deleted successfully'\n    });\n  } catch (error) {\n    console.error('Error deleting weekly doc:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Database error',\n      message: 'Failed to delete weekly documentation'\n    });\n  }\n});\n\nexport default router;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/types/database.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3538,3541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3538,3541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Database Types\n * TypeScript interfaces for all database entities\n */\n\nexport type DocStatus = 'pending' | 'approved' | 'rejected';\nexport type UserRole = 'admin' | 'staff';\nexport type WeekId = string; // Format: 'YYYY-WXX'\nexport type MonthId = string; // Format: 'YYYY-MM'\n\n// Database entity interfaces\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  password_hash: string;\n  role: UserRole;\n  is_active: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface Client {\n  id: string;\n  initials: string;\n  name: string;\n  staff_id: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface CarePlan {\n  id: string;\n  client_id: string;\n  care_plan_date: string | null;\n  has_gfp: boolean;\n  staff_notified: boolean;\n  notes: string | null;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface WeeklyDoc {\n  id: string;\n  client_id: string;\n  week_id: WeekId;\n  monday: boolean;\n  tuesday: boolean;\n  wednesday: boolean;\n  thursday: boolean;\n  friday: boolean;\n  saturday: boolean;\n  sunday: boolean;\n  status: DocStatus;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface MonthlyReport {\n  id: string;\n  client_id: string;\n  month_id: MonthId;\n  sent: boolean;\n  status: DocStatus;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface VismaTime {\n  id: string;\n  client_id: string;\n  week_id: WeekId;\n  monday: boolean;\n  tuesday: boolean;\n  wednesday: boolean;\n  thursday: boolean;\n  friday: boolean;\n  status: DocStatus;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface IdempotencyKey {\n  key: string;\n  operation: string;\n  request_hash: string;\n  response: string | null;\n  created_at: string;\n  expires_at: string;\n}\n\n// Extended interfaces with relationships\nexport interface ClientWithRelations extends Client {\n  care_plan?: CarePlan;\n  weekly_docs: WeeklyDoc[];\n  monthly_reports: MonthlyReport[];\n  visma_time: VismaTime[];\n}\n\nexport interface UserWithClients extends User {\n  clients: ClientWithRelations[];\n}\n\n// API request/response types\nexport interface CreateUserRequest {\n  email: string;\n  name: string;\n  password: string;\n  role?: UserRole;\n}\n\nexport interface CreateClientRequest {\n  initials: string;\n  name: string;\n  staff_id: string;\n}\n\nexport interface UpdateCarePlanRequest {\n  care_plan_date?: string;\n  plan_date?: string;\n  has_gfp?: boolean;\n  staff_notified?: boolean;\n  notes?: string;\n  goals?: string;\n  interventions?: string;\n  status?: DocStatus;\n}\n\nexport interface CreateCarePlanRequest {\n  client_id: string;\n  plan_date: string;\n  goals?: string;\n  interventions?: string;\n  notes?: string;\n  status?: DocStatus;\n}\n\nexport interface CreateWeeklyDocRequest {\n  client_id: string;\n  week_id: WeekId;\n  monday?: boolean;\n  tuesday?: boolean;\n  wednesday?: boolean;\n  thursday?: boolean;\n  friday?: boolean;\n  saturday?: boolean;\n  sunday?: boolean;\n  notes?: string;\n  status?: DocStatus;\n}\n\nexport interface UpdateWeeklyDocRequest {\n  monday?: boolean;\n  tuesday?: boolean;\n  wednesday?: boolean;\n  thursday?: boolean;\n  friday?: boolean;\n  saturday?: boolean;\n  sunday?: boolean;\n  notes?: string;\n  status?: DocStatus;\n}\n\nexport interface CreateMonthlyReportRequest {\n  month_id: MonthId;\n  sent?: boolean;\n  status?: DocStatus;\n}\n\nexport interface CreateVismaTimeRequest {\n  week_id: WeekId;\n  monday?: boolean;\n  tuesday?: boolean;\n  wednesday?: boolean;\n  thursday?: boolean;\n  friday?: boolean;\n  status?: DocStatus;\n}\n\n// API response types\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  message?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n}\n\n// Authentication types\nexport interface LoginRequest {\n  email: string;\n  password: string;\n}\n\nexport interface AuthResponse {\n  token: string;\n  user: Omit<User, 'password_hash'>;\n}\n\nexport interface JwtPayload {\n  userId: string;\n  email: string;\n  role: UserRole;\n  iat: number;\n  exp: number;\n}\n\n// KPI and dashboard types\nexport interface KPIMetrics {\n  totalClients: number;\n  totalStaff: number;\n  activeCarePlans: number;\n  waitingCarePlans: number;\n  delayedCarePlans: number;\n  completedThisWeek: number;\n  delayedWeeklyDocs: number;\n  delayedMonthlyReports: number;\n  delayedVismaTime: number;\n}\n\nexport interface WeeklyStats {\n  weekId: WeekId;\n  completedDocs: number;\n  totalDocs: number;\n  completionRate: number;\n}\n\nexport interface MonthlyStats {\n  monthId: MonthId;\n  sentReports: number;\n  totalReports: number;\n  sentRate: number;\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/types/express.d.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Request' is defined but never used.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Express TypeScript declarations\n */\n\nimport { Request } from 'express';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: {\n        userId: string;\n        email: string;\n        role: 'admin' | 'staff';\n        iat?: number;\n        exp?: number;\n      };\n    }\n  }\n}\n\nexport {};\n\n\n\n\n\n\n\n\n\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/utils/audit-logger.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":140,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":140,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":146,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":152,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":152,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":159,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":159,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":165,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":165,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":576,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":576,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18058,18061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18058,18061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Audit Logging System - GDPR Compliant\n * Tracks all security-relevant operations for compliance and monitoring\n * \n * GDPR COMPLIANCE FEATURES:\n * - User ID anonymization with SHA-256 hashing\n * - Automatic data retention (180 days default)\n * - Data portability export functions\n * - Sensitive data redaction\n */\n\nimport Database from 'better-sqlite3';\nimport { randomUUID, createHash } from 'crypto';\nimport type { Request, Response } from 'express';\n\nexport interface AuditEvent {\n  id: string;\n  timestamp: string;\n  actorId: string; // Anonymized user ID\n  actorRole: string; // User role (not sensitive)\n  action: AuditAction;\n  resource: string;\n  resourceId?: string;\n  details: Record<string, unknown>;\n  ipAddress: string;\n  userAgent: string;\n  success: boolean;\n  errorMessage?: string;\n  isAnonymized: boolean; // GDPR compliance flag\n  retentionDays: number; // Data retention period\n  gdprCompliant: boolean; // Overall GDPR compliance flag\n}\n\nexport type AuditAction = \n  | 'LOGIN'\n  | 'LOGOUT'\n  | 'LOGIN_FAILED'\n  | 'PASSWORD_CHANGE'\n  | 'USER_CREATED'\n  | 'USER_UPDATED'\n  | 'USER_DELETED'\n  | 'USER_DEACTIVATED'\n  | 'CLIENT_CREATED'\n  | 'CLIENT_UPDATED'\n  | 'CLIENT_DELETED'\n  | 'CARE_PLAN_CREATED'\n  | 'CARE_PLAN_UPDATED'\n  | 'CARE_PLAN_DELETED'\n  | 'WEEKLY_DOC_CREATED'\n  | 'WEEKLY_DOC_UPDATED'\n  | 'WEEKLY_DOC_DELETED'\n  | 'WEEKLY_DOC_APPROVED'\n  | 'WEEKLY_DOC_REJECTED'\n  | 'MONTHLY_REPORT_CREATED'\n  | 'MONTHLY_REPORT_UPDATED'\n  | 'MONTHLY_REPORT_DELETED'\n  | 'MONTHLY_REPORT_SENT'\n  | 'VISMA_TIME_CREATED'\n  | 'VISMA_TIME_UPDATED'\n  | 'VISMA_TIME_DELETED'\n  | 'DATA_EXPORT'\n  | 'DATA_IMPORT'\n  | 'BACKUP_CREATED'\n  | 'MIGRATION_EXECUTED'\n  | 'ADMIN_ACTION'\n  | 'SECURITY_VIOLATION'\n  | 'RATE_LIMIT_EXCEEDED'\n  | 'INVALID_TOKEN'\n  | 'UNAUTHORIZED_ACCESS';\n\nexport interface AuditLoggerOptions {\n  retentionDays?: number;\n  enableConsoleLogging?: boolean;\n  enableDatabaseLogging?: boolean;\n  sensitiveFields?: string[];\n  gdprCompliant?: boolean; // Enable GDPR compliance features\n  anonymizationSalt?: string; // Salt for user ID anonymization\n}\n\nclass AuditLogger {\n  private db: Database.Database;\n  private options: Required<AuditLoggerOptions>;\n  private cleanupInterval: NodeJS.Timeout | null = null;\n\n  constructor(db: Database.Database, options: AuditLoggerOptions = {}) {\n    this.db = db;\n    this.options = {\n      retentionDays: options.retentionDays || 180, // GDPR: Extended to 180 days\n      enableConsoleLogging: options.enableConsoleLogging ?? true,\n      enableDatabaseLogging: options.enableDatabaseLogging ?? true,\n      sensitiveFields: options.sensitiveFields || ['password', 'password_hash', 'token', 'secret', 'personal_number', 'ssn'],\n      gdprCompliant: options.gdprCompliant ?? true, // GDPR enabled by default\n      anonymizationSalt: options.anonymizationSalt || 'ungdomsstod-gdpr-salt-2024'\n    };\n\n    this.initializeTables();\n    this.startCleanupScheduler();\n  }\n\n  /**\n   * GDPR-compliant user ID anonymization\n   * Creates a consistent but anonymous hash for user tracking\n   */\n  private anonymizeUserId(userId: string): string {\n    if (!userId || userId === 'anonymous') {\n      return 'anonymous';\n    }\n    \n    return createHash('sha256')\n      .update(userId + this.options.anonymizationSalt)\n      .digest('hex')\n      .substring(0, 8); // First 8 characters for brevity\n  }\n\n  private initializeTables(): void {\n    // Create audit_logs table with GDPR compliance\n    this.db.exec(`\n      CREATE TABLE IF NOT EXISTS audit_logs (\n        id TEXT PRIMARY KEY,\n        timestamp TEXT NOT NULL,\n        actor_id TEXT NOT NULL, -- Anonymized user ID\n        actor_role TEXT NOT NULL, -- User role (not sensitive)\n        action TEXT NOT NULL,\n        resource TEXT NOT NULL,\n        resource_id TEXT,\n        details TEXT NOT NULL, -- JSON string\n        ip_address TEXT NOT NULL,\n        user_agent TEXT NOT NULL,\n        success BOOLEAN NOT NULL,\n        error_message TEXT,\n        is_anonymized BOOLEAN DEFAULT 1, -- GDPR compliance flag\n        retention_days INTEGER DEFAULT 180, -- Data retention period\n        gdpr_compliant BOOLEAN DEFAULT 1 -- Overall GDPR compliance flag\n      )\n    `);\n\n    // Add GDPR columns to existing table if they don't exist\n    try {\n      this.db.exec(`ALTER TABLE audit_logs ADD COLUMN is_anonymized BOOLEAN DEFAULT 1`);\n    } catch (e) {\n      // Column already exists\n    }\n    \n    try {\n      this.db.exec(`ALTER TABLE audit_logs ADD COLUMN retention_days INTEGER DEFAULT 180`);\n    } catch (e) {\n      // Column already exists\n    }\n    \n    try {\n      this.db.exec(`ALTER TABLE audit_logs ADD COLUMN gdpr_compliant BOOLEAN DEFAULT 1`);\n    } catch (e) {\n      // Column already exists\n    }\n\n    // Add new GDPR-compliant columns if they don't exist\n    try {\n      this.db.exec(`ALTER TABLE audit_logs ADD COLUMN actor_id TEXT`);\n    } catch (e) {\n      // Column already exists\n    }\n    \n    try {\n      this.db.exec(`ALTER TABLE audit_logs ADD COLUMN actor_role TEXT`);\n    } catch (e) {\n      // Column already exists\n    }\n\n    // Create indexes for performance\n    this.db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp);\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON audit_logs(actor_id);\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_resource ON audit_logs(resource);\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_gdpr ON audit_logs(gdpr_compliant);\n      CREATE INDEX IF NOT EXISTS idx_audit_logs_retention ON audit_logs(retention_days);\n    `);\n  }\n\n  private sanitizeDetails(details: Record<string, unknown>): Record<string, unknown> {\n    const sanitized = { ...details };\n    \n    for (const field of this.options.sensitiveFields) {\n      if (sanitized[field]) {\n        sanitized[field] = '[REDACTED]';\n      }\n    }\n\n    return sanitized;\n  }\n\n  private startCleanupScheduler(): void {\n    // Clean up old audit logs daily\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupOldLogs();\n    }, 24 * 60 * 60 * 1000); // 24 hours\n  }\n\n  private cleanupOldLogs(): void {\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - this.options.retentionDays);\n      const cutoffTimestamp = cutoffDate.toISOString();\n\n      // GDPR compliant cleanup - respects individual retention settings\n      const stmt = this.db.prepare(`\n        DELETE FROM audit_logs \n        WHERE timestamp < ? \n        OR (retention_days IS NOT NULL AND timestamp < datetime('now', '-' || retention_days || ' days'))\n      `);\n      const result = stmt.run(cutoffTimestamp);\n      \n      if (this.options.enableConsoleLogging) {\n        console.log(`🧹 [GDPR Cleanup] Deleted ${result.changes} old audit logs (retention: ${this.options.retentionDays} days)`);\n      }\n    } catch (error) {\n      console.error('❌ [GDPR Cleanup] Failed to cleanup audit logs:', error);\n    }\n  }\n\n  /**\n   * Manual GDPR cleanup function for immediate retention policy enforcement\n   */\n  public async cleanupOldAuditLogs(): Promise<void> {\n    this.cleanupOldLogs();\n  }\n\n  public async logEvent(\n    req: Request,\n    res: Response,\n    action: AuditAction,\n    resource: string,\n    details: Record<string, unknown> = {},\n    resourceId?: string,\n    success: boolean = true,\n    errorMessage?: string\n  ): Promise<void> {\n    try {\n      const user = (req as unknown as { user?: { userId: string; email: string; role?: string } }).user;\n      const userId = user?.userId || 'anonymous';\n      const userRole = user?.role || 'unknown';\n      \n      // GDPR: Anonymize user ID for privacy\n      const anonymizedUserId = this.options.gdprCompliant ? this.anonymizeUserId(userId) : userId;\n      \n      const auditEvent: AuditEvent = {\n        id: randomUUID(),\n        timestamp: new Date().toISOString(),\n        actorId: anonymizedUserId,\n        actorRole: userRole,\n        action,\n        resource,\n        resourceId,\n        details: this.sanitizeDetails(details),\n        ipAddress: req.ip || req.connection.remoteAddress || 'unknown',\n        userAgent: req.get('User-Agent') || 'unknown',\n        success,\n        errorMessage,\n        isAnonymized: this.options.gdprCompliant,\n        retentionDays: this.options.retentionDays,\n        gdprCompliant: this.options.gdprCompliant\n      };\n\n      // Console logging (using anonymized data)\n      if (this.options.enableConsoleLogging) {\n        const level = success ? 'INFO' : 'ERROR';\n        const message = `${level} [AUDIT] ${action} on ${resource} by ${userRole} (${anonymizedUserId})`;\n        console.log(message, { details: auditEvent.details, resourceId });\n      }\n\n      // Database logging with GDPR compliance\n      if (this.options.enableDatabaseLogging) {\n        const stmt = this.db.prepare(`\n          INSERT INTO audit_logs (\n            id, timestamp, actor_id, actor_role, action, resource, resource_id, \n            details, ip_address, user_agent, success, error_message, \n            is_anonymized, retention_days, gdpr_compliant\n          )\n          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `);\n\n        stmt.run(\n          auditEvent.id,\n          auditEvent.timestamp,\n          auditEvent.actorId,\n          auditEvent.actorRole,\n          auditEvent.action,\n          auditEvent.resource,\n          auditEvent.resourceId,\n          JSON.stringify(auditEvent.details),\n          auditEvent.ipAddress,\n          auditEvent.userAgent,\n          auditEvent.success ? 1 : 0,\n          auditEvent.errorMessage,\n          auditEvent.isAnonymized ? 1 : 0,\n          auditEvent.retentionDays,\n          auditEvent.gdprCompliant ? 1 : 0\n        );\n      }\n    } catch (error) {\n      console.error('❌ Failed to log audit event:', error);\n    }\n  }\n\n  public getAuditLogs(\n    filters: {\n      actorId?: string;\n      actorRole?: string;\n      action?: AuditAction;\n      resource?: string;\n      startDate?: string;\n      endDate?: string;\n      limit?: number;\n      offset?: number;\n      gdprCompliant?: boolean;\n    } = {}\n  ): AuditEvent[] {\n    try {\n      let query = 'SELECT * FROM audit_logs WHERE 1=1';\n      const params: (string | number | boolean)[] = [];\n\n      if (filters.actorId) {\n        query += ' AND actor_id = ?';\n        params.push(filters.actorId);\n      }\n\n      if (filters.actorRole) {\n        query += ' AND actor_role = ?';\n        params.push(filters.actorRole);\n      }\n\n      if (filters.action) {\n        query += ' AND action = ?';\n        params.push(filters.action);\n      }\n\n      if (filters.resource) {\n        query += ' AND resource = ?';\n        params.push(filters.resource);\n      }\n\n      if (filters.startDate) {\n        query += ' AND timestamp >= ?';\n        params.push(filters.startDate);\n      }\n\n      if (filters.endDate) {\n        query += ' AND timestamp <= ?';\n        params.push(filters.endDate);\n      }\n\n      if (filters.gdprCompliant !== undefined) {\n        query += ' AND gdpr_compliant = ?';\n        params.push(filters.gdprCompliant ? 1 : 0);\n      }\n\n      query += ' ORDER BY timestamp DESC';\n\n      if (filters.limit) {\n        query += ' LIMIT ?';\n        params.push(filters.limit);\n      }\n\n      if (filters.offset) {\n        query += ' OFFSET ?';\n        params.push(filters.offset);\n      }\n\n      const stmt = this.db.prepare(query);\n      const rows = stmt.all(...params) as Array<{\n        id: string;\n        timestamp: string;\n        actor_id: string;\n        actor_role: string;\n        action: string;\n        resource: string;\n        resource_id: string | null;\n        details: string;\n        ip_address: string;\n        user_agent: string;\n        success: number;\n        error_message: string | null;\n        is_anonymized: number;\n        retention_days: number;\n        gdpr_compliant: number;\n      }>;\n\n      return rows.map(row => ({\n        id: row.id,\n        timestamp: row.timestamp,\n        actorId: row.actor_id,\n        actorRole: row.actor_role,\n        action: row.action as AuditAction,\n        resource: row.resource,\n        resourceId: row.resource_id ?? undefined,\n        details: JSON.parse(row.details) as Record<string, unknown>,\n        ipAddress: row.ip_address,\n        userAgent: row.user_agent,\n        success: Boolean(row.success),\n        errorMessage: row.error_message ?? undefined,\n        isAnonymized: Boolean(row.is_anonymized || 0),\n        retentionDays: row.retention_days || 180,\n        gdprCompliant: Boolean(row.gdpr_compliant || 0)\n      }));\n    } catch (error) {\n      console.error('❌ Failed to get audit logs:', error);\n      return [];\n    }\n  }\n\n  /**\n   * GDPR Data Portability: Export user audit logs in anonymized format\n   */\n  public exportUserAuditLogs(actorRole: string): Promise<AuditEvent[]> {\n    return Promise.resolve(this.getAuditLogs({\n      actorRole,\n      gdprCompliant: true,\n      limit: 10000 // Reasonable limit for export\n    }));\n  }\n\n  /**\n   * GDPR Right to be Forgotten: Delete all audit logs for a specific user\n   * Note: Only use for legitimate GDPR requests\n   */\n  public async deleteUserAuditLogs(actorId: string): Promise<number> {\n    try {\n      const stmt = this.db.prepare('DELETE FROM audit_logs WHERE actor_id = ?');\n      const result = stmt.run(actorId);\n      \n      if (this.options.enableConsoleLogging) {\n        console.log(`🗑️ [GDPR] Deleted ${result.changes} audit logs for actor: ${actorId}`);\n      }\n      \n      return result.changes || 0;\n    } catch (error) {\n      console.error('❌ [GDPR] Failed to delete user audit logs:', error);\n      return 0;\n    }\n  }\n\n  public getSecurityViolations(limit: number = 100): AuditEvent[] {\n    return this.getAuditLogs({\n      action: 'SECURITY_VIOLATION',\n      limit\n    });\n  }\n\n  public getFailedLogins(limit: number = 100): AuditEvent[] {\n    return this.getAuditLogs({\n      action: 'LOGIN_FAILED',\n      limit\n    });\n  }\n\n  public getAdminActions(limit: number = 100): AuditEvent[] {\n    return this.getAuditLogs({\n      action: 'ADMIN_ACTION',\n      limit\n    });\n  }\n\n  public getStats(): {\n    totalLogs: number;\n    securityViolations: number;\n    failedLogins: number;\n    adminActions: number;\n    lastActivity: string | null;\n  } {\n    try {\n      const totalLogs = this.db.prepare('SELECT COUNT(*) as count FROM audit_logs').get() as { count: number };\n      const securityViolations = this.db.prepare('SELECT COUNT(*) as count FROM audit_logs WHERE action = ?').get('SECURITY_VIOLATION') as { count: number };\n      const failedLogins = this.db.prepare('SELECT COUNT(*) as count FROM audit_logs WHERE action = ?').get('LOGIN_FAILED') as { count: number };\n      const adminActions = this.db.prepare('SELECT COUNT(*) as count FROM audit_logs WHERE action = ?').get('ADMIN_ACTION') as { count: number };\n      const lastActivity = this.db.prepare('SELECT timestamp FROM audit_logs ORDER BY timestamp DESC LIMIT 1').get() as { timestamp: string } | null;\n\n      return {\n        totalLogs: totalLogs.count,\n        securityViolations: securityViolations.count,\n        failedLogins: failedLogins.count,\n        adminActions: adminActions.count,\n        lastActivity: lastActivity?.timestamp || null\n      };\n    } catch (error) {\n      console.error('❌ Failed to get audit stats:', error);\n      return {\n        totalLogs: 0,\n        securityViolations: 0,\n        failedLogins: 0,\n        adminActions: 0,\n        lastActivity: null\n      };\n    }\n  }\n\n  public destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n}\n\n// Express middleware for automatic audit logging\nexport function auditMiddleware(auditLogger: AuditLogger) {\n  return (req: Request, res: Response, next: () => void) => {\n    const originalSend = res.send;\n    \n    res.send = function(data: unknown) {\n      // Log the request after response is sent\n      const success = res.statusCode < 400;\n      \n      // Determine action based on method and route\n      let action: AuditAction;\n      const method = req.method;\n      const path = req.path;\n      \n      if (path.includes('/auth/login')) {\n        action = success ? 'LOGIN' : 'LOGIN_FAILED';\n      } else if (path.includes('/auth/logout')) {\n        action = 'LOGOUT';\n      } else if (method === 'POST' && path.includes('/users')) {\n        action = 'USER_CREATED';\n      } else if (method === 'PUT' && path.includes('/users')) {\n        action = 'USER_UPDATED';\n      } else if (method === 'DELETE' && path.includes('/users')) {\n        action = 'USER_DELETED';\n      } else if (method === 'POST' && path.includes('/clients')) {\n        action = 'CLIENT_CREATED';\n      } else if (method === 'PUT' && path.includes('/clients')) {\n        action = 'CLIENT_UPDATED';\n      } else if (method === 'DELETE' && path.includes('/clients')) {\n        action = 'CLIENT_DELETED';\n      } else if (path.includes('/admin')) {\n        action = 'ADMIN_ACTION';\n      } else {\n        // Generic action based on method\n        action = method === 'POST' ? 'DATA_CREATED' as AuditAction : \n                method === 'PUT' ? 'DATA_UPDATED' as AuditAction :\n                method === 'DELETE' ? 'DATA_DELETED' as AuditAction : \n                'DATA_ACCESSED' as AuditAction;\n      }\n\n      const resource = path.split('/').pop() || 'unknown';\n      const resourceId = req.params.id;\n      \n      auditLogger.logEvent(\n        req,\n        res,\n        action,\n        resource,\n        {\n          method,\n          path,\n          statusCode: res.statusCode,\n          body: req.body\n        },\n        resourceId,\n        success\n      );\n\n      return originalSend.call(this, data);\n    };\n\n    next();\n  };\n}\n\n// GDPR Export functions for standalone use\nimport { getDatabase } from '../database/connection.js';\n\n/**\n * GDPR Data Portability: Export user audit logs in anonymized format\n * Returns only anonymized data for compliance with GDPR Article 20\n */\nexport async function exportUserAuditLogs(userRole: string): Promise<any[]> {\n  try {\n    const db = getDatabase();\n    \n    // Returnera endast anonymiserad data\n    const logs = db.prepare(`\n      SELECT * FROM audit_logs \n      WHERE actor_role = ? \n      AND is_anonymized = 1 \n      AND gdpr_compliant = 1\n      ORDER BY timestamp DESC\n    `).all(userRole);\n    \n    console.log(`📤 [GDPR Export] Exported ${logs.length} audit logs for role: ${userRole}`);\n    return logs;\n  } catch (error) {\n    console.error('❌ [GDPR Export] Failed to export user audit logs:', error);\n    return [];\n  }\n}\n\n/**\n * GDPR Cleanup function for external use\n */\nexport async function cleanupOldAuditLogs(): Promise<void> {\n  try {\n    const db = getDatabase();\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - 180); // 180 days retention\n    \n    const result = db.prepare(`\n      DELETE FROM audit_logs \n      WHERE timestamp < ? \n      OR (retention_days IS NOT NULL AND timestamp < datetime('now', '-' || retention_days || ' days'))\n    `).run(cutoffDate.toISOString());\n    \n    console.log(`🧹 [GDPR Cleanup] Deleted ${result.changes} old audit logs`);\n  } catch (error) {\n    console.error('❌ [GDPR Cleanup] Error:', error);\n  }\n}\n\nexport default AuditLogger;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/utils/feature-flags.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/utils/idempotency.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'randomBytes' is defined but never used.","line":6,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Idempotency Utilities\n * Ensures safe API operations with idempotency keys\n */\n\nimport { createHash, randomBytes } from 'crypto';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getDatabase, safeQueryOne, safeExecute } from '../database/connection.js';\nimport type { IdempotencyKey } from '../types/database.js';\nimport type { Request, Response, NextFunction } from 'express';\n\nconst IDEMPOTENCY_KEY_EXPIRY_HOURS = 24;\n\n/**\n * Generate idempotency key\n */\nexport function generateIdempotencyKey(): string {\n  return `idem_${uuidv4()}`;\n}\n\n/**\n * Generate request hash for idempotency\n */\nexport function generateRequestHash(requestBody: Record<string, unknown>, userId?: string): string {\n  const data = {\n    body: requestBody,\n    userId: userId || 'anonymous',\n    timestamp: new Date().toISOString()\n  };\n  \n  return createHash('sha256')\n    .update(JSON.stringify(data))\n    .digest('hex');\n}\n\n/**\n * Check if idempotency key exists and is valid\n */\nexport function checkIdempotencyKey(key: string): IdempotencyKey | null {\n  const query = `\n    SELECT * FROM idempotency_keys \n    WHERE key = ? AND expires_at > datetime('now')\n  `;\n  \n  return safeQueryOne<IdempotencyKey>(query, [key]);\n}\n\n/**\n * Store idempotency key with response\n */\nexport function storeIdempotencyKey(\n  key: string,\n  operation: string,\n  requestHash: string,\n  response: Record<string, unknown>\n): void {\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + IDEMPOTENCY_KEY_EXPIRY_HOURS);\n  \n  const query = `\n    INSERT OR REPLACE INTO idempotency_keys \n    (key, operation, request_hash, response, expires_at)\n    VALUES (?, ?, ?, ?, ?)\n  `;\n  \n  safeExecute(query, [\n    key,\n    operation,\n    requestHash,\n    JSON.stringify(response),\n    expiresAt.toISOString()\n  ]);\n}\n\n/**\n * Store idempotency key without response (for pending operations)\n */\nexport function storePendingIdempotencyKey(\n  key: string,\n  operation: string,\n  requestHash: string\n): void {\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + IDEMPOTENCY_KEY_EXPIRY_HOURS);\n  \n  const query = `\n    INSERT OR REPLACE INTO idempotency_keys \n    (key, operation, request_hash, response, expires_at)\n    VALUES (?, ?, ?, NULL, ?)\n  `;\n  \n  safeExecute(query, [\n    key,\n    operation,\n    requestHash,\n    expiresAt.toISOString()\n  ]);\n}\n\n/**\n * Complete idempotency key with response\n */\nexport function completeIdempotencyKey(key: string, response: Record<string, unknown>): void {\n  const query = `\n    UPDATE idempotency_keys \n    SET response = ?\n    WHERE key = ?\n  `;\n  \n  safeExecute(query, [JSON.stringify(response), key]);\n}\n\n/**\n * Clean up expired idempotency keys\n */\nexport function cleanupExpiredIdempotencyKeys(): void {\n  const query = `\n    DELETE FROM idempotency_keys \n    WHERE expires_at <= datetime('now')\n  `;\n  \n  const result = safeExecute(query);\n  if (result.changes > 0) {\n    console.log(`🧹 Cleaned up ${result.changes} expired idempotency keys`);\n  }\n}\n\n/**\n * Middleware for Express to handle idempotency\n */\nexport function idempotencyMiddleware() {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const idempotencyKey = req.headers['idempotency-key'] as string;\n    \n    if (!idempotencyKey) {\n      return next();\n    }\n    \n    // Generate request hash\n    const requestHash = generateRequestHash(req.body, (req.user as { userId?: string })?.userId);\n    \n    // Check if key exists\n    const existing = checkIdempotencyKey(idempotencyKey);\n    \n    if (existing) {\n      if (existing.response) {\n        // Return cached response\n        try {\n          const cachedResponse = JSON.parse(existing.response);\n          return res.json(cachedResponse);\n        } catch (error) {\n          console.error('Failed to parse cached response:', error);\n        }\n      } else {\n        // Operation is pending, return 409 Conflict\n        return res.status(409).json({\n          success: false,\n          error: 'Operation already in progress',\n          message: 'This operation is already being processed'\n        });\n      }\n    }\n    \n    // Store pending operation\n    storePendingIdempotencyKey(\n      idempotencyKey,\n      `${req.method} ${req.path}`,\n      requestHash\n    );\n    \n    // Override res.json to cache the response\n    const originalJson = res.json.bind(res);\n    res.json = function(data: unknown) {\n      completeIdempotencyKey(idempotencyKey, data as Record<string, unknown>);\n      return originalJson(data);\n    };\n    \n    next();\n  };\n}\n\n/**\n * Generate idempotency key from request\n */\nexport function generateKeyFromRequest(req: Request): string {\n  const { method, path, body, user } = req;\n  \n  // Create a deterministic key based on request content\n  const keyData = {\n    method,\n    path,\n    body,\n    userId: (user as { userId?: string })?.userId\n  };\n  \n  const hash = createHash('sha256')\n    .update(JSON.stringify(keyData))\n    .digest('hex');\n  \n  return `req_${hash.substring(0, 16)}`;\n}\n\n/**\n * Validate idempotency key format\n */\nexport function isValidIdempotencyKey(key: string): boolean {\n  return /^[a-zA-Z0-9_-]{8,64}$/.test(key);\n}\n\n/**\n * Get idempotency statistics\n */\nexport function getIdempotencyStats(): {\n  total: number;\n  expired: number;\n  pending: number;\n  completed: number;\n} {\n  const db = getDatabase();\n  \n  const total = db.prepare(`\n    SELECT COUNT(*) as count FROM idempotency_keys\n  `).get() as { count: number };\n  \n  const expired = db.prepare(`\n    SELECT COUNT(*) as count FROM idempotency_keys \n    WHERE expires_at <= datetime('now')\n  `).get() as { count: number };\n  \n  const pending = db.prepare(`\n    SELECT COUNT(*) as count FROM idempotency_keys \n    WHERE response IS NULL AND expires_at > datetime('now')\n  `).get() as { count: number };\n  \n  const completed = db.prepare(`\n    SELECT COUNT(*) as count FROM idempotency_keys \n    WHERE response IS NOT NULL AND expires_at > datetime('now')\n  `).get() as { count: number };\n  \n  return {\n    total: total.count,\n    expired: expired.count,\n    pending: pending.count,\n    completed: completed.count\n  };\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/server/utils/timezone.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'startOfMonth' is defined but never used.","line":6,"column":61,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":73},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":93,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":123,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":123,"endColumn":17}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Timezone Utilities\n * Handles Europe/Stockholm timezone for all date operations\n */\n\nimport { format, parseISO, isValid, startOfWeek, endOfWeek, startOfMonth, endOfMonth } from 'date-fns';\nimport { zonedTimeToUtc, utcToZonedTime, format as formatTz } from 'date-fns-tz';\n\nexport const STOCKHOLM_TIMEZONE = 'Europe/Stockholm';\n\n/**\n * Get current date/time in Stockholm timezone\n */\nexport function nowInStockholm(): Date {\n  return utcToZonedTime(new Date(), STOCKHOLM_TIMEZONE);\n}\n\n/**\n * Format date to Stockholm timezone\n */\nexport function formatInStockholm(date: Date, formatString: string): string {\n  return formatTz(date, formatString, { timeZone: STOCKHOLM_TIMEZONE });\n}\n\n/**\n * Convert UTC date to Stockholm timezone\n */\nexport function toStockholmTime(utcDate: Date): Date {\n  return utcToZonedTime(utcDate, STOCKHOLM_TIMEZONE);\n}\n\n/**\n * Convert Stockholm time to UTC\n */\nexport function toUtc(stockholmDate: Date): Date {\n  return zonedTimeToUtc(stockholmDate, STOCKHOLM_TIMEZONE);\n}\n\n/**\n * Get current week ID in Stockholm timezone (YYYY-WXX format)\n */\nexport function getCurrentWeekId(): string {\n  const stockholmDate = nowInStockholm();\n  return formatInStockholm(stockholmDate, 'yyyy-\\'W\\'II');\n}\n\n/**\n * Get current month ID in Stockholm timezone (YYYY-MM format)\n */\nexport function getCurrentMonthId(): string {\n  const stockholmDate = nowInStockholm();\n  return formatInStockholm(stockholmDate, 'yyyy-MM');\n}\n\n/**\n * Get current date in Stockholm timezone (YYYY-MM-DD format)\n */\nexport function getCurrentDateId(): string {\n  const stockholmDate = nowInStockholm();\n  return formatInStockholm(stockholmDate, 'yyyy-MM-dd');\n}\n\n/**\n * Parse week ID to date range in Stockholm timezone\n */\nexport function parseWeekId(weekId: string): { start: Date; end: Date } | null {\n  try {\n    // Parse YYYY-WXX format\n    const match = weekId.match(/^(\\d{4})-W(\\d{2})$/);\n    if (!match) return null;\n    \n    const year = parseInt(match[1]!, 10);\n    const week = parseInt(match[2]!, 10);\n    \n    // Create date for the first day of the year\n    const firstDayOfYear = new Date(year, 0, 1);\n    \n    // Find the first Monday of the year (ISO week)\n    const firstMonday = startOfWeek(firstDayOfYear, { weekStartsOn: 1 });\n    \n    // Calculate the start of the requested week\n    const weekStart = new Date(firstMonday);\n    weekStart.setDate(firstMonday.getDate() + (week - 1) * 7);\n    \n    // Convert to Stockholm timezone\n    const stockholmStart = utcToZonedTime(weekStart, STOCKHOLM_TIMEZONE);\n    const stockholmEnd = endOfWeek(stockholmStart, { weekStartsOn: 1 });\n    \n    return {\n      start: stockholmStart,\n      end: stockholmEnd\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Parse month ID to date range in Stockholm timezone\n */\nexport function parseMonthId(monthId: string): { start: Date; end: Date } | null {\n  try {\n    // Parse YYYY-MM format\n    const match = monthId.match(/^(\\d{4})-(\\d{2})$/);\n    if (!match) return null;\n    \n    const year = parseInt(match[1]!, 10);\n    const month = parseInt(match[2]!, 10);\n    \n    if (month < 1 || month > 12) return null;\n    \n    const monthStart = new Date(year, month - 1, 1);\n    const monthEnd = endOfMonth(monthStart);\n    \n    // Convert to Stockholm timezone\n    const stockholmStart = utcToZonedTime(monthStart, STOCKHOLM_TIMEZONE);\n    const stockholmEnd = utcToZonedTime(monthEnd, STOCKHOLM_TIMEZONE);\n    \n    return {\n      start: stockholmStart,\n      end: stockholmEnd\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Validate week ID format\n */\nexport function isValidWeekId(weekId: string): boolean {\n  return /^\\d{4}-W\\d{2}$/.test(weekId) && parseWeekId(weekId) !== null;\n}\n\n/**\n * Validate month ID format\n */\nexport function isValidMonthId(monthId: string): boolean {\n  return /^\\d{4}-\\d{2}$/.test(monthId) && parseMonthId(monthId) !== null;\n}\n\n/**\n * Get all week IDs for a given year in Stockholm timezone\n */\nexport function getWeekIdsForYear(year: number): string[] {\n  const weekIds: string[] = [];\n  const firstDay = new Date(year, 0, 1);\n  const lastDay = new Date(year, 11, 31);\n  \n  let current = startOfWeek(firstDay, { weekStartsOn: 1 });\n  \n  while (current <= lastDay) {\n    const stockholmDate = utcToZonedTime(current, STOCKHOLM_TIMEZONE);\n    weekIds.push(formatInStockholm(stockholmDate, 'yyyy-\\'W\\'II'));\n    current = new Date(current.getTime() + 7 * 24 * 60 * 60 * 1000);\n  }\n  \n  return weekIds;\n}\n\n/**\n * Get all month IDs for a given year\n */\nexport function getMonthIdsForYear(year: number): string[] {\n  return Array.from({ length: 12 }, (_, i) => \n    format(new Date(year, i, 1), 'yyyy-MM')\n  );\n}\n\n/**\n * Add days to a date in Stockholm timezone\n */\nexport function addDaysInStockholm(date: Date, days: number): Date {\n  const stockholmDate = utcToZonedTime(date, STOCKHOLM_TIMEZONE);\n  const newDate = new Date(stockholmDate);\n  newDate.setDate(stockholmDate.getDate() + days);\n  return zonedTimeToUtc(newDate, STOCKHOLM_TIMEZONE);\n}\n\n/**\n * Format date for display in Stockholm timezone\n */\nexport function formatForDisplay(date: Date | string): string {\n  const dateObj = typeof date === 'string' ? parseISO(date) : date;\n  if (!isValid(dateObj)) return 'Invalid date';\n  \n  return formatInStockholm(dateObj, 'yyyy-MM-dd HH:mm');\n}\n\n/**\n * Format date for API (ISO string in Stockholm timezone)\n */\nexport function formatForApi(date: Date): string {\n  return formatInStockholm(date, \"yyyy-MM-dd'T'HH:mm:ss.SSSxxx\");\n}\n\n/**\n * Parse API date string to Stockholm timezone\n */\nexport function parseApiDate(dateString: string): Date {\n  const parsed = parseISO(dateString);\n  return utcToZonedTime(parsed, STOCKHOLM_TIMEZONE);\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/App.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/App.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/App.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'UI_TOKENS' is assigned a value but never used.","line":10,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState, useRef } from \"react\";\nimport { AppState, DocStatus, WeekId, MonthId, Staff, Client, Plan, GFPPlan, WeeklyDoc, MonthlyReport, VismaWeek, View, HistoryEntry } from \"./types\";\nimport { getStoredData, getBackups, getStorageType } from \"./storage\";\nimport { getCurrentWeek, getCurrentMonth, addWeeks, addMonths, addDaysISO, todayYMD } from \"./date\";\nimport SaveBar from \"./components/SaveBar\";\nimport StaffSummary from \"./components/StaffSummary\";\nimport GroupAttendanceWidget from \"./components/GroupAttendanceWidget\";\n\n// NEW: UI Tokens for consistent styling\nconst UI_TOKENS = {\n  colors: {\n    primary: '#007aff',\n    orange: '#ff9500',\n    red: '#ff3b30',\n    green: '#16a34a',\n    textPrimary: '#111111',\n    textSecondary: '#374151',\n    border: 'rgba(0,0,0,0.12)',\n    sidebarActive: '#e9f2ff'\n  },\n  inputBase: {\n    padding: '8px 12px',\n    border: '1px solid rgba(0,0,0,0.12)',\n    borderRadius: '6px',\n    fontSize: '14px',\n    backgroundColor: '#ffffff',\n    color: '#111111'\n  },\n  selectBase: {\n    padding: '8px 12px',\n    border: '1px solid rgba(0,0,0,0.12)',\n    borderRadius: '6px',\n    fontSize: '14px',\n    backgroundColor: '#ffffff',\n    color: '#111111'\n  },\n  textareaBase: {\n    padding: '8px 12px',\n    border: '1px solid rgba(0,0,0,0.12)',\n    borderRadius: '6px',\n    fontSize: '14px',\n    backgroundColor: '#ffffff',\n    color: '#111111',\n    resize: 'vertical' as const\n  }\n};\n\n// NEW: Central status label mapping\nconst STATUS_LABEL: Record<DocStatus, string> = {\n  approved: 'Godkänd',\n  pending: 'Väntar', \n  rejected: 'Ej godkänt/komplettera'\n};\n\n// NEW: Debounce helper for note saving\nfunction debounceNote(fn: (noteValue: string) => void, ms: number = 500): (noteValue: string) => void {\n  let timeoutId: number;\n  return (noteValue: string) => {\n    clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => fn(noteValue), ms);\n  };\n}\n\n// NEW: Period-based data persistence helpers with proper isolation\nconst PERIOD_DATA_PREFIX = 'us:';\n\nfunction getPeriodKey(clientId: string, periodType: 'weekly' | 'monthly', periodId: string): string {\n  return `${PERIOD_DATA_PREFIX}${clientId}:${periodType}:${periodId}`;\n}\n\nfunction savePeriodData(clientId: string, periodType: 'weekly' | 'monthly', periodId: string, data: WeeklyDoc | MonthlyReport): void {\n  try {\n    const key = getPeriodKey(clientId, periodType, periodId);\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.warn(`Failed to save ${periodType} data for ${clientId}:${periodId}:`, error);\n  }\n}\n\nfunction loadPeriodData<T extends WeeklyDoc | MonthlyReport>(\n  clientId: string, \n  periodType: 'weekly' | 'monthly', \n  periodId: string, \n  defaultData: T\n): T {\n  try {\n    const key = getPeriodKey(clientId, periodType, periodId);\n    const stored = localStorage.getItem(key);\n    if (stored) {\n      const parsed = JSON.parse(stored) as T;\n      return { ...defaultData, ...parsed };\n    }\n  } catch (error) {\n    console.warn(`Failed to load ${periodType} data for ${clientId}:${periodId}:`, error);\n  }\n  return defaultData;\n}\n\n// NEW: Cleanup orphaned period data for clients that no longer exist (but preserve archived clients' history and us:history)\nfunction cleanupClientLocalStorage(allClientIds: Set<string>): void {\n  try {\n    const keysToRemove: string[] = [];\n    \n    // Scan all localStorage keys for period data\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(PERIOD_DATA_PREFIX)) {\n        // Parse key: us:clientId:periodType:periodId\n        const parts = key.split(':');\n        if (parts.length >= 2 && parts[1]) {\n          const clientId = parts[1];\n          // Only remove if client doesn't exist at all (including archived ones)\n          if (!allClientIds.has(clientId)) {\n            keysToRemove.push(key);\n          }\n        }\n      }\n    }\n    \n    // Remove orphaned keys (but NEVER touch us:history)\n    keysToRemove.forEach(key => {\n      if (key !== HISTORY_KEY) { // Extra safety check\n        localStorage.removeItem(key);\n      }\n    });\n    \n    if (keysToRemove.length > 0) {\n      console.log(`Cleaned up ${keysToRemove.length} orphaned period data entries (preserved history)`);\n    }\n  } catch (error) {\n    console.warn('Failed to cleanup orphaned period data:', error);\n  }\n}\n\n// NEW: Get all client IDs from state (including archived ones to preserve history)\nfunction getAllClientIds(state: AppState): Set<string> {\n  const clientIds = new Set<string>();\n  state.staff.forEach(staff => {\n    staff.clients.forEach(client => {\n      clientIds.add(client.id);\n    });\n  });\n  return clientIds;\n}\n\n// NEW: History management functions\nconst HISTORY_KEY = 'us:history';\n\nfunction loadHistory(): HistoryEntry[] {\n  try {\n    const stored = localStorage.getItem(HISTORY_KEY);\n    if (stored) {\n      return JSON.parse(stored) as HistoryEntry[];\n    }\n  } catch (error) {\n    console.warn('Failed to load history:', error);\n  }\n  return [];\n}\n\nfunction saveHistory(history: HistoryEntry[]): void {\n  try {\n    localStorage.setItem(HISTORY_KEY, JSON.stringify(history));\n  } catch (error) {\n    console.warn('Failed to save history:', error);\n  }\n}\n\nfunction upsertHistory(entry: Omit<HistoryEntry, 'id' | 'ts'>): void {\n  const history = loadHistory();\n  const now = new Date().toISOString();\n  \n  // Create unique key for idempotency (commented out as not used in current implementation)\n  // const key = `${entry.periodType}:${entry.periodId}:${entry.staffId}:${entry.clientId}:${entry.metric}`;\n  \n  // Find existing entry\n  const existingIndex = history.findIndex(h => \n    h.periodType === entry.periodType &&\n    h.periodId === entry.periodId &&\n    h.staffId === entry.staffId &&\n    h.clientId === entry.clientId &&\n    h.metric === entry.metric\n  );\n  \n  const newEntry: HistoryEntry = {\n    id: existingIndex >= 0 ? history[existingIndex]!.id : crypto.randomUUID(),\n    ...entry,\n    ts: now\n  };\n  \n  if (existingIndex >= 0) {\n    // Update existing entry\n    history[existingIndex] = newEntry;\n  } else {\n    // Add new entry\n    history.push(newEntry);\n  }\n  \n  saveHistory(history);\n}\n\n// Helper functions for future use (currently not used but available for extensions)\n// function getHistoryForPeriod(periodType: 'week' | 'month', periodId: string): HistoryEntry[] {\n//   const history = loadHistory();\n//   return history.filter(h => h.periodType === periodType && h.periodId === periodId);\n// }\n\n// function getHistoryForClient(clientId: string): HistoryEntry[] {\n//   const history = loadHistory();\n//   return history.filter(h => h.clientId === clientId);\n// }\n\n// function getHistoryForStaff(staffId: string): HistoryEntry[] {\n//   const history = loadHistory();\n//   return history.filter(h => h.staffId === staffId);\n// }\n\n// NEW: Retention and export functions\nfunction retentionSweep(cutoffDays: number): { \n  toRemove: Array<{ type: 'client' | 'plan' | 'weeklyDoc' | 'monthlyReport' | 'vismaWeek'; \n                   id: string; \n                   staffId: string; \n                   clientId?: string; \n                   data: Client | GFPPlan | WeeklyDoc | MonthlyReport | VismaWeek; \n                   deletedAt: string }>;\n  cutoffDate: string;\n} {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - cutoffDays);\n  const cutoffISO = cutoffDate.toISOString();\n  \n  const toRemove: Array<{ type: 'client' | 'plan' | 'weeklyDoc' | 'monthlyReport' | 'vismaWeek'; \n                         id: string; \n                         staffId: string; \n                         clientId?: string; \n                         data: Client | GFPPlan | WeeklyDoc | MonthlyReport | VismaWeek; \n                         deletedAt: string }> = [];\n  \n  // Scan all staff and clients for old archived/deleted items\n  const currentState = loadState();\n  const allStaff: Staff[] = currentState?.staff || [];\n  \n  allStaff.forEach((staff: Staff) => {\n    staff.clients.forEach((client: Client) => {\n      // Check client-level deletion/archiving\n      if (client.archivedAt && client.archivedAt < cutoffISO) {\n        toRemove.push({\n          type: 'client',\n          id: client.id,\n          staffId: staff.id,\n          clientId: client.id,\n          data: client,\n          deletedAt: client.archivedAt\n        });\n      } else if (client.deletedAt && client.deletedAt < cutoffISO) {\n        toRemove.push({\n          type: 'client',\n          id: client.id,\n          staffId: staff.id,\n          clientId: client.id,\n          data: client,\n          deletedAt: client.deletedAt\n        });\n      } else {\n        // Check individual items within active clients\n        // GFP Plans\n        client.plans.forEach((plan: GFPPlan) => {\n          if (plan.deletedAt && plan.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'plan',\n              id: plan.id,\n              staffId: staff.id,\n              clientId: client.id,\n              data: plan,\n              deletedAt: plan.deletedAt\n            });\n          }\n        });\n        \n        // Weekly Docs\n        Object.values(client.weeklyDocs).forEach((doc: WeeklyDoc) => {\n          if (doc.deletedAt && doc.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'weeklyDoc',\n              id: doc.weekId,\n              staffId: staff.id,\n              clientId: client.id,\n              data: doc,\n              deletedAt: doc.deletedAt\n            });\n          }\n        });\n        \n        // Monthly Reports\n        Object.values(client.monthlyReports).forEach((report: MonthlyReport) => {\n          if (report.deletedAt && report.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'monthlyReport',\n              id: report.monthId,\n              staffId: staff.id,\n              clientId: client.id,\n              data: report,\n              deletedAt: report.deletedAt\n            });\n          }\n        });\n        \n        // Visma Weeks\n        Object.values(client.visma).forEach((visma: VismaWeek) => {\n          if (visma.deletedAt && visma.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'vismaWeek',\n              id: visma.weekId,\n              staffId: staff.id,\n              clientId: client.id,\n              data: visma,\n              deletedAt: visma.deletedAt\n            });\n          }\n        });\n      }\n    });\n  });\n  \n  return { toRemove, cutoffDate: cutoffISO };\n}\n\nfunction exportToJSON(data: unknown[], filename: string): void {\n  const jsonStr = JSON.stringify(data, null, 2);\n  const blob = new Blob([jsonStr], { type: 'application/json' });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}\n\nfunction exportToCSV(data: Record<string, unknown>[], filename: string): void {\n  if (data.length === 0) return;\n  \n  const firstRow = data[0];\n  if (!firstRow) return;\n  \n  const headers = Object.keys(firstRow);\n  const csvContent = [\n    headers.join(','),\n    ...data.map(row => \n      headers.map(header => {\n        const value = row[header];\n        // Escape CSV values\n        if (typeof value === 'string' && (value.includes(',') || value.includes('\"') || value.includes('\\n'))) {\n          return `\"${value.replace(/\"/g, '\"\"')}\"`;\n        }\n        return value;\n      }).join(',')\n    )\n  ].join('\\n');\n  \n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = filename;\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  URL.revokeObjectURL(url);\n}\n\n// NEW: Helper functions for counting affected items\nfunction countClientData(client: Client): { plans: number; weeks: number; months: number } {\n  return {\n    plans: client.plans.length,\n    weeks: Object.keys(client.weeklyDocs).length,\n    months: Object.keys(client.monthlyReports).length\n  };\n}\n\nfunction countStaffData(staff: Staff): { clients: number; totalPlans: number; totalWeeks: number; totalMonths: number } {\n  let totalPlans = 0;\n  let totalWeeks = 0;\n  let totalMonths = 0;\n  \n  staff.clients.forEach(client => {\n    const counts = countClientData(client);\n    totalPlans += counts.plans;\n    totalWeeks += counts.weeks;\n    totalMonths += counts.months;\n  });\n  \n  return {\n    clients: staff.clients.length,\n    totalPlans,\n    totalWeeks,\n    totalMonths\n  };\n}\n\n// NEW: Enhanced ConfirmDialog component with impact summary\ninterface ConfirmDialogProps {\n  open: boolean;\n  title: string;\n  description: string;\n  impactSummary?: string;\n  onConfirm: () => void;\n  onCancel: () => void;\n}\n\nfunction ConfirmDialog({ open, title, description, impactSummary, onConfirm, onCancel }: ConfirmDialogProps) {\n  const confirmButtonRef = useRef<HTMLButtonElement>(null);\n\n  // Autofokus på \"Ta bort\"-knappen när dialog öppnas\n  useEffect(() => {\n    if (open && confirmButtonRef.current) {\n      confirmButtonRef.current.focus();\n    }\n  }, [open]);\n\n  // Keyboard handling\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Escape') {\n      onCancel();\n    } else if (e.key === 'Enter') {\n      onConfirm();\n    }\n  };\n\n  if (!open) return null;\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        inset: 0,\n        background: 'rgba(0, 0, 0, 0.35)',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        zIndex: 1000,\n        padding: 16\n      }}\n      onKeyDown={handleKeyDown}\n      tabIndex={-1}\n    >\n      <div\n        style={{\n          background: '#ffffff',\n          borderRadius: 12,\n          padding: 24,\n          maxWidth: 450,\n          width: '100%',\n          boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',\n          border: '1px solid rgba(0, 0, 0, 0.1)'\n        }}\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"confirm-dialog-title\"\n        aria-describedby=\"confirm-dialog-description\"\n      >\n        <h3\n          id=\"confirm-dialog-title\"\n          style={{\n            fontSize: 18,\n            fontWeight: 700,\n            color: '#111827',\n            margin: '0 0 12px 0',\n            lineHeight: 1.4\n          }}\n        >\n          {title}\n        </h3>\n        \n        <p\n          id=\"confirm-dialog-description\"\n          style={{\n            fontSize: 14,\n            color: '#374151',\n            margin: '0 0 16px 0',\n            lineHeight: 1.5\n          }}\n        >\n          {description}\n        </p>\n        \n        {impactSummary && (\n          <div\n            style={{\n              background: '#fef3c7',\n              border: '1px solid #f59e0b',\n              borderRadius: 8,\n              padding: 12,\n              margin: '0 0 24px 0'\n            }}\n          >\n            <div style={{\n              fontSize: 13,\n              fontWeight: 600,\n              color: '#92400e',\n              marginBottom: 4\n            }}>\n              Detta påverkar:\n            </div>\n            <div style={{\n              fontSize: 14,\n              color: '#92400e',\n              lineHeight: 1.4\n            }}>\n              {impactSummary}\n            </div>\n          </div>\n        )}\n        \n        <div\n          style={{\n            display: 'flex',\n            gap: 12,\n            justifyContent: 'flex-end'\n          }}\n        >\n          <button\n            onClick={onCancel}\n            style={{\n              background: '#f8fafc',\n              color: '#374151',\n              border: '1px solid #e5e7eb',\n              borderRadius: 8,\n              padding: '8px 16px',\n              fontSize: 14,\n              fontWeight: 600,\n              cursor: 'pointer',\n              transition: 'all 0.15s ease'\n            }}\n            onMouseOver={(e) => {\n              e.currentTarget.style.background = '#e2e8f0';\n              e.currentTarget.style.borderColor = '#cbd5e1';\n            }}\n            onMouseOut={(e) => {\n              e.currentTarget.style.background = '#f8fafc';\n              e.currentTarget.style.borderColor = '#e5e7eb';\n            }}\n          >\n            Avbryt\n          </button>\n          \n          <button\n            ref={confirmButtonRef}\n            onClick={onConfirm}\n            style={{\n              background: '#ff3b30',\n              color: '#ffffff',\n              border: '1px solid #ff3b30',\n              borderRadius: 8,\n              padding: '8px 16px',\n              fontSize: 14,\n              fontWeight: 600,\n              cursor: 'pointer',\n              transition: 'all 0.15s ease'\n            }}\n            onMouseOver={(e) => {\n              e.currentTarget.style.background = '#e53e3e';\n              e.currentTarget.style.borderColor = '#e53e3e';\n            }}\n            onMouseOut={(e) => {\n              e.currentTarget.style.background = '#ff3b30';\n              e.currentTarget.style.borderColor = '#ff3b30';\n            }}\n          >\n            Ta bort\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n/* ---------- GFP Plan Helper Functions ---------- */\nfunction nextGfpTitle(plans: GFPPlan[]): string { \n  return `GFP ${plans.length + 1}`; \n}\n\nfunction latestPlan(plans: GFPPlan[] | undefined): GFPPlan | undefined {\n  if (!plans || plans.length === 0) return undefined;\n  // Filter out soft-deleted plans and return the first (newest) active plan\n  const activePlans = plans.filter(p => !p.deletedAt);\n  return activePlans[0]; // Nyaste först\n}\n\n/**\n * Ungdomsstöd Admin – Komplett version\n * - LocalStorage + fallback till minne\n * - Export/Import (fil + clipboard, med fallback)\n * - Automatisk backup (senaste 7)\n * - Dashboard, KPI:er, Personal, Klient, Rapporter, Inställningar\n * - Inline-styles (medveten designbeslut för enkelhet och portabilitet)\n * - Typ-säkring vid import\n * - SaveBar med auto-save och toast-meddelanden\n * - Responsiv klientvy med accordion på mobil\n * \n * NOTE: Inline-styles används medvetet enligt projektreglerna.\n * Webhint-varningar om \"no-inline-styles\" kan ignoreras.\n */\n\n/* ---------- Helper Components ---------- */\n\n// StatusPill Component\ninterface StatusPillProps {\n  status: DocStatus;\n  size?: 'small' | 'medium';\n}\n\nfunction StatusPill({ status, size = 'small' }: StatusPillProps) {\n  const colors = {\n    approved: '#16a34a',\n    pending: '#ff9500', \n    rejected: '#ff3b30'\n  };\n  \n  // UPDATED: Use central STATUS_LABEL mapping instead of local labels\n  const pillSize = size === 'small' ? { padding: '2px 8px', fontSize: '11px' } : { padding: '4px 12px', fontSize: '12px' };\n  \n  return (\n    <span style={{\n      ...pillSize,\n      background: colors[status],\n      color: '#ffffff',\n      borderRadius: '12px',\n      fontWeight: '600',\n      textTransform: 'uppercase' as const,\n      letterSpacing: '0.5px',\n      display: 'inline-block',\n      whiteSpace: 'nowrap' as const\n    }}>\n      {STATUS_LABEL[status]}\n    </span>\n  );\n}\n\n// Card Component  \ninterface CardProps {\n  title: string;\n  status?: DocStatus;\n  headerActions?: React.ReactNode;\n  children: React.ReactNode;\n  className?: string;\n}\n\nfunction Card({ title, status, headerActions, children }: CardProps) {\n  return (\n    <div style={{\n      background: '#fff',\n      border: '1px solid rgba(0,0,0,0.12)',\n      borderRadius: 14,\n      padding: 12,\n      boxShadow: '0 1px 2px rgba(0,0,0,0.04)',\n      height: 'fit-content'\n    }}>\n      <div style={{\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        marginBottom: 8,\n        flexWrap: 'wrap',\n        gap: 8\n      }}>\n        <div style={{ display: 'flex', alignItems: 'center', gap: 8, flex: 1 }}>\n          <div style={{ fontWeight: 800, fontSize: 14 }}>{title}</div>\n          {status && <StatusPill status={status} />}\n        </div>\n        {headerActions && (\n          <div style={{ display: 'flex', gap: 6, alignItems: 'center' }}>\n            {headerActions}\n          </div>\n        )}\n      </div>\n      {children}\n    </div>\n  );\n}\n\n// Accordion Component\ninterface AccordionProps {\n  sections: Array<{\n    id: string;\n    title: string;\n    status?: DocStatus;\n    headerActions?: React.ReactNode;\n    children: React.ReactNode;\n  }>;\n}\n\nfunction Accordion({ sections }: AccordionProps) {\n  const [openSection, setOpenSection] = useState<string | null>(sections[0]?.id || null);\n  \n  return (\n    <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>\n      {sections.map((section) => {\n        const isOpen = openSection === section.id;\n        return (\n          <div key={section.id} style={{\n            background: '#fff',\n            border: '1px solid rgba(0,0,0,0.12)',\n            borderRadius: 14,\n            overflow: 'hidden',\n            boxShadow: '0 1px 2px rgba(0,0,0,0.04)'\n          }}>\n            <button\n              onClick={() => setOpenSection(isOpen ? null : section.id)}\n              style={{\n                width: '100%',\n                padding: '12px 16px',\n                background: isOpen ? '#f8fafc' : '#fff',\n                border: 'none',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'space-between',\n                cursor: 'pointer',\n                fontSize: 14,\n                fontWeight: 800,\n                color: '#111111',\n                transition: 'background 0.15s ease'\n              }}\n              aria-expanded={isOpen}\n              aria-controls={`accordion-content-${section.id}`}\n            >\n              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>\n                <span>{section.title}</span>\n                {section.status && <StatusPill status={section.status} />}\n              </div>\n              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>\n                {section.headerActions}\n                <svg \n                  width={16} \n                  height={16} \n                  viewBox=\"0 0 24 24\" \n                  style={{ \n                    transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',\n                    transition: 'transform 0.2s ease'\n                  }}\n                  aria-hidden=\"true\"\n                >\n                  <path d=\"M7 10l5 5 5-5\" stroke=\"#6b7280\" strokeWidth=\"2\" fill=\"none\" strokeLinecap=\"round\" strokeLinejoin=\"round\"/>\n                </svg>\n              </div>\n            </button>\n            {isOpen && (\n              <div \n                id={`accordion-content-${section.id}`}\n                style={{ padding: '0 16px 16px 16px' }}\n              >\n                {section.children}\n              </div>\n            )}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\n// PeriodPicker Component - Navigation för veckor och månader\ninterface PeriodPickerProps {\n  type: 'week' | 'month';\n  value: string;\n  onChange: (newValue: string) => void;\n}\n\nfunction PeriodPicker({ type, value, onChange }: PeriodPickerProps) {\n  const goBack = () => {\n    if (type === 'week') {\n      onChange(addWeeks(value, -1));\n    } else {\n      onChange(addMonths(value, -1));\n    }\n  };\n\n  const goForward = () => {\n    if (type === 'week') {\n      onChange(addWeeks(value, 1));\n    } else {\n      onChange(addMonths(value, 1));\n    }\n  };\n\n  const goToCurrent = () => {\n    if (type === 'week') {\n      onChange(getCurrentWeek());\n    } else {\n      onChange(getCurrentMonth());\n    }\n  };\n\n  const inputWidth = type === 'week' ? 92 : 92;\n  const placeholder = type === 'week' ? 'YYYY-WXX' : 'YYYY-MM';\n\n  return (\n    <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>\n      <button\n        onClick={goBack}\n        style={{\n          background: '#f8fafc',\n          border: '1px solid rgba(0,0,0,0.12)',\n          borderRadius: 6,\n          padding: '6px 8px',\n          cursor: 'pointer',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          minWidth: 28,\n          height: 28,\n          fontSize: 14,\n          color: '#374151',\n          transition: 'all 0.15s ease'\n        }}\n        onMouseOver={(e) => {\n          e.currentTarget.style.background = '#e2e8f0';\n          e.currentTarget.style.borderColor = '#007aff';\n        }}\n        onMouseOut={(e) => {\n          e.currentTarget.style.background = '#f8fafc';\n          e.currentTarget.style.borderColor = 'rgba(0,0,0,0.12)';\n        }}\n        aria-label={`Föregående ${type === 'week' ? 'vecka' : 'månad'}`}\n      >\n        ◀\n      </button>\n      \n      <input\n        type=\"text\"\n        value={value}\n        onChange={(e) => onChange(e.target.value)}\n        placeholder={placeholder}\n        style={{ \n          background: '#ffffff',\n          color: '#111111',\n          border: '1px solid rgba(0,0,0,0.12)',\n          borderRadius: 6,\n          padding: '4px 8px',\n          outline: 'none',\n          boxShadow: '0 1px 1px rgba(0,0,0,0.02)',\n          width: inputWidth,\n          textAlign: 'center',\n          fontSize: 12,\n          fontWeight: 600\n        }}\n        aria-label={`${type === 'week' ? 'Vecka' : 'Månad'} input`}\n      />\n      \n      <button\n        onClick={goForward}\n        style={{\n          background: '#f8fafc',\n          border: '1px solid rgba(0,0,0,0.12)',\n          borderRadius: 6,\n          padding: '6px 8px',\n          cursor: 'pointer',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          minWidth: 28,\n          height: 28,\n          fontSize: 14,\n          color: '#374151',\n          transition: 'all 0.15s ease'\n        }}\n        onMouseOver={(e) => {\n          e.currentTarget.style.background = '#e2e8f0';\n          e.currentTarget.style.borderColor = '#007aff';\n        }}\n        onMouseOut={(e) => {\n          e.currentTarget.style.background = '#f8fafc';\n          e.currentTarget.style.borderColor = 'rgba(0,0,0,0.12)';\n        }}\n        aria-label={`Nästa ${type === 'week' ? 'vecka' : 'månad'}`}\n      >\n        ▶\n      </button>\n      \n      <button\n        onClick={goToCurrent}\n        style={{\n          background: '#007aff',\n          color: '#ffffff',\n          border: '1px solid #007aff',\n          borderRadius: 6,\n          padding: '4px 8px',\n          fontSize: 11,\n          fontWeight: 600,\n          cursor: 'pointer',\n          transition: 'all 0.15s ease',\n          marginLeft: 4\n        }}\n        onMouseOver={(e) => {\n          e.currentTarget.style.background = '#0051d5';\n          e.currentTarget.style.borderColor = '#0051d5';\n        }}\n        onMouseOut={(e) => {\n          e.currentTarget.style.background = '#007aff';\n          e.currentTarget.style.borderColor = '#007aff';\n        }}\n      >\n        Nu\n      </button>\n    </div>\n  );\n}\n\n\n// DayMatrix Component - Kompakt dagmatris för vecko- och Visma-data\ninterface DayMatrixProps {\n  days: Record<string, boolean>;\n  weekId: WeekId;\n  onChange: (day: string, checked: boolean) => void;\n  type: 'weekly' | 'visma';\n}\n\nfunction DayMatrix({ days, weekId, onChange, type }: DayMatrixProps) {\n  // Dag-etiketter och ordning\n  const dayLabels = type === 'weekly' \n    ? ['må', 'ti', 'on', 'to', 'fr', 'lö', 'sö']\n    : ['må', 'ti', 'on', 'to', 'fr']; // Visma bara vardagar\n    \n  const dayKeys = type === 'weekly'\n    ? ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']\n    : ['mon', 'tue', 'wed', 'thu', 'fri'];\n\n  // Beräkna verkliga datum för tooltips\n  const getDateForDay = (dayIndex: number): string => {\n    try {\n      // Parse ISO week: YYYY-Wxx\n      const match = weekId.match(/^(\\d{4})-W(\\d{2})$/);\n      if (!match) return '';\n      \n      const year = parseInt(match[1]!, 10);\n      const week = parseInt(match[2]!, 10);\n      \n      // Skapa måndagen för den veckan\n      const jan4 = new Date(year, 0, 4);\n      const startOfYear = new Date(jan4.getTime() - (jan4.getDay() - 1) * 24 * 60 * 60 * 1000);\n      const monday = new Date(startOfYear.getTime() + (week - 1) * 7 * 24 * 60 * 60 * 1000);\n      \n      // Lägg till dagar för att få rätt dag\n      const targetDate = new Date(monday.getTime() + dayIndex * 24 * 60 * 60 * 1000);\n      \n      return targetDate.toLocaleDateString('sv-SE');\n    } catch {\n      return '';\n    }\n  };\n\n  const markWorkDays = () => {\n    ['mon', 'tue', 'wed', 'thu', 'fri'].forEach(day => {\n      if (days[day] !== undefined) {\n        onChange(day, true);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    dayKeys.forEach(day => {\n      if (days[day] !== undefined) {\n        onChange(day, false);\n      }\n    });\n  };\n\n  // Kontrollera om några dagar är valda\n  const hasSelectedDays = dayKeys.some(day => days[day] === true);\n\n  return (\n    <div style={{ marginBottom: 12 }}>\n      {/* Dagmatris */}\n      <div style={{ \n        display: 'grid', \n        gridTemplateColumns: `repeat(${dayLabels.length}, 1fr)`, \n        gap: 4, \n        marginBottom: 8,\n        maxWidth: 280\n      }}>\n        {dayLabels.map((label, index) => {\n          const dayKey = dayKeys[index]!;\n          const isChecked = days[dayKey] || false;\n          const dateStr = getDateForDay(index);\n          const tooltip = `${label} ${dateStr} (${weekId})`;\n          \n          return (\n            <label \n              key={dayKey}\n              style={{ \n                display: 'flex', \n                flexDirection: 'column', \n                alignItems: 'center', \n                gap: 3,\n                cursor: 'pointer',\n                padding: 2\n              }}\n              title={tooltip}\n            >\n              <div style={{ \n                fontSize: 11, \n                fontWeight: 600, \n                color: '#374151',\n                lineHeight: 1\n              }}>\n                {label}\n              </div>\n              <div style={{\n                width: 32,\n                height: 32,\n                border: '2px solid #e5e7eb',\n                borderRadius: 6,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                background: isChecked ? '#007aff' : '#ffffff',\n                borderColor: isChecked ? '#007aff' : '#e5e7eb',\n                transition: 'all 0.15s ease',\n                cursor: 'pointer'\n              }}>\n                <input\n                  type=\"checkbox\"\n                  checked={isChecked}\n                  onChange={(e) => onChange(dayKey, e.target.checked)}\n                  style={{\n                    width: 16,\n                    height: 16,\n                    cursor: 'pointer',\n                    accentColor: '#007aff'\n                  }}\n                  aria-label={tooltip}\n                />\n              </div>\n            </label>\n          );\n        })}\n      </div>\n      \n      {/* Knapprad */}\n      <div style={{ \n        display: 'flex', \n        gap: 6, \n        flexWrap: 'wrap',\n        alignItems: 'center' \n      }}>\n        <button\n          onClick={markWorkDays}\n          style={{\n            background: '#f0f7ff',\n            color: '#007aff',\n            border: '1px solid #007aff',\n            borderRadius: 6,\n            padding: '4px 8px',\n            fontSize: 11,\n            fontWeight: 600,\n            cursor: 'pointer',\n            transition: 'all 0.15s ease'\n          }}\n          onMouseOver={(e) => {\n            e.currentTarget.style.background = '#007aff';\n            e.currentTarget.style.color = '#ffffff';\n          }}\n          onMouseOut={(e) => {\n            e.currentTarget.style.background = '#f0f7ff';\n            e.currentTarget.style.color = '#007aff';\n          }}\n        >\n          Markera arbetsdagar\n        </button>\n        \n        <button\n          onClick={clearAll}\n          style={{\n            background: '#f8fafc',\n            color: '#6b7280',\n            border: '1px solid #e5e7eb',\n            borderRadius: 6,\n            padding: '4px 8px',\n            fontSize: 11,\n            fontWeight: 600,\n            cursor: 'pointer',\n            transition: 'all 0.15s ease'\n          }}\n          onMouseOver={(e) => {\n            e.currentTarget.style.background = '#fee2e2';\n            e.currentTarget.style.color = '#dc2626';\n            e.currentTarget.style.borderColor = '#fecaca';\n          }}\n          onMouseOut={(e) => {\n            e.currentTarget.style.background = '#f8fafc';\n            e.currentTarget.style.color = '#6b7280';\n            e.currentTarget.style.borderColor = '#e5e7eb';\n          }}\n        >\n          Rensa alla\n        </button>\n      </div>\n\n      {/* Tomt-läge meddelande */}\n      {!hasSelectedDays && (\n        <div style={{\n          fontSize: 11,\n          color: '#9ca3af',\n          textAlign: 'center',\n          fontStyle: 'italic',\n          marginTop: 8,\n          padding: '4px 8px'\n        }}>\n          {type === 'weekly' \n            ? 'Ingen dokumentation vald denna vecka' \n            : 'Ingen tid registrerad denna vecka'\n          }\n        </div>\n      )}\n    </div>\n  );\n}\n\n// KPI Card Component\ntype KpiVariant = 'late' | 'waiting' | 'info' | 'neutral' | 'success';\n\nconst KPI_COLORS: Record<KpiVariant, {accent: string; text: string; bg: string;}> = {\n  late:    { accent: '#ff3b30', text: '#111827', bg: 'rgba(255,59,48,0.06)' },\n  waiting: { accent: '#ff9500', text: '#111827', bg: 'rgba(255,149,0,0.06)' },\n  info:    { accent: '#007aff', text: '#111827', bg: 'rgba(0,122,255,0.06)' },\n  success: { accent: '#16a34a', text: '#111827', bg: 'rgba(22,163,74,0.06)' },\n  neutral: { accent: '#6b7280', text: '#111827', bg: 'rgba(107,114,128,0.06)' },\n};\n\ninterface KpiCardProps {\n  title: string;\n  value: number | string;\n  subtitle?: string;\n  variant?: KpiVariant;\n  icon?: React.ReactNode;\n}\n\nfunction KpiCard({ title, value, subtitle, variant = 'info', icon }: KpiCardProps) {\n  const c = KPI_COLORS[variant];\n  return (\n    <div \n      className={`kpi-card kpi-${variant}`}\n      style={{\n        ...card(),\n        display: 'flex',\n        gap: ui.gap,\n        alignItems: 'center',\n        minHeight: 82\n      }}>\n      <div style={{\n        background: c.bg,\n        width: 36,\n        height: 36,\n        minWidth: 36,\n        borderRadius: 10,\n        display: 'grid',\n        placeItems: 'center'\n      }}>\n        {icon || (\n          <svg width={20} height={20} viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n            <circle cx=\"12\" cy=\"12\" r=\"9\" fill={c.accent} opacity={0.9} />\n          </svg>\n        )}\n      </div>\n      <div style={{ flex: 1 }}>\n        <div style={{ color: '#374151', fontSize: 12, fontWeight: 600 }}>{title}</div>\n        <div style={{ display: 'flex', alignItems: 'baseline', gap: 8 }}>\n          <div style={{ color: c.text, fontSize: 26, fontWeight: 700 }}>{value}</div>\n          {subtitle && (\n            <div style={{ color: '#6b7280', fontSize: 12 }}>{subtitle}</div>\n          )}\n        </div>\n      </div>\n      <div style={{ width: 6, alignSelf: 'stretch', borderRadius: 6, background: c.accent, opacity: 0.18 }} />\n    </div>\n  );\n}\n\n// Typer importeras nu från types.ts\n\n/* ---------- Utils ---------- */\nfunction formatDateTime(): string {\n  return new Date().toLocaleString(\"sv-SE\");\n}\n\nfunction compareWeekId(a: WeekId, b: WeekId): number {\n  const [ya, wa] = a.split(\"-W\");\n  const [yb, wb] = b.split(\"-W\");\n  if (ya !== yb) return Number(ya) - Number(yb);\n  return Number(wa) - Number(wb);\n}\n\nfunction compareMonthId(a: MonthId, b: MonthId): number {\n  return a.localeCompare(b);\n}\n\n/* ---------- Lagring ---------- */\nfunction loadState(): AppState | undefined {\n  try {\n    const raw = getStoredData();\n    if (raw) {\n      const state = JSON.parse(raw) as AppState;\n      \n      // MIGRATION: Konvertera gamla Plan-fält till plans[0]\n      state.staff.forEach(staff => {\n        staff.clients.forEach(client => {\n          if (!client.plans) {\n            client.plans = [];\n          }\n          \n          // Om klient har gamla fält men ingen plans[0], skapa en\n          if (client.plan && (client.plan.carePlanDate || client.plan.hasGFP || client.plan.staffNotified || client.plan.notes)) {\n            const hasExistingPlan = client.plans.length > 0;\n            if (!hasExistingPlan) {\n              const legacyPlan: GFPPlan = {\n                id: crypto.randomUUID(),\n                title: 'GFP 1',\n                date: client.plan.carePlanDate || todayYMD(),\n                dueDate: client.plan.carePlanDate ? addDaysISO(client.plan.carePlanDate, 21) : addDaysISO(todayYMD(), 21),\n                note: client.plan.notes || '',\n                staffInformed: client.plan.staffNotified || false,\n                done: client.plan.hasGFP || false,\n                status: client.plan.hasGFP ? 'approved' : 'pending'\n              };\n              client.plans.unshift(legacyPlan); // Lägg först (nyaste)\n            }\n          }\n        });\n      });\n      \n      return state;\n    }\n  } catch (error) {\n    console.warn(\"Failed to load state:\", error);\n  }\n  return undefined;\n}\n\n// SaveBar hanterar nu sparning automatiskt med debounce\n\n/* ---------- Init-data ---------- */\nfunction newClient(name: string): Client {\n  return {\n    id: crypto.randomUUID(),\n    name,\n    plan: { carePlanDate: undefined, hasGFP: false, staffNotified: false, notes: \"\" }, // LEGACY\n    plans: [], // NEW - flera vårdplaner\n    weeklyDocs: {},\n    monthlyReports: {},\n    visma: {},\n    createdAt: todayYMD(),\n  };\n}\n\nfunction initialState(): AppState {\n  return {\n    staff: [\n      { id: crypto.randomUUID(), name: \"Anna\", clients: [] },\n      { id: crypto.randomUUID(), name: \"Johan\", clients: [] },\n    ],\n    selectedStaffId: undefined,\n    selectedClientId: undefined,\n    lastBackup: formatDateTime(),\n    version: \"3.0\",\n  };\n}\n\n/* ---------- Export/Import ---------- */\nfunction exportToFile(state: AppState): void {\n  const data = JSON.stringify(state, null, 2);\n  const blob = new Blob([data], { type: \"application/json\" });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement(\"a\");\n  a.href = url;\n  a.download = `ungdomsstod_export_${todayYMD()}.json`;\n  a.click();\n  URL.revokeObjectURL(url);\n}\n\nfunction exportToClipboard(state: AppState): void {\n  const data = btoa(JSON.stringify(state));\n  if (navigator.clipboard?.writeText) {\n    navigator.clipboard.writeText(data).then(\n      () => alert(\"Data kopierat! Dela med kollega via email/chat.\"),\n      () => fallback()\n    );\n  } else {\n    fallback();\n  }\n  function fallback() {\n    try {\n      const ta = document.createElement(\"textarea\");\n      ta.value = data;\n      document.body.appendChild(ta);\n      ta.select();\n      document.execCommand(\"copy\");\n      document.body.removeChild(ta);\n      alert(\"Data kopierat (fallback).\");\n    } catch {\n      alert(\"Kopiering misslyckades – markera och kopiera manuellt.\");\n    }\n  }\n}\n\n\n/* ---------- UI tokens & helpers ---------- */\n// NEW: Enhanced UI tokens for proper contrast\nconst ui = {\n  gap: 12, \n  radius: 10, \n  pad: 12,\n  border: '#E5E7EB', \n  bg: '#FFFFFF', \n  bgAlt: '#F9FAFB',\n  text: '#111827', \n  textMute: '#6B7280',\n  navHoverBg: '#EEF2FF',\n  navActiveBg: '#E6F0FF',\n  navActiveText: '#0A2540',\n  blue: '#007aff', \n  orange: '#ff9500', \n  red: '#ff3b30',\n  green: '#16a34a',\n  cardBg: '#FFFFFF',\n  sidebarActive: '#e9f2ff'\n};\n\n// Legacy C object för bakåtkompatibilitet under migrering\nconst C = {\n  blue: ui.blue,\n  orange: ui.orange,\n  red: ui.red,\n  green: ui.green,\n  white: ui.bg,\n  border: ui.border,\n  text: ui.text,\n  textLight: ui.textMute,\n  sidebarBg: ui.bg,\n  sidebarActive: ui.sidebarActive\n};\n\n// Style helpers\nfunction card(): React.CSSProperties {\n  return {\n    background: ui.bg,\n    border: `1px solid ${ui.border}`,\n    borderRadius: ui.radius,\n    padding: ui.pad,\n    boxShadow: '0 1px 2px rgba(0,0,0,0.04)'\n  };\n}\n\nfunction row(gap = ui.gap): React.CSSProperties {\n  return {\n    display: 'flex',\n    alignItems: 'center',\n    gap\n  };\n}\n\nfunction col(gap = ui.gap): React.CSSProperties {\n  return {\n    display: 'flex',\n    flexDirection: 'column',\n    gap\n  };\n}\n\nfunction pill(status: 'approved' | 'pending' | 'rejected' | 'late' | 'info'): React.CSSProperties {\n  const colors = {\n    approved: { bg: 'rgba(22,163,74,0.1)', text: ui.green, border: ui.green },\n    pending: { bg: 'rgba(255,149,0,0.1)', text: ui.orange, border: ui.orange },\n    rejected: { bg: 'rgba(255,59,48,0.1)', text: ui.red, border: ui.red },\n    late: { bg: 'rgba(255,59,48,0.1)', text: ui.red, border: ui.red },\n    info: { bg: 'rgba(0,122,255,0.1)', text: ui.blue, border: ui.blue }\n  };\n  \n  const color = colors[status];\n  return {\n    background: color.bg,\n    color: color.text,\n    border: `1px solid ${color.border}`,\n    borderRadius: 6,\n    padding: '2px 8px',\n    fontSize: 11,\n    fontWeight: 600,\n    display: 'inline-block'\n  };\n}\n\n// ★ Base controls (förhindrar svarta fält i dark mode/Safari)\nconst inputBase: React.CSSProperties = {\n  background: '#ffffff',\n  color: C.text,\n  border: `1px solid ${C.border}`,\n  borderRadius: 10,\n  padding: '8px 10px',\n  outline: 'none',\n  boxShadow: '0 1px 1px rgba(0,0,0,0.02)'\n};\n\nconst inputSmall: React.CSSProperties = {\n  ...inputBase,\n  borderRadius: 6,\n  padding: '4px 8px'\n};\n\nconst selectBase: React.CSSProperties = {\n  ...inputSmall,\n  appearance: 'none',\n  WebkitAppearance: 'none',\n  MozAppearance: 'none',\n  backgroundImage:\n    'url(\"data:image/svg+xml;utf8,<svg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'16\\' height=\\'16\\'><path d=\\'M4 6l4 4 4-4\\' stroke=\\'%236b7280\\' stroke-width=\\'2\\' fill=\\'none\\' stroke-linecap=\\'round\\'/></svg>\")',\n  backgroundRepeat: 'no-repeat',\n  backgroundPosition: 'right 8px center',\n  paddingRight: 28\n} as React.CSSProperties;\n\nconst textareaBase: React.CSSProperties = {\n  ...inputBase,\n  minHeight: 80,\n  resize: 'vertical'\n};\n\n// NEW: Helper functions for consistent contrast styling\nconst navItemStyle = (active: boolean): React.CSSProperties => ({\n  padding: '10px 12px',\n  borderRadius: 8,\n  cursor: 'pointer',\n  color: active ? ui.navActiveText : ui.text,\n  background: active ? ui.navActiveBg : 'transparent',\n  fontWeight: active ? 600 : 500,\n  borderLeft: active ? `3px solid ${ui.blue}` : '3px solid transparent',\n  border: 'none',\n  textAlign: 'left',\n  width: '100%',\n  fontSize: 15,\n  letterSpacing: 0.2,\n  transition: 'all 0.15s ease'\n});\n\nconst listItemStyle = (selected: boolean): React.CSSProperties => ({\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'space-between',\n  gap: 12,\n  background: ui.cardBg,\n  border: `1px solid ${ui.border}`,\n  borderRadius: 10,\n  padding: 10,\n  color: ui.text,\n  ...(selected ? { background: ui.navActiveBg, borderColor: ui.blue } : {})\n});\n\nconst nameStyle: React.CSSProperties = { fontWeight: 600, color: ui.text };\nconst metaStyle: React.CSSProperties = { fontSize: 12, color: ui.textMute };\n\nconst app: React.CSSProperties = {\n  display: \"flex\",\n  height: \"100vh\",\n  minWidth: 280,\n  background: \"#f5f7fb\",\n  fontFamily: \"system-ui, -apple-system, sans-serif\"\n};\n\nconst sidebar: React.CSSProperties = {\n  width: 280,\n  minWidth: 240,\n  background: C.sidebarBg,\n  color: C.text,              // 🔥 säkerställ mörk text\n  borderRight: `1px solid ${C.border}`,\n  padding: 16,\n  display: \"flex\",\n  flexDirection: \"column\",\n  gap: 12\n};\n\n// REMOVED: Legacy navItem function replaced by navItemStyle with better contrast\n\nconst main: React.CSSProperties = {\n  flex: 1,\n  padding: 16,\n  paddingBottom: 80, // Utrymme för SaveBar\n  overflow: \"auto\"\n};\n\nconst headerBar: React.CSSProperties = {\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  gap: 10,\n  marginBottom: 14\n};\n\nconst title: React.CSSProperties = { fontSize: 20, fontWeight: 800 };\n\nconst gridTwo: React.CSSProperties = {\n  display: \"grid\",\n  gridTemplateColumns: \"repeat(auto-fit, minmax(320px, 1fr))\",\n  gap: 12,\n  marginBottom: 12\n};\n\nconst gridThree: React.CSSProperties = {\n  display: \"grid\",\n  gridTemplateColumns: \"repeat(auto-fit, minmax(200px, 1fr))\",\n  gap: 12\n};\n\n// Legacy card constant removed - use card() helper instead\n\nconst cardHeader: React.CSSProperties = {\n  ...row(),\n  justifyContent: \"space-between\",\n  marginBottom: 8\n};\n\nconst btn: React.CSSProperties = {\n  padding: \"8px 14px\",\n  borderRadius: 8,\n  border: `1px solid ${C.border}`,\n  background: \"#fff\",\n  fontWeight: 600,\n  cursor: \"pointer\",\n  transition: \"all 0.2s\"\n};\n\nconst primaryBtn: React.CSSProperties = {\n  ...btn,\n  background: C.blue,\n  color: C.white,\n  borderColor: C.blue\n};\n\n// smallBtn style removed - now using PeriodPicker component\n\n/* ---------- Småkomponenter ---------- */\nfunction Sparkline({ points }: { points: number[] }) {\n  if (!points.length) return null;\n  const W = 220;\n  const H = 64;\n  const max = Math.max(...points, 1);\n  const min = Math.min(...points, 0);\n  const range = Math.max(1, max - min);\n  const step = W / Math.max(1, points.length - 1);\n  const d = points\n    .map((v, i) => {\n      const x = i * step;\n      const y = H - ((v - min) / range) * H;\n      return `${i === 0 ? \"M\" : \"L\"}${x.toFixed(1)},${y.toFixed(1)}`;\n    })\n    .join(\" \");\n  return (\n    <svg width={W} height={H} style={{ display: \"block\" }}>\n      <path d={d} fill=\"none\" stroke={C.blue} strokeWidth={2} />\n      <circle cx={W} cy={H - ((points[points.length - 1]! - min) / range) * H} r={3} fill={C.blue} />\n    </svg>\n  );\n}\n\nfunction Donut({ pct }: { pct: number }) {\n  const size = 120;\n  const stroke = 12;\n  const R = (size - stroke) / 2;\n  const CIRC = 2 * Math.PI * R;\n  const off = CIRC * (1 - Math.max(0, Math.min(1, pct)));\n  return (\n    <svg width={size} height={size}>\n      <g transform={`translate(${size / 2},${size / 2})`}>\n        <circle r={R} fill=\"none\" stroke=\"#eef2f7\" strokeWidth={stroke} />\n        <circle\n          r={R}\n          fill=\"none\"\n          stroke={C.blue}\n          strokeWidth={stroke}\n          strokeDasharray={`${CIRC} ${CIRC}`}\n          strokeDashoffset={off}\n          transform=\"rotate(-90)\"\n          strokeLinecap=\"round\"\n        />\n        <text y=\"6\" textAnchor=\"middle\" fontWeight=\"800\" fontSize=\"20\">\n          {Math.round(pct * 100)}%\n        </text>\n      </g>\n    </svg>\n  );\n}\n\n\n/* ---------- Views ---------- */\nfunction Overview({ state, kpis }: { state: AppState; kpis: Record<string, number> }) {\n    const overviewSamples = useMemo(() => {\n    const weeklyByWeek: Record<string, number> = {};\n    const currentWeekId = getCurrentWeek();\n    \n    // Get history for past weeks (including archived clients)\n    const history = loadHistory();\n    const pastWeeks = history\n      .filter(h => h.periodType === 'week' && h.metric === 'weekDoc' && compareWeekId(h.periodId, currentWeekId) < 0)\n      .filter(h => h.status === 'approved');\n    \n    // Aggregate from history\n    pastWeeks.forEach(entry => {\n      weeklyByWeek[entry.periodId] = (weeklyByWeek[entry.periodId] || 0) + 1;\n    });\n    \n    // Add current week data from active clients only\n    state.staff.forEach(st => {\n      st.clients.forEach(c => {\n        // Skip archived and soft-deleted clients for current week\n        if (c.archivedAt || c.deletedAt) return;\n        \n        Object.entries(c.weeklyDocs).forEach(([weekId, doc]) => {\n          if (doc.status === \"approved\" && compareWeekId(weekId, currentWeekId) >= 0) {\n            weeklyByWeek[weekId] = (weeklyByWeek[weekId] || 0) + 1;\n          }\n        });\n      });\n    });\n\n    const sortedWeeks = Object.keys(weeklyByWeek).sort(compareWeekId).slice(-8);\n    const series = sortedWeeks.map(w => weeklyByWeek[w] || 0);\n\n    // Calculate total and approved docs from history + current active clients\n    const currentWeekForDocs = getCurrentWeek();\n    const currentMonthForDocs = getCurrentMonth();\n    \n    // Get all history entries\n    const allHistory = loadHistory();\n    \n    // Count total docs from history (past periods) + current active clients\n    const totalDocs = allHistory.length + state.staff.reduce(\n      (sum, st) =>\n        sum +\n        st.clients.reduce(\n          (cSum, c) => {\n            // Skip archived and soft-deleted clients\n            if (c.archivedAt || c.deletedAt) return cSum;\n            // Only count current period docs from active clients\n            let count = 0;\n            Object.entries(c.weeklyDocs).forEach(([weekId]) => {\n              if (compareWeekId(weekId, currentWeekForDocs) >= 0) count++;\n            });\n            Object.entries(c.monthlyReports).forEach(([monthId]) => {\n              if (compareMonthId(monthId, currentMonthForDocs) >= 0) count++;\n            });\n            return cSum + count;\n          },\n          0\n        ),\n      0\n    );\n\n    // Count approved docs from history + current active clients\n    const approvedFromHistory = allHistory.filter(h => h.status === 'approved').length;\n    const approvedFromCurrent = state.staff.reduce(\n      (sum, st) =>\n        sum +\n        st.clients.reduce(\n          (cSum, c) => {\n            // Skip archived and soft-deleted clients\n            if (c.archivedAt || c.deletedAt) return cSum;\n            let count = 0;\n            Object.values(c.weeklyDocs).forEach(doc => {\n              if (doc.status === \"approved\" && compareWeekId(doc.weekId, currentWeekForDocs) >= 0) count++;\n            });\n            Object.values(c.monthlyReports).forEach(report => {\n              if (report.status === \"approved\" && compareMonthId(report.monthId, currentMonthForDocs) >= 0) count++;\n            });\n            return cSum + count;\n          },\n          0\n        ),\n      0\n    );\n    \n    const approvedDocs = approvedFromHistory + approvedFromCurrent;\n\n    const quality = totalDocs ? approvedDocs / totalDocs : 0;\n\n    return {\n      series: series.length ? series : [0],\n      quality\n    };\n  }, [state.staff]);\n\n  // PRINT NEW: Print function for dashboard\n  const handlePrint = () => {\n    window.print();\n  };\n\n  return (\n    <div data-print-scope=\"personal-dashboard\">\n      <div style={headerBar}>\n        <div style={title}>Vårdadmin – Dashboard</div>\n        {/* PRINT NEW: Print button */}\n        <button\n          onClick={handlePrint}\n          data-print-keep\n          style={{\n            background: '#007aff',\n            color: '#ffffff',\n            border: '1px solid #007aff',\n            borderRadius: 8,\n            padding: '8px 16px',\n            fontSize: 14,\n            fontWeight: 600,\n            cursor: 'pointer',\n            transition: 'all 0.15s ease'\n          }}\n          onMouseOver={(e) => {\n            e.currentTarget.style.background = '#0051d5';\n            e.currentTarget.style.borderColor = '#0051d5';\n          }}\n          onMouseOut={(e) => {\n            e.currentTarget.style.background = '#007aff';\n            e.currentTarget.style.borderColor = '#007aff';\n          }}\n        >\n          🖨️ Skriv ut\n        </button>\n      </div>\n\n      <div style={gridTwo}>\n        <div style={card()}>\n          <div style={cardHeader}>\n            <div style={{ fontWeight: 800 }}>Vårdplaner - Status</div>\n          </div>\n          <div style={{ display: \"grid\", gridTemplateColumns: \"1fr 1fr\", gap: 10 }}>\n            <div>\n              <div style={{ fontSize: 24, fontWeight: 900, color: C.green }}>{kpis.totalPlansActive}</div>\n              <div style={{ fontSize: 12, color: C.textLight }}>Aktiva med GFP</div>\n            </div>\n            <div>\n              <div style={{ fontSize: 24, fontWeight: 900, color: C.orange }}>{kpis.waitingPlan}</div>\n              <div style={{ fontSize: 12, color: C.textLight }}>Inväntar</div>\n            </div>\n          </div>\n        </div>\n\n        <div style={card()}>\n          <div style={cardHeader}>\n            <div style={{ fontWeight: 800 }}>Veckodokumentation</div>\n          </div>\n          <div style={{ display: \"grid\", gridTemplateColumns: \"1fr auto\", gap: 10, alignItems: \"center\" }}>\n            <div>\n              <div style={{ fontSize: 13, color: C.textLight, marginBottom: 6 }}>Godkända per vecka</div>\n              <Sparkline points={overviewSamples.series} />\n              <div style={{ fontSize: 11, color: C.textLight, marginTop: 4, fontStyle: 'italic' }}>\n                Historik inkluderar arkiverade klienter\n              </div>\n            </div>\n            <Donut pct={overviewSamples.quality} />\n          </div>\n        </div>\n      </div>\n\n      <div style={gridThree} className=\"kpi-grid\">\n        <KpiCard title=\"Försenad plan\" value={kpis.delayedPlan ?? 0} subtitle=\"GFP över 21 dagar\" variant=\"late\" />\n        <KpiCard title=\"Försenad dokumentation\" value={kpis.delayedDocs ?? 0} subtitle=\"Ej godkända veckor\" variant=\"waiting\" />\n        <KpiCard title=\"Denna vecka\" value={kpis.completedThisWeek ?? 0} subtitle=\"Godkända dokument\" variant=\"success\" />\n        <KpiCard title=\"Totalt klienter\" value={kpis.totalClients ?? 0} subtitle={`${state.staff.length} personal`} variant=\"neutral\" />\n        <KpiCard title=\"Försenad månadsrapport\" value={kpis.delayedMonthly ?? 0} variant=\"info\" />\n        <KpiCard title=\"Försenad Visma-tid\" value={kpis.delayedVisma ?? 0} variant=\"info\" />\n      </div>\n\n      {/* Tuesday Attendance Group Widget */}\n      <GroupAttendanceWidget />\n    </div>\n  );\n}\n\nfunction StaffView({ state, setState, selectedStaff, setView }: { \n  state: AppState; \n  setState: (fn: (prev: AppState) => AppState) => void; \n  selectedStaff: Staff | undefined; \n  setView: (view: View) => void; \n}) {\n  const [newStaffName, setNewStaffName] = useState(\"\");\n  const [newClientName, setNewClientName] = useState(\"\");\n  const [staffQuery, setStaffQuery] = useState(\"\");\n  \n  // NEW: Confirm dialog state\n  const [confirmDialog, setConfirmDialog] = useState<{\n    open: boolean;\n    title: string;\n    description: string;\n    impactSummary?: string;\n    onConfirm: () => void;\n  }>({\n    open: false,\n    title: '',\n    description: '',\n    impactSummary: undefined,\n    onConfirm: () => {}\n  });\n\n  function addStaff(name: string) {\n    if (!name.trim()) return;\n    setState((p: AppState) => ({\n      ...p,\n      staff: [...p.staff, { id: crypto.randomUUID(), name: name.trim(), clients: [] }]\n    }));\n  }\n\n  function removeStaff(id: string) {\n    setState((prev: AppState) => {\n      const nextStaff = prev.staff.filter(s => s.id !== id);\n      const nextSelectedStaffId = prev.selectedStaffId === id ? undefined : prev.selectedStaffId;\n      return { ...prev, staff: nextStaff, selectedStaffId: nextSelectedStaffId, selectedClientId: undefined };\n    });\n  }\n\n  // NEW: Show confirm dialog for staff deletion with impact summary\n  function showDeleteStaffConfirm(staff: Staff) {\n    const counts = countStaffData(staff);\n    const impactSummary = counts.clients > 0 \n      ? `Tar bort ${counts.clients} klienter, ${counts.totalPlans} planer, ${counts.totalWeeks} veckor, ${counts.totalMonths} månadsrapporter`\n      : 'Ingen data att ta bort';\n    \n    setConfirmDialog({\n      open: true,\n      title: \"Ta bort personal\",\n      description: `Är du säker på att du vill ta bort ${staff.name}? Detta går inte att ångra.`,\n      impactSummary,\n      onConfirm: () => {\n        removeStaff(staff.id);\n        setConfirmDialog(prev => ({ ...prev, open: false }));\n      }\n    });\n  }\n\n  function addClientToSelected(name: string) {\n    if (!selectedStaff || !name.trim()) return;\n    setState((prev: AppState) => ({\n      ...prev,\n      staff: prev.staff.map(s =>\n        s.id === selectedStaff.id ? { ...s, clients: [...s.clients, newClient(name.trim())] } : s\n      )\n    }));\n  }\n\n  function softDeleteClient(clientId: string) {\n    if (!selectedStaff) return;\n    setState((prev: AppState) => ({\n      ...prev,\n      staff: prev.staff.map(s =>\n        s.id === selectedStaff.id ? { \n          ...s, \n          clients: s.clients.map(c => \n            c.id === clientId \n              ? { ...c, deletedAt: new Date().toISOString() }\n              : c\n          )\n        } : s\n      ),\n      selectedClientId: prev.selectedClientId === clientId ? undefined : prev.selectedClientId\n    }));\n  }\n\n  // Helper function for restoring soft-deleted clients (used in ArchiveView)\n  // function restoreClient(clientId: string) {\n  //   if (!selectedStaff) return;\n  //   setState((prev: AppState) => ({\n  //     ...prev,\n  //     staff: prev.staff.map(s =>\n  //       s.id === selectedStaff.id ? { \n  //         ...s, \n  //         clients: s.clients.map(c => \n  //           c.id === clientId \n  //             ? { ...c, deletedAt: undefined }\n  //             : c\n  //         )\n  //       } : s\n  //     )\n  //   }));\n  // }\n\n\n  // NEW: Show confirm dialog for client soft deletion with impact summary\n  function showDeleteClientConfirm(client: Client) {\n    const counts = countClientData(client);\n    const impactSummary = counts.plans > 0 || counts.weeks > 0 || counts.months > 0\n      ? `Mjuk-raderar ${counts.plans} planer, ${counts.weeks} veckor, ${counts.months} månadsrapporter (bevaras för historik)`\n      : 'Ingen data att radera';\n    \n    setConfirmDialog({\n      open: true,\n      title: \"Ta bort klient\",\n      description: `Är du säker på att du vill ta bort ${client.name}? Klienten försvinner från aktiva listor men all historik bevaras.`,\n      impactSummary,\n      onConfirm: () => {\n        softDeleteClient(client.id);\n        setConfirmDialog(prev => ({ ...prev, open: false }));\n      }\n    });\n  }\n\n  const filtered = state.staff.filter((s: Staff) => s.name.toLowerCase().includes(staffQuery.toLowerCase()));\n\n  return (\n    <div>\n      <div style={headerBar}>\n        <div style={title}>Personal & Klienter</div>\n      </div>\n\n      <div style={{ display: \"grid\", gridTemplateColumns: \"minmax(260px, 340px) 1fr\", gap: 12 }}>\n        <div style={card()}>\n          <div style={cardHeader}>\n            <div style={{ fontWeight: 800 }}>Personal ({state.staff.length})</div>\n          </div>\n\n          <input\n            placeholder=\"Sök personal…\"\n            value={staffQuery}\n            onChange={e => setStaffQuery(e.target.value)}\n            style={{ ...inputBase, width: '100%', marginBottom: 8 }}\n          />\n\n          <div style={{ display: \"flex\", gap: 6, marginBottom: 8 }}>\n            <input\n              placeholder=\"Namn på ny personal\"\n              value={newStaffName}\n              onChange={e => setNewStaffName(e.target.value)}\n              style={{ ...inputBase, flex: 1 }}\n            />\n            <button style={primaryBtn} onClick={() => { addStaff(newStaffName); setNewStaffName(\"\"); }}>\n              Lägg till\n            </button>\n          </div>\n\n          <div style={{ ...col(6), maxHeight: 400, overflow: \"auto\" }}>\n            {/* NEW: Updated staff list with proper contrast */}\n            {filtered.map((s: Staff) => (\n              <div\n                key={s.id}\n                style={listItemStyle(state.selectedStaffId === s.id)}\n                onMouseEnter={(e) => {\n                  if (state.selectedStaffId !== s.id) {\n                    e.currentTarget.style.background = ui.navHoverBg;\n                  }\n                }}\n                onMouseLeave={(e) => {\n                  if (state.selectedStaffId !== s.id) {\n                    e.currentTarget.style.background = ui.cardBg;\n                  }\n                }}\n              >\n                <button\n                  style={{ \n                    flex: 1, \n                    textAlign: \"left\", \n                    border: \"none\", \n                    background: \"transparent\", \n                    padding: 0,\n                    cursor: 'pointer',\n                    color: ui.text\n                  }}\n                  onClick={() =>\n                    setState((prev: AppState) => ({ ...prev, selectedStaffId: s.id, selectedClientId: undefined }))\n                  }\n                  onFocus={(e) => {\n                    e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n                    e.currentTarget.style.outlineOffset = '2px';\n                  }}\n                  onBlur={(e) => {\n                    e.currentTarget.style.outline = 'none';\n                  }}\n                >\n                  <div style={nameStyle}>{s.name}</div>\n                  <div style={metaStyle}>{s.clients.filter(c => !c.archivedAt && !c.deletedAt).length} klienter</div>\n                </button>\n                <button \n                  style={{ ...primaryBtn, fontSize: 12, padding: \"4px 8px\" }} \n                  onClick={() => { \n                    setState((prev: AppState) => ({ ...prev, selectedStaffId: s.id, selectedClientId: undefined })); \n                    setView(\"staffDetail\"); \n                  }}\n                >\n                  Dashboard\n                </button>\n                <button style={{ ...btn, fontSize: 12, padding: \"4px 8px\" }} onClick={() => showDeleteStaffConfirm(s)}>\n                  Ta bort\n                </button>\n              </div>\n            ))}\n          </div>\n        </div>\n\n        <div style={card()}>\n          <div style={cardHeader}>\n            <div style={{ fontWeight: 800 }}>\n              Klienter {selectedStaff ? `– ${selectedStaff.name}` : \"\"}\n            </div>\n          </div>\n          {!selectedStaff ? (\n            <div style={{ color: C.textLight }}>Välj en personal till vänster.</div>\n          ) : (\n            <>\n              <div style={{ display: \"flex\", gap: 6, marginBottom: 8 }}>\n                <input\n                  placeholder=\"Klient initialer (t.ex. AB)\"\n                  value={newClientName}\n                  onChange={e => setNewClientName(e.target.value)}\n                  style={{ ...inputBase, flex: 1 }}\n                />\n                <button style={primaryBtn} onClick={() => { addClientToSelected(newClientName); setNewClientName(\"\"); }}>\n                  Lägg till\n                </button>\n              </div>\n\n              <div style={{ ...col(6), maxHeight: 450, overflow: \"auto\" }}>\n                {/* NEW: Updated client list with proper contrast - only show active clients */}\n                {selectedStaff.clients.filter(c => !c.archivedAt && !c.deletedAt).map((c: Client) => (\n                  <div\n                    key={c.id}\n                    style={{\n                      ...listItemStyle(state.selectedClientId === c.id),\n                      display: \"grid\",\n                      gridTemplateColumns: \"1fr auto auto\",\n                      gap: 6,\n                      alignItems: \"center\"\n                    }}\n                    onMouseEnter={(e) => {\n                      if (state.selectedClientId !== c.id) {\n                        e.currentTarget.style.background = ui.navHoverBg;\n                      }\n                    }}\n                    onMouseLeave={(e) => {\n                      if (state.selectedClientId !== c.id) {\n                        e.currentTarget.style.background = ui.cardBg;\n                      }\n                    }}\n                  >\n                    <button\n                      style={{ \n                        textAlign: \"left\", \n                        border: \"none\", \n                        background: \"transparent\", \n                        padding: 0,\n                        cursor: 'pointer',\n                        color: ui.text\n                      }}\n                      onClick={() => setState((prev: AppState) => ({ ...prev, selectedClientId: c.id }))}\n                      onFocus={(e) => {\n                        e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n                        e.currentTarget.style.outlineOffset = '2px';\n                      }}\n                      onBlur={(e) => {\n                        e.currentTarget.style.outline = 'none';\n                      }}\n                    >\n                      <div style={nameStyle}>{c.name}</div>\n                      <div style={metaStyle}>\n                        Planer: {c.plans.length} • Senaste: {latestPlan(c.plans)?.title || \"Ingen\"}\n                      </div>\n                    </button>\n                    <button style={primaryBtn} onClick={() => { setState((prev: AppState) => ({ ...prev, selectedClientId: c.id })); setView(\"client\"); }}>\n                      Öppna\n                    </button>\n                    <button style={{ ...btn, fontSize: 12 }} onClick={() => showDeleteClientConfirm(c)}>\n                      Ta bort\n                    </button>\n                  </div>\n                ))}\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n      \n      {/* NEW: Confirm dialog */}\n      <ConfirmDialog\n        open={confirmDialog.open}\n        title={confirmDialog.title}\n        description={confirmDialog.description}\n        impactSummary={confirmDialog.impactSummary}\n        onConfirm={confirmDialog.onConfirm}\n        onCancel={() => setConfirmDialog(prev => ({ ...prev, open: false }))}\n      />\n    </div>\n  );\n}\n\n/* ---------- ClientWork Section Content Components ---------- */\n\n// Veckodokumentation innehåll\nfunction WeeklyDocContent({ weeklyDoc, saveWeeklyDoc, weekIdInput, clientId }: {\n  weeklyDoc: WeeklyDoc;\n  saveWeeklyDoc: (weekId: WeekId, doc: WeeklyDoc) => void;\n  weekIdInput: WeekId;\n  clientId: string;\n}) {\n  const [note, setNote] = useState(weeklyDoc.note || '');\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle');\n  const [lastSaved, setLastSaved] = useState<string>('');\n  \n  // NEW: Debounced save with period-based storage\n  const debouncedSave = useRef(debounceNote((noteValue: string) => {\n    const updatedDoc = { ...weeklyDoc, note: noteValue };\n    savePeriodData(clientId, 'weekly', weekIdInput, updatedDoc);\n    setSaveStatus('saved');\n    setLastSaved(new Date().toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' }));\n  }, 500));\n\n  // NEW: Load data when period changes (ensures isolation)\n  useEffect(() => {\n    const defaultDoc: WeeklyDoc = {\n      weekId: weekIdInput,\n      days: { mon: false, tue: false, wed: false, thu: false, fri: false, sat: false, sun: false },\n      status: \"pending\",\n      note: ''\n    };\n    \n    const loadedDoc = loadPeriodData(clientId, 'weekly', weekIdInput, defaultDoc);\n    setNote(loadedDoc.note || '');\n    setSaveStatus('idle');\n    setLastSaved('');\n    \n    // Update the parent component with loaded data\n    if (JSON.stringify(loadedDoc) !== JSON.stringify(weeklyDoc)) {\n      saveWeeklyDoc(weekIdInput, loadedDoc);\n    }\n  }, [weekIdInput, clientId, weeklyDoc, saveWeeklyDoc]); // NEW: Re-load when period or client changes\n\n  const handleDayChange = (day: string, checked: boolean) => {\n    const newDoc = { \n      ...weeklyDoc, \n      days: { ...weeklyDoc.days, [day]: checked },\n      lastUpdated: new Date().toISOString()\n    };\n    saveWeeklyDoc(weekIdInput, newDoc);\n    // NEW: Also save to period-based storage\n    savePeriodData(clientId, 'weekly', weekIdInput, newDoc);\n  };\n\n  const handleNoteChange = (value: string) => {\n    setNote(value);\n    setSaveStatus('saving');\n    // NEW: Update weeklyDoc object with new note\n    const updatedDoc = { ...weeklyDoc, note: value };\n    saveWeeklyDoc(weekIdInput, updatedDoc);\n    debouncedSave.current(value);\n  };\n\n  const handleNoteBlur = () => {\n    const updatedDoc = { ...weeklyDoc, note: note };\n    savePeriodData(clientId, 'weekly', weekIdInput, updatedDoc);\n    setSaveStatus('saved');\n    setLastSaved(new Date().toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' }));\n  };\n\n  return (\n    <>\n      <DayMatrix\n        days={weeklyDoc.days}\n        weekId={weekIdInput}\n        onChange={handleDayChange}\n        type=\"weekly\"\n      />\n      \n      <div style={{ ...row(8), flexWrap: \"wrap\" }}>\n        <div style={{ fontSize: 12, fontWeight: 600 }}>Status:</div>\n        <select\n          value={weeklyDoc.status}\n          onChange={(e) => saveWeeklyDoc(weekIdInput, { ...weeklyDoc, status: e.target.value as DocStatus })}\n          style={selectBase}\n          aria-label=\"Veckodokumentation status\"\n        >\n          {/* UPDATED: Use STATUS_LABEL for all option labels */}\n          <option value=\"pending\">{STATUS_LABEL.pending}</option>\n          <option value=\"approved\">{STATUS_LABEL.approved}</option>\n          <option value=\"rejected\">{STATUS_LABEL.rejected}</option>\n        </select>\n      </div>\n\n      {/* NEW: Note section */}\n      <div style={{ marginTop: 12 }}>\n        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 6 }}>\n          <div style={{ fontSize: 12, fontWeight: 600 }}>Notis för veckan</div>\n          <div style={{ fontSize: 11, color: ui.textMute }}>\n            {saveStatus === 'saving' && 'Sparar...'}\n            {saveStatus === 'saved' && lastSaved && `Sparat ${lastSaved}`}\n          </div>\n        </div>\n        <textarea\n          value={note}\n          onChange={(e) => handleNoteChange(e.target.value)}\n          onBlur={handleNoteBlur}\n          placeholder=\"Kort notis för veckan…\"\n          style={{\n            ...textareaBase,\n            height: 64,\n            fontSize: 14,\n            borderRadius: 8,\n            border: '1px solid #E5E7EB',\n            background: '#ffffff',\n            color: '#111111'\n          }}\n          aria-label=\"Veckodokumentation notis\"\n        />\n      </div>\n    </>\n  );\n}\n\nfunction WeeklyDocSection({ weeklyDoc, saveWeeklyDoc, weekIdInput, setWeekIdInput, clientId }: {\n  weeklyDoc: WeeklyDoc;\n  saveWeeklyDoc: (weekId: WeekId, doc: WeeklyDoc) => void;\n  weekIdInput: WeekId;\n  setWeekIdInput: (weekId: WeekId) => void;\n  clientId: string;\n}) {\n  const headerActions = (\n    <PeriodPicker\n      type=\"week\"\n      value={weekIdInput}\n      onChange={setWeekIdInput}\n    />\n  );\n  \n  return (\n    <Card\n      title=\"Veckodokumentation\"\n      status={weeklyDoc.status}\n      headerActions={headerActions}\n    >\n      <WeeklyDocContent \n        weeklyDoc={weeklyDoc}\n        saveWeeklyDoc={saveWeeklyDoc}\n        weekIdInput={weekIdInput}\n        clientId={clientId}\n      />\n    </Card>\n  );\n}\n\n// Månadsrapport innehåll\nfunction MonthlyReportContent({ monthlyReport, saveMonthlyReport, monthIdInput, clientId }: {\n  monthlyReport: MonthlyReport;\n  saveMonthlyReport: (monthId: MonthId, report: MonthlyReport) => void;\n  monthIdInput: MonthId;\n  clientId: string;\n}) {\n  const [note, setNote] = useState(monthlyReport.note || '');\n  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle');\n  const [lastSaved, setLastSaved] = useState<string>('');\n  \n  // NEW: Debounced save with period-based storage\n  const debouncedSave = useRef(debounceNote((noteValue: string) => {\n    const updatedReport = { ...monthlyReport, note: noteValue };\n    savePeriodData(clientId, 'monthly', monthIdInput, updatedReport);\n    setSaveStatus('saved');\n    setLastSaved(new Date().toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' }));\n  }, 500));\n\n  // NEW: Load data when period changes (ensures isolation)\n  useEffect(() => {\n    const defaultReport: MonthlyReport = {\n      monthId: monthIdInput,\n      sent: false,\n      status: \"pending\",\n      note: ''\n    };\n    \n    const loadedReport = loadPeriodData(clientId, 'monthly', monthIdInput, defaultReport);\n    setNote(loadedReport.note || '');\n    setSaveStatus('idle');\n    setLastSaved('');\n    \n    // Update the parent component with loaded data\n    if (JSON.stringify(loadedReport) !== JSON.stringify(monthlyReport)) {\n      saveMonthlyReport(monthIdInput, loadedReport);\n    }\n  }, [monthIdInput, clientId, monthlyReport, saveMonthlyReport]); // NEW: Re-load when period or client changes\n\n  const handleNoteChange = (value: string) => {\n    setNote(value);\n    setSaveStatus('saving');\n    // NEW: Update monthlyReport object with new note\n    const updatedReport = { ...monthlyReport, note: value };\n    saveMonthlyReport(monthIdInput, updatedReport);\n    debouncedSave.current(value);\n  };\n\n  const handleNoteBlur = () => {\n    const updatedReport = { ...monthlyReport, note: note };\n    savePeriodData(clientId, 'monthly', monthIdInput, updatedReport);\n    setSaveStatus('saved');\n    setLastSaved(new Date().toLocaleTimeString('sv-SE', { hour: '2-digit', minute: '2-digit' }));\n  };\n\n  return (\n    <>\n      <div style={{ ...row(12), flexWrap: \"wrap\" }}>\n        <label style={{ ...row(8) }}>\n          <input\n            type=\"checkbox\"\n            checked={monthlyReport.sent}\n            onChange={(e) => saveMonthlyReport(monthIdInput, { ...monthlyReport, sent: e.target.checked })}\n          />\n          Skickad\n        </label>\n        <div style={{ display: \"flex\", gap: 8, alignItems: \"center\" }}>\n          <div style={{ fontSize: 12, fontWeight: 600 }}>Status:</div>\n          <select\n            value={monthlyReport.status}\n            onChange={(e) => saveMonthlyReport(monthIdInput, { ...monthlyReport, status: e.target.value as DocStatus })}\n            style={selectBase}\n            aria-label=\"Månadsrapport status\"\n          >\n            {/* UPDATED: Use STATUS_LABEL for all option labels */}\n            <option value=\"pending\">{STATUS_LABEL.pending}</option>\n            <option value=\"approved\">{STATUS_LABEL.approved}</option>\n            <option value=\"rejected\">{STATUS_LABEL.rejected}</option>\n          </select>\n        </div>\n      </div>\n\n      {/* NEW: Note section */}\n      <div style={{ marginTop: 12 }}>\n        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 6 }}>\n          <div style={{ fontSize: 12, fontWeight: 600 }}>Notis för månaden</div>\n          <div style={{ fontSize: 11, color: ui.textMute }}>\n            {saveStatus === 'saving' && 'Sparar...'}\n            {saveStatus === 'saved' && lastSaved && `Sparat ${lastSaved}`}\n          </div>\n        </div>\n        <textarea\n          value={note}\n          onChange={(e) => handleNoteChange(e.target.value)}\n          onBlur={handleNoteBlur}\n          placeholder=\"Kort notis för månaden…\"\n          style={{\n            ...textareaBase,\n            height: 64,\n            fontSize: 14,\n            borderRadius: 8,\n            border: '1px solid #E5E7EB',\n            background: '#ffffff',\n            color: '#111111'\n          }}\n          aria-label=\"Månadsrapport notis\"\n        />\n      </div>\n    </>\n  );\n}\n\nfunction MonthlyReportSection({ monthlyReport, saveMonthlyReport, monthIdInput, setMonthIdInput, clientId }: {\n  monthlyReport: MonthlyReport;\n  saveMonthlyReport: (monthId: MonthId, report: MonthlyReport) => void;\n  monthIdInput: MonthId;\n  setMonthIdInput: (monthId: MonthId) => void;\n  clientId: string;\n}) {\n  const headerActions = (\n    <PeriodPicker\n      type=\"month\"\n      value={monthIdInput}\n      onChange={setMonthIdInput}\n    />\n  );\n  \n  return (\n    <Card\n      title=\"Månadsrapport\"\n      status={monthlyReport.status}\n      headerActions={headerActions}\n    >\n      <MonthlyReportContent \n        monthlyReport={monthlyReport}\n        saveMonthlyReport={saveMonthlyReport}\n        monthIdInput={monthIdInput}\n        clientId={clientId}\n      />\n    </Card>\n  );\n}\n\n// Visma innehåll\nfunction VismaContent({ vismaWeek, saveVisma, weekIdInput }: {\n  vismaWeek: VismaWeek;\n  saveVisma: (weekId: WeekId, visma: VismaWeek) => void;\n  weekIdInput: WeekId;\n}) {\n  const handleDayChange = (day: string, checked: boolean) => {\n    const newVisma = { \n      ...vismaWeek, \n      days: { ...vismaWeek.days, [day]: checked },\n      lastUpdated: new Date().toISOString()\n    };\n    saveVisma(weekIdInput, newVisma);\n  };\n\n  return (\n    <>\n      <DayMatrix\n        days={vismaWeek.days}\n        weekId={weekIdInput}\n        onChange={handleDayChange}\n        type=\"visma\"\n      />\n      \n      <div style={{ ...row(8), flexWrap: \"wrap\" }}>\n        <div style={{ fontSize: 12, fontWeight: 600 }}>Status:</div>\n        <select\n          value={vismaWeek.status}\n          onChange={(e) => saveVisma(weekIdInput, { ...vismaWeek, status: e.target.value as DocStatus })}\n          style={selectBase}\n          aria-label=\"Visma tid status\"\n        >\n          {/* UPDATED: Use STATUS_LABEL for all option labels */}\n          <option value=\"pending\">{STATUS_LABEL.pending}</option>\n          <option value=\"approved\">{STATUS_LABEL.approved}</option>\n          <option value=\"rejected\">{STATUS_LABEL.rejected}</option>\n        </select>\n      </div>\n    </>\n  );\n}\n\nfunction VismaSection({ vismaWeek, saveVisma, weekIdInput, setWeekIdInput }: {\n  vismaWeek: VismaWeek;\n  saveVisma: (weekId: WeekId, visma: VismaWeek) => void;\n  weekIdInput: WeekId;\n  setWeekIdInput: (weekId: WeekId) => void;\n}) {\n  const headerActions = (\n    <PeriodPicker\n      type=\"week\"\n      value={weekIdInput}\n      onChange={setWeekIdInput}\n    />\n  );\n  \n  return (\n    <Card\n      title=\"Visma Tid\"\n      status={vismaWeek.status}\n      headerActions={headerActions}\n    >\n      <VismaContent \n        vismaWeek={vismaWeek}\n        saveVisma={saveVisma}\n        weekIdInput={weekIdInput}\n      />\n    </Card>\n  );\n}\n\n// Plan innehåll - Uppdaterad för flera GFP-planer\nfunction PlanContent({ selectedClient, savePlan, addNewPlan, showDeletePlanConfirm }: {\n  selectedClient: Client;\n  savePlan: (updates: Partial<Plan> | { plans: GFPPlan[] }) => void;\n  addNewPlan: () => void;\n  showDeletePlanConfirm: (plan: GFPPlan) => void;\n}) {\n  const [selectedPlanIndex, setSelectedPlanIndex] = useState(0);\n  \n  // Filter out soft-deleted plans\n  const activePlans = selectedClient.plans.filter(p => !p.deletedAt);\n  const currentPlan = activePlans[selectedPlanIndex];\n  \n  const saveCurrentPlan = (updates: Partial<GFPPlan>) => {\n    if (!currentPlan) return;\n    \n    const updatedPlans = [...selectedClient.plans];\n    updatedPlans[selectedPlanIndex] = { ...currentPlan, ...updates };\n    \n    // Uppdatera genom savePlan (som kommer att hantera state-uppdatering)\n    savePlan({ plans: updatedPlans });\n  };\n\n  return (\n    <div>\n      {/* Flikar/Chips för planer + Ny plan-knapp */}\n      <div style={{ ...row(8), marginBottom: 16, flexWrap: \"wrap\" }}>\n        {activePlans.map((plan, index) => (\n          <div key={plan.id} style={{ display: 'flex', alignItems: 'center', gap: 4 }}>\n            <button\n              onClick={() => setSelectedPlanIndex(index)}\n              style={{\n                background: selectedPlanIndex === index ? ui.blue : ui.bgAlt,\n                color: selectedPlanIndex === index ? '#ffffff' : ui.text,\n                border: `1px solid ${selectedPlanIndex === index ? ui.blue : ui.border}`,\n                borderRadius: 8,\n                padding: '6px 12px',\n                fontSize: 12,\n                fontWeight: 600,\n                cursor: 'pointer',\n                transition: 'all 0.15s ease'\n              }}\n            >\n              {plan.title}\n            </button>\n            {/* NEW: Delete plan button */}\n            {activePlans.length > 1 && (\n              <button\n                onClick={() => showDeletePlanConfirm(plan)}\n                style={{\n                  background: '#fee2e2',\n                  color: '#dc2626',\n                  border: '1px solid #fecaca',\n                  borderRadius: 6,\n                  padding: '4px 6px',\n                  fontSize: 10,\n                  fontWeight: 600,\n                  cursor: 'pointer',\n                  transition: 'all 0.15s ease',\n                  minWidth: 20,\n                  height: 20,\n                  display: 'flex',\n                  alignItems: 'center',\n                  justifyContent: 'center'\n                }}\n                onMouseOver={(e) => {\n                  e.currentTarget.style.background = '#fecaca';\n                  e.currentTarget.style.borderColor = '#fca5a5';\n                }}\n                onMouseOut={(e) => {\n                  e.currentTarget.style.background = '#fee2e2';\n                  e.currentTarget.style.borderColor = '#fecaca';\n                }}\n                title={`Ta bort ${plan.title}`}\n                aria-label={`Ta bort ${plan.title}`}\n              >\n                ×\n              </button>\n            )}\n          </div>\n        ))}\n        <button\n          onClick={addNewPlan}\n          style={{\n            background: ui.green,\n            color: '#ffffff',\n            border: `1px solid ${ui.green}`,\n            borderRadius: 8,\n            padding: '6px 12px',\n            fontSize: 12,\n            fontWeight: 600,\n            cursor: 'pointer',\n            transition: 'all 0.15s ease'\n          }}\n        >\n          + Ny plan\n        </button>\n      </div>\n\n      {/* Innehåll för vald plan */}\n      {currentPlan ? (\n        <div style={{ display: \"grid\", gridTemplateColumns: \"repeat(auto-fit, minmax(200px, 1fr))\", gap: 10, alignItems: \"start\" }}>\n          <div>\n            <div style={{ fontSize: 12, fontWeight: 700, opacity: 0.7, marginBottom: 4 }}>Datum (vårdplan)</div>\n            <input\n              type=\"date\"\n              value={currentPlan.date}\n              onChange={(e) => saveCurrentPlan({ date: e.target.value, dueDate: addDaysISO(e.target.value, 21) })}\n              style={inputBase}\n              aria-label=\"Vårdplan datum\"\n            />\n          </div>\n          \n          <div>\n            <div style={{ fontSize: 12, fontWeight: 700, opacity: 0.7, marginBottom: 4 }}>Förfallodatum</div>\n            <div style={{ ...pill(currentPlan.done ? 'approved' : (todayYMD() > currentPlan.dueDate ? 'rejected' : 'pending')), fontWeight: 700 }}>\n              {currentPlan.dueDate}\n            </div>\n            {todayYMD() > currentPlan.dueDate && !currentPlan.done && (\n              <div style={{ color: ui.red, fontSize: 11, fontWeight: 600, marginTop: 4 }}>\n                (Försenad)\n              </div>\n            )}\n          </div>\n\n          <div>\n            <label style={{ ...row(8) }}>\n              <input\n                type=\"checkbox\"\n                checked={currentPlan.staffInformed}\n                onChange={(e) => saveCurrentPlan({ staffInformed: e.target.checked })}\n              />\n              Personal tillsagd\n            </label>\n          </div>\n          \n          <div>\n            <label style={{ ...row(8) }}>\n              <input\n                type=\"checkbox\"\n                checked={currentPlan.done}\n                onChange={(e) => saveCurrentPlan({ done: e.target.checked, status: e.target.checked ? 'approved' : 'pending' })}\n              />\n              GFP klar\n            </label>\n          </div>\n\n          <div style={{ gridColumn: \"1 / -1\" }}>\n            <div style={{ fontSize: 12, fontWeight: 700, opacity: 0.7, marginBottom: 4 }}>Anteckning</div>\n            <textarea\n              value={currentPlan.note}\n              onChange={(e) => saveCurrentPlan({ note: e.target.value })}\n              placeholder=\"Skriv anteckning…\"\n              style={textareaBase}\n            />\n          </div>\n        </div>\n      ) : (\n        <div style={{ textAlign: 'center', color: ui.textMute, padding: 20 }}>\n          Inga planer än. Klicka \"Ny plan\" för att skapa en.\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction ClientWorkFull({\n  selectedClient,\n  savePlan,\n  saveWeeklyDoc,\n  saveMonthlyReport,\n  saveVisma,\n  weekIdInput,\n  setWeekIdInput,\n  monthIdInput,\n  setMonthIdInput\n}: {\n  selectedClient: Client | undefined;\n  savePlan: (updates: Partial<Plan> | { plans: GFPPlan[] }) => void;\n  saveWeeklyDoc: (weekId: WeekId, doc: WeeklyDoc) => void;\n  saveMonthlyReport: (monthId: MonthId, report: MonthlyReport) => void;\n  saveVisma: (weekId: WeekId, visma: VismaWeek) => void;\n  weekIdInput: WeekId;\n  setWeekIdInput: (weekId: WeekId) => void;\n  monthIdInput: MonthId;\n  setMonthIdInput: (monthId: MonthId) => void;\n}) {\n  const [isMobile, setIsMobile] = useState(false);\n  \n  // NEW: Confirm dialog state for plan deletion\n  const [confirmDialog, setConfirmDialog] = useState<{\n    open: boolean;\n    title: string;\n    description: string;\n    impactSummary?: string;\n    onConfirm: () => void;\n  }>({\n    open: false,\n    title: '',\n    description: '',\n    impactSummary: undefined,\n    onConfirm: () => {}\n  });\n\n  // NEW: Show confirm dialog for plan soft deletion with impact summary\n  function showDeletePlanConfirm(plan: GFPPlan) {\n    setConfirmDialog({\n      open: true,\n      title: \"Ta bort plan\",\n      description: `Är du säker på att du vill ta bort ${plan.title}? Planen försvinner från aktiva listor men all historik bevaras.`,\n      impactSummary: \"Mjuk-raderar 1 plan\",\n      onConfirm: () => {\n        if (!selectedClient) return;\n        const updatedPlans = selectedClient.plans.map(p => \n          p.id === plan.id \n            ? { ...p, deletedAt: new Date().toISOString() }\n            : p\n        );\n        savePlan({ plans: updatedPlans });\n        setConfirmDialog(prev => ({ ...prev, open: false }));\n      }\n    });\n  }\n\n  // Responsive check\n  useEffect(() => {\n    const checkMobile = () => {\n      setIsMobile(window.innerWidth < 1024);\n    };\n    \n    checkMobile();\n    window.addEventListener('resize', checkMobile);\n    return () => window.removeEventListener('resize', checkMobile);\n  }, []);\n\n  if (!selectedClient) {\n    return (\n      <div>\n        <div style={headerBar}>\n          <div style={title}>Klient – Arbete</div>\n        </div>\n        <div style={{ ...card, color: C.textLight }}>\n          Välj en klient i Personal-vyn för att börja arbeta.\n        </div>\n      </div>\n    );\n  }\n\n  // NEW: Load period data with proper isolation\n  const weeklyDoc = (() => {\n    const defaultDoc: WeeklyDoc = {\n      weekId: weekIdInput,\n      days: { mon: false, tue: false, wed: false, thu: false, fri: false, sat: false, sun: false },\n      status: \"pending\" as DocStatus,\n      note: ''\n    };\n    return loadPeriodData(selectedClient.id, 'weekly', weekIdInput, defaultDoc);\n  })();\n\n  const monthlyReport = (() => {\n    const defaultReport: MonthlyReport = {\n      monthId: monthIdInput,\n      sent: false,\n      status: \"pending\" as DocStatus,\n      note: ''\n    };\n    return loadPeriodData(selectedClient.id, 'monthly', monthIdInput, defaultReport);\n  })();\n\n  const vismaWeek = selectedClient.visma[weekIdInput] || {\n    weekId: weekIdInput,\n    days: { mon: false, tue: false, wed: false, thu: false, fri: false },\n    status: \"pending\" as DocStatus\n  };\n\n  // Plan status beräkning - använd senaste planen\n  const getPlanStatus = (): DocStatus => {\n    const latest = latestPlan(selectedClient.plans);\n    if (!latest) return \"pending\";\n    if (!latest.done) {\n      const today = todayYMD();\n      if (today > latest.dueDate) return \"rejected\"; // Försenad\n    }\n    return latest.done ? \"approved\" : \"pending\";\n  };\n\n  const planStatus = getPlanStatus();\n\n  if (isMobile) {\n    // Mobile: Accordion layout\n    const accordionSections = [\n      {\n        id: 'plan',\n        title: 'Plan (GFP)',\n        status: planStatus,\n        children: <PlanContent selectedClient={selectedClient} savePlan={savePlan} addNewPlan={() => {\n          const newPlan: GFPPlan = {\n            id: crypto.randomUUID(),\n            title: nextGfpTitle(selectedClient.plans),\n            date: todayYMD(),\n            dueDate: addDaysISO(todayYMD(), 21),\n            note: '',\n            staffInformed: false,\n            done: false,\n            status: 'pending'\n          };\n          const updatedPlans = [newPlan, ...selectedClient.plans];\n          savePlan({ plans: updatedPlans });\n        }} showDeletePlanConfirm={showDeletePlanConfirm} />\n      },\n      {\n        id: 'weekly',\n        title: 'Veckodokumentation',\n        status: weeklyDoc.status,\n        headerActions: (\n          <div onClick={(e) => e.stopPropagation()}>\n            <PeriodPicker\n              type=\"week\"\n              value={weekIdInput}\n              onChange={setWeekIdInput}\n            />\n          </div>\n        ),\n        children: <WeeklyDocContent weeklyDoc={weeklyDoc} saveWeeklyDoc={saveWeeklyDoc} weekIdInput={weekIdInput} clientId={selectedClient.id} />\n      },\n      {\n        id: 'monthly',\n        title: 'Månadsrapport',\n        status: monthlyReport.status,\n        headerActions: (\n          <div onClick={(e) => e.stopPropagation()}>\n            <PeriodPicker\n              type=\"month\"\n              value={monthIdInput}\n              onChange={setMonthIdInput}\n            />\n          </div>\n        ),\n        children: <MonthlyReportContent monthlyReport={monthlyReport} saveMonthlyReport={saveMonthlyReport} monthIdInput={monthIdInput} clientId={selectedClient.id} />\n      },\n      {\n        id: 'visma',\n        title: 'Visma Tid',\n        status: vismaWeek.status,\n        headerActions: (\n          <div onClick={(e) => e.stopPropagation()}>\n            <PeriodPicker\n              type=\"week\"\n              value={weekIdInput}\n              onChange={setWeekIdInput}\n            />\n          </div>\n        ),\n        children: <VismaContent vismaWeek={vismaWeek} saveVisma={saveVisma} weekIdInput={weekIdInput} />\n      }\n    ];\n\n    return (\n      <div>\n        <div style={headerBar}>\n          <div style={title}>Klient: {selectedClient.name}</div>\n          <div style={{ fontSize: 12, color: C.textLight }}>\n            V{getCurrentWeek()} • {getCurrentMonth()}\n          </div>\n        </div>\n        <Accordion sections={accordionSections} />\n      </div>\n    );\n  }\n\n  // Desktop: Two-column card layout\n  return (\n    <div>\n      <div style={headerBar}>\n        <div style={title}>Klient: {selectedClient.name}</div>\n        <div style={{ fontSize: 12, color: C.textLight }}>\n          Vecka: {getCurrentWeek()} • Månad: {getCurrentMonth()}\n        </div>\n      </div>\n\n      <div style={{ \n        display: \"grid\", \n        gridTemplateColumns: \"repeat(auto-fit, minmax(480px, 1fr))\", \n        gap: 16,\n        alignItems: \"start\"\n      }}>\n        <Card\n          title=\"Plan (GFP)\"\n          status={planStatus}\n        >\n          <PlanContent selectedClient={selectedClient} savePlan={savePlan} addNewPlan={() => {\n            const newPlan: GFPPlan = {\n              id: crypto.randomUUID(),\n              title: nextGfpTitle(selectedClient.plans),\n              date: todayYMD(),\n              dueDate: addDaysISO(todayYMD(), 21),\n              note: '',\n              staffInformed: false,\n              done: false,\n              status: 'pending'\n            };\n            const updatedPlans = [newPlan, ...selectedClient.plans];\n            savePlan({ plans: updatedPlans });\n          }} showDeletePlanConfirm={showDeletePlanConfirm} />\n        </Card>\n\n        <WeeklyDocSection\n          weeklyDoc={weeklyDoc}\n          saveWeeklyDoc={saveWeeklyDoc}\n          weekIdInput={weekIdInput}\n          setWeekIdInput={setWeekIdInput}\n          clientId={selectedClient.id}\n        />\n        \n        <MonthlyReportSection\n          monthlyReport={monthlyReport}\n          saveMonthlyReport={saveMonthlyReport}\n          monthIdInput={monthIdInput}\n          setMonthIdInput={setMonthIdInput}\n          clientId={selectedClient.id}\n        />\n        \n        <VismaSection\n          vismaWeek={vismaWeek}\n          saveVisma={saveVisma}\n          weekIdInput={weekIdInput}\n          setWeekIdInput={setWeekIdInput}\n        />\n      </div>\n      \n      {/* NEW: Confirm dialog */}\n      <ConfirmDialog\n        open={confirmDialog.open}\n        title={confirmDialog.title}\n        description={confirmDialog.description}\n        impactSummary={confirmDialog.impactSummary}\n        onConfirm={confirmDialog.onConfirm}\n        onCancel={() => setConfirmDialog(prev => ({ ...prev, open: false }))}\n      />\n    </div>\n  );\n}\n\nfunction Reports({ state }: { state: AppState }) {\n  return (\n    <div>\n      <div style={headerBar}>\n        <div style={title}>Rapporter & Export</div>\n      </div>\n\n      <div style={gridTwo}>\n        <div style={card()}>\n          <div style={cardHeader}>\n            <div style={{ fontWeight: 800 }}>Export</div>\n          </div>\n          <div style={{ display: \"flex\", gap: 8, marginBottom: 12 }}>\n            <button style={primaryBtn} onClick={() => exportToFile(state)}>\n              Ladda ner fil\n            </button>\n            <button style={btn} onClick={() => exportToClipboard(state)}>\n              Kopiera till urklipp\n            </button>\n          </div>\n          <div style={{ fontSize: 12, color: C.textLight }}>\n            Export inkluderar all data. Använd för backup eller för att dela med kollega.\n          </div>\n        </div>\n\n        <div style={card()}>\n          <div style={cardHeader}>\n            <div style={{ fontWeight: 800 }}>Lagring</div>\n          </div>\n          <div style={{ marginBottom: 8 }}>\n            <div style={{ fontSize: 12, color: C.textLight, marginBottom: 4 }}>Lagringstyp</div>\n            <div style={{ fontWeight: 700 }}>{getStorageType()}</div>\n          </div>\n          <div style={{ marginBottom: 8 }}>\n            <div style={{ fontSize: 12, color: C.textLight, marginBottom: 4 }}>Senaste backup</div>\n            <div style={{ fontWeight: 700 }}>{state.lastBackup || \"Aldrig\"}</div>\n          </div>\n          <div>\n            <div style={{ fontSize: 12, color: C.textLight, marginBottom: 4 }}>Backups tillgängliga</div>\n            <div style={{ fontWeight: 700 }}>{getBackups().length} st</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction StaffDetail({ state, selectedStaff }: { state: AppState; selectedStaff: Staff | undefined }) {\n  if (!selectedStaff) {\n    return (\n      <div>\n        <div style={headerBar}>\n          <div style={title}>Personal Dashboard</div>\n        </div>\n        <div style={card()}>\n          <div style={{ color: C.textLight, textAlign: 'center', padding: 20 }}>\n            Välj en personal i Personal-vyn för att visa dashboard.\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <StaffSummary staff={selectedStaff} state={state} />\n    </div>\n  );\n}\n\nfunction ArchiveView({ state, setState }: { state: AppState; setState: (fn: (prev: AppState) => AppState) => void }) {\n  const [staffQuery, setStaffQuery] = useState(\"\");\n  const [retentionDays, setRetentionDays] = useState(180);\n  \n  // NEW: Confirm dialog state for restore and cleanup\n  const [confirmDialog, setConfirmDialog] = useState<{\n    open: boolean;\n    title: string;\n    description: string;\n    impactSummary?: string;\n    onConfirm: () => void;\n  }>({\n    open: false,\n    title: '',\n    description: '',\n    onConfirm: () => {}\n  });\n\n  function restoreClient(clientId: string, staffId: string) {\n    setState((prev: AppState) => ({\n      ...prev,\n      staff: prev.staff.map(s =>\n        s.id === staffId ? { \n          ...s, \n          clients: s.clients.map(c => \n            c.id === clientId \n              ? { ...c, archivedAt: undefined, deletedAt: undefined }\n              : c\n          )\n        } : s\n      )\n    }));\n  }\n\n  function showRestoreClientConfirm(client: Client) {\n    setConfirmDialog({\n      open: true,\n      title: \"Återställ klient\",\n      description: `Är du säker på att du vill återställa ${client.name}? Klienten kommer att visas i aktiva listor igen.`,\n      onConfirm: () => {\n        const staff = state.staff.find(s => s.clients.some(c => c.id === client.id));\n        if (staff) {\n          restoreClient(client.id, staff.id);\n        }\n        setConfirmDialog(prev => ({ ...prev, open: false }));\n      }\n    });\n  }\n\n  // NEW: Cleanup functions\n  function performRetentionCleanup() {\n    const sweepResult = retentionSweep(retentionDays);\n    \n    if (sweepResult.toRemove.length === 0) {\n      alert('Inga gamla poster att rensa.');\n      return;\n    }\n\n    setConfirmDialog({\n      open: true,\n      title: \"Rensa gamla arkiverade poster\",\n      description: `Är du säker på att du vill rensa ${sweepResult.toRemove.length} poster som är äldre än ${retentionDays} dagar? Denna åtgärd kan inte ångras.`,\n      impactSummary: `Rensar ${sweepResult.toRemove.filter(item => item.type === 'client').length} klienter, ${sweepResult.toRemove.filter(item => item.type === 'plan').length} planer, ${sweepResult.toRemove.filter(item => item.type === 'weeklyDoc').length} veckorapporter, ${sweepResult.toRemove.filter(item => item.type === 'monthlyReport').length} månadsrapporter, ${sweepResult.toRemove.filter(item => item.type === 'vismaWeek').length} Visma-veckor`,\n      onConfirm: () => {\n        executeRetentionCleanup(sweepResult.toRemove);\n        setConfirmDialog(prev => ({ ...prev, open: false }));\n      }\n    });\n  }\n\n  function exportBeforeCleanup() {\n    const sweepResult = retentionSweep(retentionDays);\n    \n    if (sweepResult.toRemove.length === 0) {\n      alert('Inga gamla poster att exportera.');\n      return;\n    }\n\n    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n    const exportData = sweepResult.toRemove.map(item => ({\n      type: item.type,\n      id: item.id,\n      staffId: item.staffId,\n      clientId: item.clientId,\n      deletedAt: item.deletedAt,\n      data: JSON.stringify(item.data)\n    }));\n\n    exportToJSON(exportData, `ungdomsstod-retention-export-${timestamp}.json`);\n    exportToCSV(exportData, `ungdomsstod-retention-export-${timestamp}.csv`);\n  }\n\n  function executeRetentionCleanup(toRemove: Array<{ type: string; id: string; staffId: string; clientId?: string }>) {\n    setState((prev: AppState) => {\n      const newState = { ...prev };\n      \n      toRemove.forEach(item => {\n        const staffIndex = newState.staff.findIndex(s => s.id === item.staffId);\n        if (staffIndex === -1) return;\n\n        const staff = newState.staff[staffIndex];\n        if (!staff) return;\n\n        if (item.type === 'client') {\n          // Remove entire client\n          staff.clients = staff.clients.filter(c => c.id !== item.id);\n        } else if (item.clientId) {\n          // Remove individual items within client\n          const clientIndex = staff.clients.findIndex(c => c.id === item.clientId);\n          if (clientIndex === -1) return;\n\n          const client = staff.clients[clientIndex];\n          if (!client) return;\n          \n          switch (item.type) {\n            case 'plan':\n              client.plans = client.plans.filter(p => p.id !== item.id);\n              break;\n            case 'weeklyDoc':\n              delete client.weeklyDocs[item.id as WeekId];\n              break;\n            case 'monthlyReport':\n              delete client.monthlyReports[item.id as MonthId];\n              break;\n            case 'vismaWeek':\n              delete client.visma[item.id as WeekId];\n              break;\n          }\n        }\n      });\n      \n      return newState;\n    });\n    \n    alert(`${toRemove.length} poster har rensats från arkivet.`);\n  }\n\n  // Get all archived and soft-deleted clients grouped by staff\n  const archivedClientsByStaff = useMemo(() => {\n    const result: Array<{ staff: Staff; clients: Client[] }> = [];\n    \n    state.staff.forEach(staff => {\n      const archivedClients = staff.clients.filter(c => c.archivedAt || c.deletedAt);\n      if (archivedClients.length > 0) {\n        result.push({ staff, clients: archivedClients });\n      }\n    });\n    \n    return result;\n  }, [state.staff]);\n\n  const filteredStaff = archivedClientsByStaff.filter(({ staff }) => \n    staff.name.toLowerCase().includes(staffQuery.toLowerCase())\n  );\n\n  return (\n    <div>\n      <div style={headerBar}>\n        <div style={title}>Arkiverade & borttagna klienter</div>\n      </div>\n\n      {/* NEW: Retention cleanup controls */}\n      <div style={card()}>\n        <div style={cardHeader}>\n          <div style={{ fontWeight: 800 }}>Rensa gamla arkiverade poster</div>\n        </div>\n\n        <div style={{ marginBottom: 16 }}>\n          <label style={{ display: 'block', marginBottom: 8, fontWeight: 600, color: '#374151' }}>\n            Rensa poster äldre än (dagar):\n          </label>\n          <input\n            type=\"number\"\n            value={retentionDays}\n            onChange={e => setRetentionDays(parseInt(e.target.value) || 180)}\n            min=\"1\"\n            max=\"3650\"\n            style={{ ...inputBase, width: 120 }}\n          />\n        </div>\n\n        <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>\n          <button\n            style={{\n              ...primaryBtn,\n              background: '#007aff',\n              fontSize: 14\n            }}\n            onClick={exportBeforeCleanup}\n          >\n            🗃️ Exportera gamla poster\n          </button>\n          <button\n            style={{\n              ...primaryBtn,\n              background: '#ff3b30',\n              fontSize: 14\n            }}\n            onClick={performRetentionCleanup}\n          >\n            🗑️ Rensa gamla poster\n          </button>\n        </div>\n      </div>\n\n      <div style={card()}>\n        <div style={cardHeader}>\n          <div style={{ fontWeight: 800 }}>Arkiverade & borttagna klienter</div>\n        </div>\n\n        <input\n          placeholder=\"Sök personal…\"\n          value={staffQuery}\n          onChange={e => setStaffQuery(e.target.value)}\n          style={{ ...inputBase, width: '100%', marginBottom: 16 }}\n        />\n\n        {filteredStaff.length === 0 ? (\n          <div style={{ color: C.textLight, textAlign: 'center', padding: 20 }}>\n            {staffQuery ? 'Inga arkiverade eller borttagna klienter hittades för denna personal.' : 'Inga arkiverade eller borttagna klienter.'}\n          </div>\n        ) : (\n          <div style={{ ...col(12) }}>\n            {filteredStaff.map(({ staff, clients }) => (\n              <div key={staff.id} style={card()}>\n                <div style={{ fontWeight: 700, marginBottom: 12, color: ui.text }}>\n                  {staff.name} ({clients.length} arkiverade/borttagna)\n                </div>\n                <div style={{ ...col(8) }}>\n                  {clients.map(client => (\n                    <div\n                      key={client.id}\n                      style={{\n                        ...listItemStyle(false),\n                        display: \"grid\",\n                        gridTemplateColumns: \"1fr auto\",\n                        gap: 12,\n                        alignItems: \"center\"\n                      }}\n                    >\n                      <div>\n                        <div style={nameStyle}>{client.name}</div>\n                        <div style={metaStyle}>\n                          {client.archivedAt && `Arkiverad: ${new Date(client.archivedAt).toLocaleDateString('sv-SE')}`}\n                          {client.deletedAt && `Borttagen: ${new Date(client.deletedAt).toLocaleDateString('sv-SE')}`}\n                        </div>\n                      </div>\n                      <button \n                        style={{\n                          ...primaryBtn,\n                          fontSize: 12,\n                          padding: \"6px 12px\"\n                        }}\n                        onClick={() => showRestoreClientConfirm(client)}\n                      >\n                        Återställ\n                      </button>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n      \n      {/* Confirm dialog */}\n      <ConfirmDialog\n        open={confirmDialog.open}\n        title={confirmDialog.title}\n        description={confirmDialog.description}\n        impactSummary={confirmDialog.impactSummary}\n        onConfirm={confirmDialog.onConfirm}\n        onCancel={() => setConfirmDialog(prev => ({ ...prev, open: false }))}\n      />\n    </div>\n  );\n}\n\n/* ---------- App Render ---------- */\nexport default function App() {\n  const [state, setState] = useState<AppState>(() => loadState() ?? initialState());\n  const [view, setView] = useState<View>(\"overview\");\n  const [weekIdInput, setWeekIdInput] = useState<WeekId>(getCurrentWeek());\n  const [monthIdInput, setMonthIdInput] = useState<MonthId>(getCurrentMonth());\n\n  // NEW: Cleanup orphaned period data on app start\n  useEffect(() => {\n    const allClientIds = getAllClientIds(state);\n    cleanupClientLocalStorage(allClientIds);\n  }, [state]); // Run once on mount and when state changes\n\n  // NEW: Cleanup orphaned period data when clients are removed\n  useEffect(() => {\n    const allClientIds = getAllClientIds(state);\n    cleanupClientLocalStorage(allClientIds);\n  }, [state.staff, state]); // Run when staff/clients change\n\n  // SaveBar hanterar nu auto-save med debounce\n  // useEffect för saveState borttaget\n\n  // ★ Om vi hamnar i klientvyn utan vald klient: gå till Personal\n  useEffect(() => {\n    if (view === 'client' && !state.selectedClientId) {\n      setView('staff');\n    }\n    if (view === 'staffDetail' && !state.selectedStaffId) {\n      setView('staff');\n    }\n  }, [view, state.selectedClientId, state.selectedStaffId]);\n\n  const selectedStaff = useMemo(\n    () => state.staff.find((s) => s.id === state.selectedStaffId),\n    [state.staff, state.selectedStaffId]\n  );\n\n  const selectedClient = useMemo(() => {\n    const s = selectedStaff;\n    if (!s) return undefined;\n    return s.clients.find((c) => c.id === state.selectedClientId && !c.archivedAt && !c.deletedAt);\n  }, [selectedStaff, state.selectedClientId]);\n\n  const kpis = useMemo((): Record<string, number> => {\n    const nowWeek = getCurrentWeek();\n    const nowMonth = getCurrentMonth();\n    const today = todayYMD();\n\n    let delayedPlan = 0, waitingPlan = 0, delayedDocs = 0, delayedMonthly = 0, delayedVisma = 0, totalClients = 0, totalPlansActive = 0, completedThisWeek = 0;\n\n    state.staff.forEach(st => {\n      st.clients.forEach(client => {\n        // Skip archived and soft-deleted clients\n        if (client.archivedAt || client.deletedAt) return;\n        \n        totalClients += 1;\n        \n        // Använd senaste planen för KPI-beräkning\n        const latest = latestPlan(client.plans);\n        if (!latest) {\n          waitingPlan += 1;\n        } else {\n          if (!latest.done) {\n            if (today > latest.dueDate) delayedPlan += 1;\n            else waitingPlan += 1;\n          } else {\n            totalPlansActive += 1;\n          }\n        }\n        Object.values(client.weeklyDocs).forEach((wd) => {\n          if (compareWeekId(wd.weekId, nowWeek) === 0 && wd.status === \"approved\") {\n            completedThisWeek += 1;\n          }\n          if (compareWeekId(wd.weekId, nowWeek) < 0 && (wd.status !== \"approved\")) delayedDocs += 1;\n        });\n        Object.values(client.monthlyReports).forEach((mr) => {\n          if (compareMonthId(mr.monthId, nowMonth) < 0 && (!mr.sent || mr.status !== \"approved\")) delayedMonthly += 1;\n        });\n        Object.values(client.visma).forEach((vw) => {\n          if (compareWeekId(vw.weekId, nowWeek) < 0 && (vw.status !== \"approved\")) delayedVisma += 1;\n        });\n      });\n    });\n\n    return { \n      delayedPlan, \n      waitingPlan, \n      delayedDocs, \n      delayedMonthly, \n      delayedVisma, \n      totalClients, \n      totalPlansActive, \n      completedThisWeek \n    };\n  }, [state.staff]);\n\n  return (\n    <div style={app}>\n      <aside style={sidebar} data-print-hide>\n        <div style={{ fontWeight: 900, fontSize: 18, color: ui.text, marginBottom: 10 }}>Vårdadmin</div>\n        {/* NEW: Updated navigation with proper contrast */}\n        <button \n          style={navItemStyle(view === \"overview\")} \n          onClick={() => setView(\"overview\")}\n          onMouseEnter={(e) => {\n            if (view !== \"overview\") {\n              e.currentTarget.style.background = ui.navHoverBg;\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (view !== \"overview\") {\n              e.currentTarget.style.background = 'transparent';\n            }\n          }}\n          onFocus={(e) => {\n            e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n            e.currentTarget.style.outlineOffset = '2px';\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Översikt\n        </button>\n        <button\n          style={{\n            ...navItemStyle(view === \"client\"),\n            opacity: selectedClient ? 1 : 0.55,\n            cursor: selectedClient ? 'pointer' : 'not-allowed'\n          }}\n          onClick={() => selectedClient && setView(\"client\")}\n          onMouseEnter={(e) => {\n            if (view !== \"client\" && selectedClient) {\n              e.currentTarget.style.background = ui.navHoverBg;\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (view !== \"client\") {\n              e.currentTarget.style.background = 'transparent';\n            }\n          }}\n          onFocus={(e) => {\n            if (selectedClient) {\n              e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n              e.currentTarget.style.outlineOffset = '2px';\n            }\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Klienten {selectedClient ? `(${selectedClient.name})` : \"\"}\n        </button>\n        <button \n          style={navItemStyle(view === \"staff\")} \n          onClick={() => setView(\"staff\")}\n          onMouseEnter={(e) => {\n            if (view !== \"staff\") {\n              e.currentTarget.style.background = ui.navHoverBg;\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (view !== \"staff\") {\n              e.currentTarget.style.background = 'transparent';\n            }\n          }}\n          onFocus={(e) => {\n            e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n            e.currentTarget.style.outlineOffset = '2px';\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Personal\n        </button>\n        <button\n          style={{\n            ...navItemStyle(view === \"staffDetail\"),\n            opacity: selectedStaff ? 1 : 0.55,\n            cursor: selectedStaff ? 'pointer' : 'not-allowed'\n          }}\n          onClick={() => selectedStaff && setView(\"staffDetail\")}\n          onMouseEnter={(e) => {\n            if (view !== \"staffDetail\" && selectedStaff) {\n              e.currentTarget.style.background = ui.navHoverBg;\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (view !== \"staffDetail\") {\n              e.currentTarget.style.background = 'transparent';\n            }\n          }}\n          onFocus={(e) => {\n            if (selectedStaff) {\n              e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n              e.currentTarget.style.outlineOffset = '2px';\n            }\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Dashboard {selectedStaff ? `(${selectedStaff.name})` : \"\"}\n        </button>\n        <button \n          style={navItemStyle(view === \"reports\")} \n          onClick={() => setView(\"reports\")}\n          onMouseEnter={(e) => {\n            if (view !== \"reports\") {\n              e.currentTarget.style.background = ui.navHoverBg;\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (view !== \"reports\") {\n              e.currentTarget.style.background = 'transparent';\n            }\n          }}\n          onFocus={(e) => {\n            e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n            e.currentTarget.style.outlineOffset = '2px';\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Rapporter\n        </button>\n        <button \n          style={navItemStyle(view === \"archive\")} \n          onClick={() => setView(\"archive\")}\n          onMouseEnter={(e) => {\n            if (view !== \"archive\") {\n              e.currentTarget.style.background = ui.navHoverBg;\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (view !== \"archive\") {\n              e.currentTarget.style.background = 'transparent';\n            }\n          }}\n          onFocus={(e) => {\n            e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n            e.currentTarget.style.outlineOffset = '2px';\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Arkiv\n        </button>\n        <div style={{ flex: 1 }} />\n        <button \n          style={{ ...navItemStyle(false), color: ui.textMute }}\n          onMouseEnter={(e) => {\n            e.currentTarget.style.background = ui.navHoverBg;\n          }}\n          onMouseLeave={(e) => {\n            e.currentTarget.style.background = 'transparent';\n          }}\n          onFocus={(e) => {\n            e.currentTarget.style.outline = `2px solid ${ui.blue}`;\n            e.currentTarget.style.outlineOffset = '2px';\n          }}\n          onBlur={(e) => {\n            e.currentTarget.style.outline = 'none';\n          }}\n        >\n          Logga ut\n        </button>\n      </aside>\n\n      <main style={main}>\n        {view === \"overview\" && <Overview state={state} kpis={kpis} />}\n        {view === \"staff\" && <StaffView state={state} setState={setState} selectedStaff={selectedStaff} setView={setView} />}\n        {view === \"staffDetail\" && <StaffDetail state={state} selectedStaff={selectedStaff} />}\n        {view === \"archive\" && <ArchiveView state={state} setState={setState} />}\n        {view === \"client\" && (\n          <ClientWorkFull\n            selectedClient={selectedClient}\n            savePlan={(u: Partial<Plan> | { plans: GFPPlan[] }) => {\n              if (!selectedStaff || !selectedClient) return;\n              \n              // NEW: Write GFP plans to history\n              if ('plans' in u && u.plans) {\n                u.plans.forEach(plan => {\n                  upsertHistory({\n                    periodType: 'week', // GFP plans are tracked weekly\n                    periodId: getCurrentWeek(), // Use current week for GFP tracking\n                    staffId: selectedStaff.id,\n                    clientId: selectedClient.id,\n                    metric: 'gfp',\n                    status: plan.status,\n                    value: plan.done ? 1 : 0\n                  });\n                });\n              }\n              \n              setState((prev) => ({\n                ...prev,\n                staff: prev.staff.map((s) =>\n                  s.id === selectedStaff.id\n                    ? { \n                        ...s, \n                        clients: s.clients.map((c) => \n                          c.id === selectedClient.id \n                            ? { \n                                ...c, \n                                ...('plans' in u ? { plans: u.plans } : { plan: { ...c.plan, ...u } })\n                              } \n                            : c\n                        ) \n                      }\n                    : s\n                )\n              }));\n            }}\n            saveWeeklyDoc={(weekId: WeekId, payload: WeeklyDoc) => {\n              if (!selectedStaff || !selectedClient) return;\n              // NEW: Save to period-based storage\n              savePeriodData(selectedClient.id, 'weekly', weekId, payload);\n              \n              // NEW: Write to history\n              const daysCount = Object.values(payload.days).filter(Boolean).length;\n              upsertHistory({\n                periodType: 'week',\n                periodId: weekId,\n                staffId: selectedStaff.id,\n                clientId: selectedClient.id,\n                metric: 'weekDoc',\n                status: payload.status,\n                value: daysCount\n              });\n              \n              setState((prev) => ({\n                ...prev,\n                staff: prev.staff.map((s) =>\n                  s.id === selectedStaff.id\n                    ? { ...s, clients: s.clients.map((c) => (c.id === selectedClient.id ? { ...c, weeklyDocs: { ...c.weeklyDocs, [weekId]: payload } } : c)) }\n                    : s\n                )\n              }));\n            }}\n            saveMonthlyReport={(monthId: MonthId, payload: MonthlyReport) => {\n              if (!selectedStaff || !selectedClient) return;\n              // NEW: Save to period-based storage\n              savePeriodData(selectedClient.id, 'monthly', monthId, payload);\n              \n              // NEW: Write to history\n              upsertHistory({\n                periodType: 'month',\n                periodId: monthId,\n                staffId: selectedStaff.id,\n                clientId: selectedClient.id,\n                metric: 'monthReport',\n                status: payload.status,\n                value: payload.sent ? 1 : 0\n              });\n              \n              setState((prev) => ({\n                ...prev,\n                staff: prev.staff.map((s) =>\n                  s.id === selectedStaff.id\n                    ? { ...s, clients: s.clients.map((c) => (c.id === selectedClient.id ? { ...c, monthlyReports: { ...c.monthlyReports, [monthId]: payload } } : c)) }\n                    : s\n                )\n              }));\n            }}\n            saveVisma={(weekId: WeekId, payload: VismaWeek) => {\n              if (!selectedStaff || !selectedClient) return;\n              setState((prev) => ({\n                ...prev,\n                staff: prev.staff.map((s) =>\n                  s.id === selectedStaff.id\n                    ? { ...s, clients: s.clients.map((c) => (c.id === selectedClient.id ? { ...c, visma: { ...c.visma, [weekId]: payload } } : c)) }\n                    : s\n                )\n              }));\n            }}\n            weekIdInput={weekIdInput}\n            setWeekIdInput={setWeekIdInput}\n            monthIdInput={monthIdInput}\n            setMonthIdInput={setMonthIdInput}\n          />\n        )}\n        {view === \"reports\" && <Reports state={state} />}\n      </main>\n      \n      <SaveBar state={state} data-print-hide />\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/AppWithAPI.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/AppWithAPI.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/AppWithAPI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/FeatureFlagManager.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/FeatureFlagManager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/FeatureFlagManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useFeatureFlags' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[516,519],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[516,519],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectedFlag' is assigned a value but never used.","line":37,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'showCreateForm' is assigned a value but never used.","line":38,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":24},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'fetchFlags'. Either include it or remove the dependency array.","line":103,"column":6,"nodeType":"ArrayExpression","endLine":103,"endColumn":13,"suggestions":[{"desc":"Update the dependencies array to be: [fetchFlags, token]","fix":{"range":[2796,2803],"text":"[fetchFlags, token]"}}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Feature Flag Management Component\n * Admin interface for managing feature flags\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { useFeatureFlags } from '../hooks/useFeatureFlags';\n\ninterface FeatureFlag {\n  id: string;\n  name: string;\n  description: string;\n  enabled: boolean;\n  rolloutPercentage: number;\n  targetUsers: string[];\n  targetRoles: string[];\n  environment: string;\n  createdBy: string;\n  createdAt: string;\n  updatedAt: string;\n  expiresAt?: string;\n  metadata: Record<string, any>;\n}\n\ninterface FeatureFlagManagerProps {\n  apiUrl?: string;\n  token?: string;\n}\n\nconst FeatureFlagManager: React.FC<FeatureFlagManagerProps> = ({ \n  apiUrl = '/api', \n  token \n}) => {\n  const [flags, setFlags] = useState<FeatureFlag[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [selectedFlag, setSelectedFlag] = useState<FeatureFlag | null>(null);\n  const [showCreateForm, setShowCreateForm] = useState(false);\n\n  const fetchFlags = async () => {\n    if (!token) return;\n\n    try {\n      setLoading(true);\n      const response = await fetch(`${apiUrl}/feature-flags`, {\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch flags: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      if (result.success) {\n        setFlags(result.data.flags);\n      } else {\n        throw new Error(result.message || 'Failed to fetch flags');\n      }\n    } catch (error) {\n      console.error('Failed to fetch feature flags:', error);\n      setError(error instanceof Error ? error.message : 'Unknown error');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const updateFlag = async (flagName: string, updates: Partial<FeatureFlag>) => {\n    if (!token) return;\n\n    try {\n      const response = await fetch(`${apiUrl}/feature-flags/${flagName}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify(updates)\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to update flag: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      if (result.success) {\n        setFlags(prev => prev.map(flag => \n          flag.name === flagName ? { ...flag, ...updates } : flag\n        ));\n        setSelectedFlag(null);\n      } else {\n        throw new Error(result.message || 'Failed to update flag');\n      }\n    } catch (error) {\n      console.error('Failed to update feature flag:', error);\n      setError(error instanceof Error ? error.message : 'Unknown error');\n    }\n  };\n\n  useEffect(() => {\n    fetchFlags();\n  }, [token]);\n\n  const toggleFlag = (flagName: string, enabled: boolean) => {\n    updateFlag(flagName, { enabled });\n  };\n\n  const updateRolloutPercentage = (flagName: string, percentage: number) => {\n    updateFlag(flagName, { rolloutPercentage: percentage });\n  };\n\n  if (loading) {\n    return (\n      <div style={{ padding: '20px', textAlign: 'center' }}>\n        <p>Laddar feature flags...</p>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div style={{ padding: '20px', color: '#ff3b30' }}>\n        <p>Fel vid hämtning av feature flags: {error}</p>\n        <button \n          onClick={fetchFlags}\n          style={{\n            padding: '8px 16px',\n            backgroundColor: '#007aff',\n            color: 'white',\n            border: 'none',\n            borderRadius: '4px',\n            cursor: 'pointer'\n          }}\n        >\n          Försök igen\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{ padding: '20px', maxWidth: '1200px', margin: '0 auto' }}>\n      <div style={{ \n        display: 'flex', \n        justifyContent: 'space-between', \n        alignItems: 'center',\n        marginBottom: '20px'\n      }}>\n        <h2 style={{ margin: 0, color: '#111111' }}>Feature Flags</h2>\n        <button\n          onClick={() => setShowCreateForm(true)}\n          style={{\n            padding: '10px 20px',\n            backgroundColor: '#16a34a',\n            color: 'white',\n            border: 'none',\n            borderRadius: '4px',\n            cursor: 'pointer'\n          }}\n        >\n          Skapa ny flagga\n        </button>\n      </div>\n\n      <div style={{\n        display: 'grid',\n        gap: '16px',\n        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))'\n      }}>\n        {flags.map(flag => (\n          <div\n            key={flag.id}\n            style={{\n              border: '1px solid rgba(0,0,0,0.12)',\n              borderRadius: '8px',\n              padding: '16px',\n              backgroundColor: '#fff'\n            }}\n          >\n            <div style={{ marginBottom: '12px' }}>\n              <h3 style={{ \n                margin: '0 0 8px 0', \n                color: '#111111',\n                fontSize: '16px'\n              }}>\n                {flag.name}\n              </h3>\n              <p style={{ \n                margin: '0 0 12px 0', \n                color: '#374151',\n                fontSize: '14px'\n              }}>\n                {flag.description}\n              </p>\n            </div>\n\n            <div style={{ marginBottom: '12px' }}>\n              <label style={{ \n                display: 'flex', \n                alignItems: 'center',\n                gap: '8px',\n                fontSize: '14px',\n                color: '#111111'\n              }}>\n                <input\n                  type=\"checkbox\"\n                  checked={flag.enabled}\n                  onChange={(e) => toggleFlag(flag.name, e.target.checked)}\n                  style={{ transform: 'scale(1.2)' }}\n                />\n                Aktiverad\n              </label>\n            </div>\n\n            <div style={{ marginBottom: '12px' }}>\n              <label style={{ \n                display: 'block',\n                fontSize: '14px',\n                color: '#111111',\n                marginBottom: '4px'\n              }}>\n                Rollout: {flag.rolloutPercentage}%\n              </label>\n              <input\n                type=\"range\"\n                min=\"0\"\n                max=\"100\"\n                value={flag.rolloutPercentage}\n                onChange={(e) => updateRolloutPercentage(flag.name, parseInt(e.target.value))}\n                style={{ width: '100%' }}\n              />\n            </div>\n\n            <div style={{ \n              fontSize: '12px', \n              color: '#6b7280',\n              borderTop: '1px solid rgba(0,0,0,0.12)',\n              paddingTop: '8px'\n            }}>\n              <div>Miljö: {flag.environment}</div>\n              <div>Skapad: {new Date(flag.createdAt).toLocaleDateString('sv-SE')}</div>\n              {flag.expiresAt && (\n                <div>Utgår: {new Date(flag.expiresAt).toLocaleDateString('sv-SE')}</div>\n              )}\n            </div>\n          </div>\n        ))}\n      </div>\n\n      {flags.length === 0 && (\n        <div style={{ \n          textAlign: 'center', \n          padding: '40px',\n          color: '#6b7280'\n        }}>\n          <p>Inga feature flags hittades.</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default FeatureFlagManager;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/GroupAttendanceWidget.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/GroupAttendanceWidget.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/GroupAttendanceWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/LoginForm.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/LoginForm.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/LoginForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SaveBar.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SaveBar.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SaveBar.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'autoSaveTimeout' and 'saveData'. Either include them or remove the dependency array.","line":147,"column":6,"nodeType":"ArrayExpression","endLine":147,"endColumn":13,"suggestions":[{"desc":"Update the dependencies array to be: [autoSaveTimeout, saveData, state]","fix":{"range":[3846,3853],"text":"[autoSaveTimeout, saveData, state]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\nimport { AppState, Toast, ToastType } from '../types';\nimport { setStoredData, getStorageType } from '../storage';\n\ninterface SaveBarProps {\n  state: AppState;\n  onSaveComplete?: (success: boolean) => void;\n}\n\ninterface ToastNotificationProps {\n  toast: Toast;\n  onRemove: (id: string) => void;\n}\n\nfunction ToastNotification({ toast, onRemove }: ToastNotificationProps) {\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      onRemove(toast.id);\n    }, toast.duration || 3000);\n\n    return () => clearTimeout(timer);\n  }, [toast.id, toast.duration, onRemove]);\n\n  const bgColor = {\n    success: '#16a34a',\n    error: '#ff3b30',\n    info: '#007aff'\n  }[toast.type];\n\n  return (\n    <div\n      style={{\n        background: bgColor,\n        color: '#ffffff',\n        padding: '12px 16px',\n        borderRadius: '8px',\n        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        gap: '12px',\n        minWidth: '300px',\n        animation: 'slideInUp 0.3s ease-out',\n        fontSize: '14px',\n        fontWeight: '600'\n      }}\n    >\n      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n        <span>{getToastIcon(toast.type)}</span>\n        <span>{toast.message}</span>\n      </div>\n      <button\n        onClick={() => onRemove(toast.id)}\n        style={{\n          background: 'transparent',\n          border: 'none',\n          color: '#ffffff',\n          cursor: 'pointer',\n          padding: '4px',\n          borderRadius: '4px',\n          opacity: 0.8,\n          fontSize: '16px',\n          lineHeight: 1\n        }}\n        aria-label=\"Stäng meddelande\"\n      >\n        ×\n      </button>\n    </div>\n  );\n}\n\nfunction getToastIcon(type: ToastType): string {\n  switch (type) {\n    case 'success': return '✓';\n    case 'error': return '✗';\n    case 'info': return 'ℹ';\n    default: return '';\n  }\n}\n\nexport default function SaveBar({ state, onSaveComplete }: SaveBarProps) {\n  const [isSaving, setIsSaving] = useState(false);\n  const [lastSaved, setLastSaved] = useState<string | null>(null);\n  const [toasts, setToasts] = useState<Toast[]>([]);\n  const [autoSaveTimeout, setAutoSaveTimeout] = useState<number | null>(null);\n\n  const addToast = useCallback((message: string, type: ToastType, duration = 3000) => {\n    const toast: Toast = {\n      id: crypto.randomUUID(),\n      message,\n      type,\n      duration\n    };\n    setToasts(prev => [...prev, toast]);\n  }, []);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  const saveData = useCallback(async () => {\n    setIsSaving(true);\n    \n    try {\n      // Lägg till timestamp för senaste uppdatering\n      const stateToSave = {\n        ...state,\n        lastBackup: new Date().toLocaleString('sv-SE')\n      };\n\n      const dataString = JSON.stringify(stateToSave);\n      const success = setStoredData(dataString);\n      \n      if (success) {\n        setLastSaved(new Date().toLocaleString('sv-SE'));\n        addToast('Sparat', 'success');\n      } else {\n        addToast('Kunde inte spara – ändringar finns lokalt (minnes-läge)', 'error', 5000);\n      }\n      \n      onSaveComplete?.(success);\n    } catch (error) {\n      console.error('Save failed:', error);\n      addToast('Fel vid sparande', 'error');\n      onSaveComplete?.(false);\n    } finally {\n      setIsSaving(false);\n    }\n  }, [state, addToast, onSaveComplete]);\n\n  // Auto-save med debounce\n  useEffect(() => {\n    if (autoSaveTimeout) {\n      clearTimeout(autoSaveTimeout);\n    }\n\n    const timeout = setTimeout(() => {\n      saveData();\n    }, 400); // 400ms debounce\n\n    setAutoSaveTimeout(timeout);\n\n    return () => {\n      if (timeout) clearTimeout(timeout);\n    };\n  }, [state]); // Triggas när state ändras\n\n  // Cleanup timeout vid unmount\n  useEffect(() => {\n    return () => {\n      if (autoSaveTimeout) clearTimeout(autoSaveTimeout);\n    };\n  }, [autoSaveTimeout]);\n\n  const storageType = getStorageType();\n  const isMemoryMode = storageType === 'Minne';\n\n  return (\n    <>\n      {/* Toast container */}\n      <div\n        style={{\n          position: 'fixed',\n          top: '20px',\n          right: '20px',\n          zIndex: 10000,\n          display: 'flex',\n          flexDirection: 'column',\n          gap: '8px',\n          pointerEvents: 'none'\n        }}\n      >\n        {toasts.map(toast => (\n          <div key={toast.id} style={{ pointerEvents: 'auto' }}>\n            <ToastNotification toast={toast} onRemove={removeToast} />\n          </div>\n        ))}\n      </div>\n\n      {/* Memory mode banner */}\n      {isMemoryMode && (\n        <div\n          style={{\n            position: 'fixed',\n            top: 0,\n            left: 0,\n            right: 0,\n            background: '#ff9500',\n            color: '#ffffff',\n            padding: '8px',\n            textAlign: 'center',\n            fontSize: '12px',\n            fontWeight: '600',\n            zIndex: 9999,\n            boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n          }}\n        >\n          ⚠️ Kunde inte spara – ändringar finns lokalt (minnes-läge). Data försvinner vid siduppdatering.\n        </div>\n      )}\n\n      {/* Sticky save bar */}\n      <div\n        style={{\n          position: 'fixed',\n          bottom: 0,\n          left: 0,\n          right: 0,\n          background: '#ffffff',\n          borderTop: '1px solid rgba(0,0,0,0.12)',\n          padding: '12px 16px',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          gap: '12px',\n          zIndex: 1000,\n          boxShadow: '0 -2px 12px rgba(0,0,0,0.08)',\n          minHeight: '56px'\n        }}\n      >\n        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', fontSize: '12px', color: '#6b7280' }}>\n          <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>\n            <span>Lagring:</span>\n            <span style={{ fontWeight: '600', color: isMemoryMode ? '#ff9500' : '#16a34a' }}>\n              {storageType}\n            </span>\n          </div>\n          {lastSaved && (\n            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>\n              <span>Senast sparat:</span>\n              <span style={{ fontWeight: '600', color: '#111111' }}>{lastSaved}</span>\n            </div>\n          )}\n        </div>\n\n        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>\n          {isSaving && (\n            <div style={{ display: 'flex', alignItems: 'center', gap: '6px', color: '#6b7280', fontSize: '12px' }}>\n              <div\n                style={{\n                  width: '12px',\n                  height: '12px',\n                  border: '2px solid #e5e7eb',\n                  borderTop: '2px solid #007aff',\n                  borderRadius: '50%',\n                  animation: 'spin 1s linear infinite'\n                }}\n              />\n              <span>Sparar...</span>\n            </div>\n          )}\n          \n          <button\n            onClick={saveData}\n            disabled={isSaving}\n            style={{\n              background: '#007aff',\n              color: '#ffffff',\n              border: 'none',\n              borderRadius: '8px',\n              padding: '10px 20px',\n              fontSize: '14px',\n              fontWeight: '600',\n              cursor: isSaving ? 'not-allowed' : 'pointer',\n              opacity: isSaving ? 0.7 : 1,\n              transition: 'all 0.2s ease',\n              boxShadow: '0 2px 4px rgba(0,122,255,0.2)'\n            }}\n            onMouseOver={(e) => {\n              if (!isSaving) {\n                e.currentTarget.style.background = '#0051d5';\n                e.currentTarget.style.transform = 'translateY(-1px)';\n                e.currentTarget.style.boxShadow = '0 4px 8px rgba(0,122,255,0.3)';\n              }\n            }}\n            onMouseOut={(e) => {\n              if (!isSaving) {\n                e.currentTarget.style.background = '#007aff';\n                e.currentTarget.style.transform = 'translateY(0)';\n                e.currentTarget.style.boxShadow = '0 2px 4px rgba(0,122,255,0.2)';\n              }\n            }}\n          >\n            {isSaving ? 'Sparar...' : 'Spara'}\n          </button>\n        </div>\n      </div>\n\n      {/* CSS animations inline */}\n      <style>\n        {`\n          @keyframes slideInUp {\n            from {\n              transform: translateY(100%);\n              opacity: 0;\n            }\n            to {\n              transform: translateY(0);\n              opacity: 1;\n            }\n          }\n          \n          @keyframes spin {\n            from {\n              transform: rotate(0deg);\n            }\n            to {\n              transform: rotate(360deg);\n            }\n          }\n        `}\n      </style>\n    </>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SimpleAuth.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SimpleAuth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SimpleAuth.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SimpleLogin.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SimpleLogin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/SimpleLogin.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/StaffSummary.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/StaffSummary.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/StaffSummary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/TuesdayAttendanceWidget.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/TuesdayAttendanceWidget.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/components/TuesdayAttendanceWidget.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/date.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/date.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/date.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/hooks/useFeatureFlags.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[236,239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[236,239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Feature Flags\n * Provides easy access to feature flags in React components\n */\nexport interface FeatureFlagEvaluation {\n    flagName: string;\n    enabled: boolean;\n    reason: string;\n    metadata?: Record<string, any>;\n}\ninterface UseFeatureFlagsOptions {\n    apiUrl?: string;\n    token?: string;\n    refreshInterval?: number;\n}\nexport declare function useFeatureFlags(flagNames: string[], options?: UseFeatureFlagsOptions): {\n    isEnabled: (flagName: string) => boolean;\n    isLoading: boolean;\n    error: string | null;\n    refresh: () => Promise<void>;\n};\n/**\n * Hook for evaluating a single feature flag\n */\nexport declare function useFeatureFlag(flagName: string, options?: UseFeatureFlagsOptions): {\n    enabled: boolean;\n    isLoading: boolean;\n    error: string | null;\n    refresh: () => Promise<void>;\n};\n/**\n * Hook for conditional rendering based on feature flags\n */\nexport declare function useFeatureFlagComponent(flagName: string, options?: UseFeatureFlagsOptions): {\n    enabled: boolean;\n    isLoading: boolean;\n    error: string | null;\n    render: (children: React.ReactNode) => import(\"react\").ReactNode;\n    renderIf: (condition: boolean, children: React.ReactNode) => import(\"react\").ReactNode;\n};\nexport default useFeatureFlags;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/hooks/useFeatureFlags.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/hooks/useFeatureFlags.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[288,291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[288,291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * React Hook for Feature Flags\n * Provides easy access to feature flags in React components\n */\n\nimport { useState, useEffect, useCallback } from 'react';\n\nexport interface FeatureFlagEvaluation {\n  flagName: string;\n  enabled: boolean;\n  reason: string;\n  metadata?: Record<string, any>;\n}\n\ninterface FeatureFlagsState {\n  flags: Record<string, boolean>;\n  loading: boolean;\n  error: string | null;\n}\n\ninterface UseFeatureFlagsOptions {\n  apiUrl?: string;\n  token?: string;\n  refreshInterval?: number;\n}\n\nexport function useFeatureFlags(\n  flagNames: string[],\n  options: UseFeatureFlagsOptions = {}\n) {\n  const {\n    apiUrl = '/api',\n    token,\n    refreshInterval = 5 * 60 * 1000 // 5 minutes\n  } = options;\n\n  const [state, setState] = useState<FeatureFlagsState>({\n    flags: {},\n    loading: true,\n    error: null\n  });\n\n  const fetchFeatureFlags = useCallback(async () => {\n    if (!token || flagNames.length === 0) {\n      setState(prev => ({ ...prev, loading: false }));\n      return;\n    }\n\n    try {\n      setState(prev => ({ ...prev, loading: true, error: null }));\n\n      const response = await fetch(`${apiUrl}/feature-flags/evaluate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({ flagNames })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch feature flags: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n\n      if (!result.success) {\n        throw new Error(result.message || 'Failed to fetch feature flags');\n      }\n\n      const evaluations: FeatureFlagEvaluation[] = result.data;\n      const flags: Record<string, boolean> = {};\n\n      evaluations.forEach(evaluation => {\n        flags[evaluation.flagName] = evaluation.enabled;\n      });\n\n      setState({\n        flags,\n        loading: false,\n        error: null\n      });\n    } catch (error) {\n      console.error('Failed to fetch feature flags:', error);\n      setState(prev => ({\n        ...prev,\n        loading: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      }));\n    }\n  }, [flagNames, apiUrl, token]);\n\n  useEffect(() => {\n    fetchFeatureFlags();\n\n    if (refreshInterval > 0) {\n      const interval = setInterval(fetchFeatureFlags, refreshInterval);\n      return () => clearInterval(interval);\n    }\n    \n    return undefined;\n  }, [fetchFeatureFlags, refreshInterval]);\n\n  const isEnabled = useCallback((flagName: string): boolean => {\n    return state.flags[flagName] || false;\n  }, [state.flags]);\n\n  const isLoading = state.loading;\n  const error = state.error;\n\n  return {\n    isEnabled,\n    isLoading,\n    error,\n    refresh: fetchFeatureFlags\n  };\n}\n\n/**\n * Hook for evaluating a single feature flag\n */\nexport function useFeatureFlag(\n  flagName: string,\n  options: UseFeatureFlagsOptions = {}\n) {\n  const { isEnabled, isLoading, error, refresh } = useFeatureFlags([flagName], options);\n  \n  return {\n    enabled: isEnabled(flagName),\n    isLoading,\n    error,\n    refresh\n  };\n}\n\n/**\n * Hook for conditional rendering based on feature flags\n */\nexport function useFeatureFlagComponent(\n  flagName: string,\n  options: UseFeatureFlagsOptions = {}\n) {\n  const { enabled, isLoading, error } = useFeatureFlag(flagName, options);\n\n  return {\n    enabled,\n    isLoading,\n    error,\n    render: (children: React.ReactNode) => enabled ? children : null,\n    renderIf: (condition: boolean, children: React.ReactNode) => \n      enabled && condition ? children : null\n  };\n}\n\nexport default useFeatureFlags;\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/hooks/useStaffStats.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/hooks/useStaffStats.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/hooks/useStaffStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/main.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/storage.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/storage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/utils/debug.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/utils/debug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/src/utils/debug.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/test-storage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/tests/archive.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockState' is assigned a value but never used.","line":45,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Testfall för arkivering av klienter\n * \n * Testar att:\n * 1. Klienter kan arkiveras (sätts archivedAt)\n * 2. Arkiverade klienter filtreras bort från aktiva listor\n * 3. Arkiverade klienter kan återställas (archivedAt tas bort)\n * 4. Historik bevaras för arkiverade klienter\n */\n\nimport { Client, Staff, AppState } from '../src/types';\n\n// Mock data för tester\nconst mockClient: Client = {\n  id: 'client-1',\n  name: 'Test Klient',\n  plan: { carePlanDate: undefined, hasGFP: false, staffNotified: false, notes: \"\" },\n  plans: [],\n  weeklyDocs: {\n    '2024-W01': {\n      weekId: '2024-W01',\n      days: { mon: true, tue: false, wed: true, thu: false, fri: false, sat: false, sun: false },\n      status: 'approved',\n      note: 'Test vecka'\n    }\n  },\n  monthlyReports: {\n    '2024-01': {\n      monthId: '2024-01',\n      sent: true,\n      status: 'approved',\n      note: 'Test månad'\n    }\n  },\n  visma: {},\n  createdAt: '2024-01-01'\n};\n\nconst mockStaff: Staff = {\n  id: 'staff-1',\n  name: 'Test Personal',\n  clients: [mockClient]\n};\n\nconst mockState: AppState = {\n  staff: [mockStaff],\n  selectedStaffId: undefined,\n  selectedClientId: undefined,\n  lastBackup: '2024-01-01T10:00:00.000Z',\n  version: '3.0'\n};\n\ndescribe('Arkivering av klienter', () => {\n  \n  test('1. Klient kan arkiveras (sätts archivedAt)', () => {\n    const now = new Date().toISOString();\n    \n    // Simulera arkivering\n    const archivedClient: Client = {\n      ...mockClient,\n      archivedAt: now\n    };\n    \n    expect(archivedClient.archivedAt).toBeDefined();\n    expect(archivedClient.archivedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    expect(archivedClient.id).toBe(mockClient.id);\n    expect(archivedClient.name).toBe(mockClient.name);\n  });\n\n  test('2. Arkiverade klienter filtreras bort från aktiva listor', () => {\n    const archivedClient: Client = {\n      ...mockClient,\n      archivedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const activeClient: Client = {\n      ...mockClient,\n      id: 'client-2',\n      name: 'Aktiv Klient'\n    };\n    \n    const staffWithMixedClients: Staff = {\n      ...mockStaff,\n      clients: [archivedClient, activeClient]\n    };\n    \n    // Filtrera bort arkiverade klienter\n    const activeClients = staffWithMixedClients.clients.filter(c => !c.archivedAt);\n    \n    expect(activeClients).toHaveLength(1);\n    expect(activeClients[0]?.id).toBe('client-2');\n    expect(activeClients[0]?.name).toBe('Aktiv Klient');\n  });\n\n  test('3. Arkiverade klienter kan återställas (archivedAt tas bort)', () => {\n    const archivedClient: Client = {\n      ...mockClient,\n      archivedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    // Simulera återställning\n    const restoredClient: Client = {\n      ...archivedClient,\n      archivedAt: undefined\n    };\n    \n    expect(restoredClient.archivedAt).toBeUndefined();\n    expect(restoredClient.id).toBe(mockClient.id);\n    expect(restoredClient.name).toBe(mockClient.name);\n    expect(restoredClient.weeklyDocs).toEqual(mockClient.weeklyDocs);\n    expect(restoredClient.monthlyReports).toEqual(mockClient.monthlyReports);\n  });\n\n  test('4. Historik bevaras för arkiverade klienter', () => {\n    const archivedClient: Client = {\n      ...mockClient,\n      archivedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    // Kontrollera att all historik finns kvar\n    expect(archivedClient.weeklyDocs).toEqual(mockClient.weeklyDocs);\n    expect(archivedClient.monthlyReports).toEqual(mockClient.monthlyReports);\n    expect(archivedClient.plans).toEqual(mockClient.plans);\n    expect(archivedClient.visma).toEqual(mockClient.visma);\n    expect(archivedClient.createdAt).toBe(mockClient.createdAt);\n    \n    // Kontrollera specifik historik\n    expect(archivedClient.weeklyDocs['2024-W01']).toBeDefined();\n    expect(archivedClient.weeklyDocs['2024-W01']?.status).toBe('approved');\n    expect(archivedClient.weeklyDocs['2024-W01']?.note).toBe('Test vecka');\n    \n    expect(archivedClient.monthlyReports['2024-01']).toBeDefined();\n    expect(archivedClient.monthlyReports['2024-01']?.status).toBe('approved');\n    expect(archivedClient.monthlyReports['2024-01']?.note).toBe('Test månad');\n  });\n\n  test('Bonus: KPI-beräkningar ignorerar arkiverade klienter', () => {\n    const archivedClient: Client = {\n      ...mockClient,\n      archivedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const activeClient: Client = {\n      ...mockClient,\n      id: 'client-2',\n      name: 'Aktiv Klient',\n      plans: [{\n        id: 'plan-1',\n        title: 'GFP 1',\n        date: '2024-01-01',\n        dueDate: '2024-01-22',\n        note: 'Test plan',\n        staffInformed: true,\n        done: true,\n        status: 'approved'\n      }]\n    };\n    \n    const staffWithMixedClients: Staff = {\n      ...mockStaff,\n      clients: [archivedClient, activeClient]\n    };\n    \n    // Simulera KPI-beräkning (bara aktiva klienter)\n    let totalPlansActive = 0;\n    staffWithMixedClients.clients.forEach(client => {\n      if (client.archivedAt) return; // Skip archived\n      \n      const latestPlan = client.plans[0];\n      if (latestPlan?.done) {\n        totalPlansActive += 1;\n      }\n    });\n    \n    expect(totalPlansActive).toBe(1); // Bara den aktiva klienten räknas\n  });\n});\n\nconsole.log('✅ Alla testfall för arkivering är definierade och redo att köras');\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/tests/history.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'DocStatus' is defined but never used.","line":13,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockHistoryEntry' is assigned a value but never used.","line":16,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'key' is assigned a value but never used.","line":107,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":107,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'archivedClient' is assigned a value but never used.","line":172,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":172,"endColumn":25}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Testfall för historiska KPI som bevaras trots arkivering/borttagning\n * \n * Testar att:\n * 1. HistoryEntry skapas korrekt vid save av vecka/månad/GFP\n * 2. upsertHistory() är idempotent per (periodType,periodId,staffId,clientId,metric)\n * 3. Historik bevaras efter arkivering av klient\n * 4. Historik bevaras efter borttagning av klient\n * 5. Dashboards läser från history för passerade perioder\n * 6. cleanup rör inte us:history\n */\n\nimport { HistoryEntry, DocStatus } from '../src/types';\n\n// Mock data för tester\nconst mockHistoryEntry: HistoryEntry = {\n  id: 'history-1',\n  periodType: 'week',\n  periodId: '2024-W01',\n  staffId: 'staff-1',\n  clientId: 'client-1',\n  metric: 'weekDoc',\n  status: 'approved',\n  value: 3,\n  ts: '2024-01-01T10:00:00.000Z'\n};\n\nconst mockWeekDocEntry: Omit<HistoryEntry, 'id' | 'ts'> = {\n  periodType: 'week',\n  periodId: '2024-W01',\n  staffId: 'staff-1',\n  clientId: 'client-1',\n  metric: 'weekDoc',\n  status: 'approved',\n  value: 3\n};\n\nconst mockMonthReportEntry: Omit<HistoryEntry, 'id' | 'ts'> = {\n  periodType: 'month',\n  periodId: '2024-01',\n  staffId: 'staff-1',\n  clientId: 'client-1',\n  metric: 'monthReport',\n  status: 'approved',\n  value: 1\n};\n\nconst mockGfpEntry: Omit<HistoryEntry, 'id' | 'ts'> = {\n  periodType: 'week',\n  periodId: '2024-W01',\n  staffId: 'staff-1',\n  clientId: 'client-1',\n  metric: 'gfp',\n  status: 'approved',\n  value: 1\n};\n\ndescribe('Historiska KPI', () => {\n  \n  test('1. HistoryEntry skapas korrekt vid save av vecka/månad/GFP', () => {\n    // Test veckodokumentation\n    const weekDocEntry: HistoryEntry = {\n      id: 'test-id',\n      ...mockWeekDocEntry,\n      ts: '2024-01-01T10:00:00.000Z'\n    };\n    \n    expect(weekDocEntry.periodType).toBe('week');\n    expect(weekDocEntry.periodId).toBe('2024-W01');\n    expect(weekDocEntry.metric).toBe('weekDoc');\n    expect(weekDocEntry.status).toBe('approved');\n    expect(weekDocEntry.value).toBe(3);\n    expect(weekDocEntry.ts).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    \n    // Test månadsrapport\n    const monthReportEntry: HistoryEntry = {\n      id: 'test-id-2',\n      ...mockMonthReportEntry,\n      ts: '2024-01-01T10:00:00.000Z'\n    };\n    \n    expect(monthReportEntry.periodType).toBe('month');\n    expect(monthReportEntry.periodId).toBe('2024-01');\n    expect(monthReportEntry.metric).toBe('monthReport');\n    expect(monthReportEntry.status).toBe('approved');\n    expect(monthReportEntry.value).toBe(1);\n    \n    // Test GFP\n    const gfpEntry: HistoryEntry = {\n      id: 'test-id-3',\n      ...mockGfpEntry,\n      ts: '2024-01-01T10:00:00.000Z'\n    };\n    \n    expect(gfpEntry.periodType).toBe('week');\n    expect(gfpEntry.periodId).toBe('2024-W01');\n    expect(gfpEntry.metric).toBe('gfp');\n    expect(gfpEntry.status).toBe('approved');\n    expect(gfpEntry.value).toBe(1);\n  });\n\n  test('2. upsertHistory() är idempotent per (periodType,periodId,staffId,clientId,metric)', () => {\n    // Simulera upsertHistory funktionalitet\n    const history: HistoryEntry[] = [];\n    \n    const upsertEntry = (entry: Omit<HistoryEntry, 'id' | 'ts'>) => {\n      const key = `${entry.periodType}:${entry.periodId}:${entry.staffId}:${entry.clientId}:${entry.metric}`;\n      const existingIndex = history.findIndex(h => \n        h.periodType === entry.periodType &&\n        h.periodId === entry.periodId &&\n        h.staffId === entry.staffId &&\n        h.clientId === entry.clientId &&\n        h.metric === entry.metric\n      );\n      \n      const newEntry: HistoryEntry = {\n        id: existingIndex >= 0 ? history[existingIndex]!.id : crypto.randomUUID(),\n        ...entry,\n        ts: new Date().toISOString()\n      };\n      \n      if (existingIndex >= 0) {\n        history[existingIndex] = newEntry;\n      } else {\n        history.push(newEntry);\n      }\n    };\n    \n    // Första anropet - ska skapa ny entry\n    upsertEntry(mockWeekDocEntry);\n    expect(history).toHaveLength(1);\n    const firstId = history[0]!.id;\n    \n    // Andra anropet med samma data - ska uppdatera befintlig entry\n    upsertEntry({ ...mockWeekDocEntry, status: 'rejected' });\n    expect(history).toHaveLength(1); // Samma antal entries\n    expect(history[0]!.id).toBe(firstId); // Samma ID\n    expect(history[0]!.status).toBe('rejected'); // Uppdaterad status\n    \n    // Tredje anropet med annan metric - ska skapa ny entry\n    upsertEntry({ ...mockWeekDocEntry, metric: 'gfp' });\n    expect(history).toHaveLength(2); // Ny entry skapad\n  });\n\n  test('3. Historik bevaras efter arkivering av klient', () => {\n    const history: HistoryEntry[] = [\n      {\n        id: 'history-1',\n        periodType: 'week',\n        periodId: '2024-W01',\n        staffId: 'staff-1',\n        clientId: 'client-1',\n        metric: 'weekDoc',\n        status: 'approved',\n        value: 3,\n        ts: '2024-01-01T10:00:00.000Z'\n      },\n      {\n        id: 'history-2',\n        periodType: 'month',\n        periodId: '2024-01',\n        staffId: 'staff-1',\n        clientId: 'client-1',\n        metric: 'monthReport',\n        status: 'approved',\n        value: 1,\n        ts: '2024-01-01T10:00:00.000Z'\n      }\n    ];\n    \n    // Simulera arkivering av klient (sätt archivedAt)\n    const archivedClient = {\n      id: 'client-1',\n      name: 'Test Klient',\n      archivedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    // Historik ska fortfarande finnas kvar\n    const clientHistory = history.filter(h => h.clientId === 'client-1');\n    expect(clientHistory).toHaveLength(2);\n    expect(clientHistory[0]?.status).toBe('approved');\n    expect(clientHistory[1]?.status).toBe('approved');\n    \n    // Historik ska vara tillgänglig för dashboards\n    const weekHistory = history.filter(h => h.periodType === 'week' && h.periodId === '2024-W01');\n    expect(weekHistory).toHaveLength(1);\n    expect(weekHistory[0]?.metric).toBe('weekDoc');\n  });\n\n  test('4. Historik bevaras efter borttagning av klient', () => {\n    const history: HistoryEntry[] = [\n      {\n        id: 'history-1',\n        periodType: 'week',\n        periodId: '2024-W01',\n        staffId: 'staff-1',\n        clientId: 'client-1',\n        metric: 'weekDoc',\n        status: 'approved',\n        value: 3,\n        ts: '2024-01-01T10:00:00.000Z'\n      },\n      {\n        id: 'history-2',\n        periodType: 'week',\n        periodId: '2024-W02',\n        staffId: 'staff-1',\n        clientId: 'client-2',\n        metric: 'weekDoc',\n        status: 'approved',\n        value: 2,\n        ts: '2024-01-08T10:00:00.000Z'\n      }\n    ];\n    \n    // Simulera borttagning av client-1\n    const remainingHistory = history; // Historik bevaras i localStorage\n    \n    // Historik för borttagen klient ska fortfarande finnas\n    const deletedClientHistory = remainingHistory.filter(h => h.clientId === 'client-1');\n    expect(deletedClientHistory).toHaveLength(1);\n    expect(deletedClientHistory[0]?.periodId).toBe('2024-W01');\n    \n    // Historik för kvarvarande klient ska också finnas\n    const remainingClientHistory = remainingHistory.filter(h => h.clientId === 'client-2');\n    expect(remainingClientHistory).toHaveLength(1);\n    expect(remainingClientHistory[0]?.periodId).toBe('2024-W02');\n  });\n\n  test('5. Dashboards läser från history för passerade perioder', () => {\n    const history: HistoryEntry[] = [\n      // Passerade veckor (från arkiverade/borttagna klienter)\n      {\n        id: 'history-1',\n        periodType: 'week',\n        periodId: '2024-W01',\n        staffId: 'staff-1',\n        clientId: 'archived-client-1',\n        metric: 'weekDoc',\n        status: 'approved',\n        value: 3,\n        ts: '2024-01-01T10:00:00.000Z'\n      },\n      {\n        id: 'history-2',\n        periodType: 'week',\n        periodId: '2024-W02',\n        staffId: 'staff-1',\n        clientId: 'deleted-client-1',\n        metric: 'weekDoc',\n        status: 'approved',\n        value: 2,\n        ts: '2024-01-08T10:00:00.000Z'\n      },\n      // Nuvarande vecka (från aktiva klienter)\n      {\n        id: 'history-3',\n        periodType: 'week',\n        periodId: '2024-W03',\n        staffId: 'staff-1',\n        clientId: 'active-client-1',\n        metric: 'weekDoc',\n        status: 'approved',\n        value: 4,\n        ts: '2024-01-15T10:00:00.000Z'\n      }\n    ];\n    \n    const currentWeek = '2024-W03';\n    \n    // Simulera dashboard-beräkning\n    const pastWeeks = history.filter(h => \n      h.periodType === 'week' && \n      h.metric === 'weekDoc' && \n      h.status === 'approved' &&\n      h.periodId < currentWeek // Passerade veckor\n    );\n    \n    const currentWeekData = history.filter(h => \n      h.periodType === 'week' && \n      h.metric === 'weekDoc' && \n      h.status === 'approved' &&\n      h.periodId === currentWeek // Nuvarande vecka\n    );\n    \n    // Passerade veckor ska inkludera data från arkiverade/borttagna klienter\n    expect(pastWeeks).toHaveLength(2);\n    expect(pastWeeks.some(h => h.clientId === 'archived-client-1')).toBe(true);\n    expect(pastWeeks.some(h => h.clientId === 'deleted-client-1')).toBe(true);\n    \n    // Nuvarande vecka ska inkludera data från aktiva klienter\n    expect(currentWeekData).toHaveLength(1);\n    expect(currentWeekData[0]?.clientId).toBe('active-client-1');\n    \n    // Aggregerad data för sparkline\n    const weeklyByWeek: Record<string, number> = {};\n    [...pastWeeks, ...currentWeekData].forEach(entry => {\n      weeklyByWeek[entry.periodId] = (weeklyByWeek[entry.periodId] || 0) + 1;\n    });\n    \n    expect(weeklyByWeek['2024-W01']).toBe(1);\n    expect(weeklyByWeek['2024-W02']).toBe(1);\n    expect(weeklyByWeek['2024-W03']).toBe(1);\n  });\n\n  test('6. cleanup rör inte us:history', () => {\n    const mockLocalStorage = {\n      'us:client-1:weekly:2024-W01': '{\"weekId\":\"2024-W01\",\"status\":\"approved\"}',\n      'us:client-2:monthly:2024-01': '{\"monthId\":\"2024-01\",\"status\":\"approved\"}',\n      'us:history': JSON.stringify([\n        {\n          id: 'history-1',\n          periodType: 'week',\n          periodId: '2024-W01',\n          staffId: 'staff-1',\n          clientId: 'client-1',\n          metric: 'weekDoc',\n          status: 'approved',\n          value: 3,\n          ts: '2024-01-01T10:00:00.000Z'\n        }\n      ]),\n      'other-key': 'some-data'\n    };\n    \n    // Simulera cleanup-funktion\n    const cleanup = (allClientIds: Set<string>) => {\n      const keysToRemove: string[] = [];\n      const PERIOD_DATA_PREFIX = 'us:';\n      const HISTORY_KEY = 'us:history';\n      \n      Object.keys(mockLocalStorage).forEach(key => {\n        if (key.startsWith(PERIOD_DATA_PREFIX) && key !== HISTORY_KEY) {\n          const parts = key.split(':');\n          if (parts.length >= 2 && parts[1]) {\n            const clientId = parts[1];\n            if (!allClientIds.has(clientId)) {\n              keysToRemove.push(key);\n            }\n          }\n        }\n      });\n      \n      // Remove orphaned keys (but NEVER touch us:history)\n      keysToRemove.forEach(key => {\n        if (key !== HISTORY_KEY) { // Extra safety check\n          delete mockLocalStorage[key];\n        }\n      });\n      \n      return keysToRemove;\n    };\n    \n    // Test med client-1 som inte finns längre\n    const allClientIds = new Set(['client-3']); // client-1 och client-2 finns inte\n    const removedKeys = cleanup(allClientIds);\n    \n    // Perioddata för client-1 och client-2 ska tas bort\n    expect(removedKeys).toContain('us:client-1:weekly:2024-W01');\n    expect(removedKeys).toContain('us:client-2:monthly:2024-01');\n    expect(mockLocalStorage['us:client-1:weekly:2024-W01']).toBeUndefined();\n    expect(mockLocalStorage['us:client-2:monthly:2024-01']).toBeUndefined();\n    \n    // us:history ska ALDRIG tas bort\n    expect(removedKeys).not.toContain('us:history');\n    expect(mockLocalStorage['us:history']).toBeDefined();\n    expect(mockLocalStorage['us:history']).toContain('history-1');\n    \n    // other-key ska inte påverkas\n    expect(mockLocalStorage['other-key']).toBe('some-data');\n  });\n});\n\nconsole.log('✅ Alla 6 testfall för historiska KPI är definierade och redo att köras');\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/tests/idempotency.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'beforeAll' is defined but never used.","line":6,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'afterAll' is defined but never used.","line":6,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'result' is assigned a value but never used.","line":151,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":151,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'hash2' is assigned a value but never used.","line":244,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":244,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9582,9585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9582,9585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Idempotency Tests\n * Tests for API idempotency functionality\n */\n\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { \n  generateIdempotencyKey,\n  generateRequestHash,\n  checkIdempotencyKey,\n  storeIdempotencyKey,\n  storePendingIdempotencyKey,\n  completeIdempotencyKey,\n  cleanupExpiredIdempotencyKeys,\n  isValidIdempotencyKey,\n  getIdempotencyStats\n} from '../server/utils/idempotency.js';\n\ndescribe('Idempotency Utilities', () => {\n  \n  describe('Key Generation', () => {\n    it('should generate unique idempotency keys', () => {\n      const key1 = generateIdempotencyKey();\n      const key2 = generateIdempotencyKey();\n      \n      expect(key1).not.toBe(key2);\n      expect(key1).toMatch(/^idem_[a-f0-9-]{36}$/);\n      expect(key2).toMatch(/^idem_[a-f0-9-]{36}$/);\n    });\n\n    it('should generate deterministic request hashes', () => {\n      const requestBody = { name: 'test', value: 123 };\n      const userId = 'user123';\n      \n      const hash1 = generateRequestHash(requestBody, userId);\n      const hash2 = generateRequestHash(requestBody, userId);\n      \n      expect(hash1).toBe(hash2);\n      expect(hash1).toHaveLength(64); // SHA256 hex length\n    });\n\n    it('should generate different hashes for different requests', () => {\n      const requestBody1 = { name: 'test1' };\n      const requestBody2 = { name: 'test2' };\n      const userId = 'user123';\n      \n      const hash1 = generateRequestHash(requestBody1, userId);\n      const hash2 = generateRequestHash(requestBody2, userId);\n      \n      expect(hash1).not.toBe(hash2);\n    });\n\n    it('should generate different hashes for different users', () => {\n      const requestBody = { name: 'test' };\n      const userId1 = 'user1';\n      const userId2 = 'user2';\n      \n      const hash1 = generateRequestHash(requestBody, userId1);\n      const hash2 = generateRequestHash(requestBody, userId2);\n      \n      expect(hash1).not.toBe(hash2);\n    });\n  });\n\n  describe('Key Validation', () => {\n    it('should validate correct idempotency key formats', () => {\n      expect(isValidIdempotencyKey('idem_12345678-1234-1234-1234-123456789abc')).toBe(true);\n      expect(isValidIdempotencyKey('req_1234567890abcdef')).toBe(true);\n      expect(isValidIdempotencyKey('test-key_123')).toBe(true);\n    });\n\n    it('should reject invalid idempotency key formats', () => {\n      expect(isValidIdempotencyKey('')).toBe(false);\n      expect(isValidIdempotencyKey('123')).toBe(false); // Too short\n      expect(isValidIdempotencyKey('a'.repeat(65))).toBe(false); // Too long\n      expect(isValidIdempotencyKey('invalid@key')).toBe(false); // Invalid characters\n      expect(isValidIdempotencyKey('key with spaces')).toBe(false); // Spaces\n    });\n  });\n\n  describe('Key Storage and Retrieval', () => {\n    const testKey = 'test-idempotency-key-123';\n    const testOperation = 'POST /api/test';\n    const testRequestHash = 'test-hash-123';\n    const testResponse = { success: true, data: { id: 'test-id' } };\n\n    it('should store and retrieve idempotency key', () => {\n      // Store key\n      storeIdempotencyKey(testKey, testOperation, testRequestHash, testResponse);\n      \n      // Retrieve key\n      const retrieved = checkIdempotencyKey(testKey);\n      \n      expect(retrieved).not.toBeNull();\n      expect(retrieved!.key).toBe(testKey);\n      expect(retrieved!.operation).toBe(testOperation);\n      expect(retrieved!.request_hash).toBe(testRequestHash);\n      expect(retrieved!.response).toBe(JSON.stringify(testResponse));\n    });\n\n    it('should return null for non-existent key', () => {\n      const nonExistentKey = 'non-existent-key';\n      const result = checkIdempotencyKey(nonExistentKey);\n      \n      expect(result).toBeNull();\n    });\n\n    it('should store pending idempotency key', () => {\n      const pendingKey = 'pending-test-key';\n      \n      storePendingIdempotencyKey(pendingKey, testOperation, testRequestHash);\n      \n      const retrieved = checkIdempotencyKey(pendingKey);\n      \n      expect(retrieved).not.toBeNull();\n      expect(retrieved!.key).toBe(pendingKey);\n      expect(retrieved!.operation).toBe(testOperation);\n      expect(retrieved!.request_hash).toBe(testRequestHash);\n      expect(retrieved!.response).toBeNull();\n    });\n\n    it('should complete pending idempotency key', () => {\n      const pendingKey = 'complete-test-key';\n      \n      // Store pending\n      storePendingIdempotencyKey(pendingKey, testOperation, testRequestHash);\n      \n      // Complete with response\n      completeIdempotencyKey(pendingKey, testResponse);\n      \n      const retrieved = checkIdempotencyKey(pendingKey);\n      \n      expect(retrieved).not.toBeNull();\n      expect(retrieved!.response).toBe(JSON.stringify(testResponse));\n    });\n  });\n\n  describe('Key Expiration', () => {\n    it('should handle expired keys correctly', () => {\n      const expiredKey = 'expired-test-key';\n      \n      // Store key with immediate expiration\n      const now = new Date();\n      now.setSeconds(now.getSeconds() - 1); // 1 second ago\n      \n      // This would require modifying the function to accept custom expiry\n      // For now, we'll test that cleanup works\n      cleanupExpiredIdempotencyKeys();\n      \n      // The key should not be retrievable after cleanup\n      const result = checkIdempotencyKey(expiredKey);\n      // Note: This test might pass or fail depending on timing\n      // The important thing is that cleanup doesn't throw errors\n    });\n  });\n\n  describe('Statistics', () => {\n    it('should return idempotency statistics', () => {\n      const stats = getIdempotencyStats();\n      \n      expect(stats).toHaveProperty('total');\n      expect(stats).toHaveProperty('expired');\n      expect(stats).toHaveProperty('pending');\n      expect(stats).toHaveProperty('completed');\n      \n      expect(typeof stats.total).toBe('number');\n      expect(typeof stats.expired).toBe('number');\n      expect(typeof stats.pending).toBe('number');\n      expect(typeof stats.completed).toBe('number');\n      \n      expect(stats.total).toBeGreaterThanOrEqual(0);\n      expect(stats.expired).toBeGreaterThanOrEqual(0);\n      expect(stats.pending).toBeGreaterThanOrEqual(0);\n      expect(stats.completed).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Integration Tests', () => {\n    it('should handle complete idempotency workflow', () => {\n      const key = generateIdempotencyKey();\n      const operation = 'POST /api/clients';\n      const requestBody = { name: 'Test Client' };\n      const requestHash = generateRequestHash(requestBody);\n      const response = { success: true, data: { id: 'client-123' } };\n      \n      // 1. Check key doesn't exist\n      expect(checkIdempotencyKey(key)).toBeNull();\n      \n      // 2. Store pending operation\n      storePendingIdempotencyKey(key, operation, requestHash);\n      \n      // 3. Check pending key exists\n      const pending = checkIdempotencyKey(key);\n      expect(pending).not.toBeNull();\n      expect(pending!.response).toBeNull();\n      \n      // 4. Complete operation\n      completeIdempotencyKey(key, response);\n      \n      // 5. Check completed key\n      const completed = checkIdempotencyKey(key);\n      expect(completed).not.toBeNull();\n      expect(completed!.response).toBe(JSON.stringify(response));\n      \n      // 6. Verify same key returns same response\n      const retrieved = checkIdempotencyKey(key);\n      expect(retrieved).not.toBeNull();\n      expect(retrieved!.response).toBe(JSON.stringify(response));\n    });\n\n    it('should handle duplicate request detection', () => {\n      const key = generateIdempotencyKey();\n      const operation = 'POST /api/test';\n      const requestBody = { value: 'test' };\n      const requestHash = generateRequestHash(requestBody);\n      const response = { success: true, data: { id: 'test-123' } };\n      \n      // First request\n      storeIdempotencyKey(key, operation, requestHash, response);\n      \n      // Simulate duplicate request with same hash\n      const duplicateHash = generateRequestHash(requestBody);\n      expect(duplicateHash).toBe(requestHash); // Should be identical\n      \n      // Should retrieve existing response\n      const existing = checkIdempotencyKey(key);\n      expect(existing).not.toBeNull();\n      expect(existing!.response).toBe(JSON.stringify(response));\n    });\n\n    it('should handle different requests with same key (should not happen in practice)', () => {\n      const key = 'same-key-different-requests';\n      const operation = 'POST /api/test';\n      \n      // First request\n      const request1 = { name: 'request1' };\n      const hash1 = generateRequestHash(request1);\n      const response1 = { success: true, data: { id: '1' } };\n      \n      storeIdempotencyKey(key, operation, hash1, response1);\n      \n      // Second request with different content but same key\n      const request2 = { name: 'request2' };\n      const hash2 = generateRequestHash(request2);\n      \n      // Should retrieve first response (idempotency key takes precedence)\n      const retrieved = checkIdempotencyKey(key);\n      expect(retrieved).not.toBeNull();\n      expect(retrieved!.request_hash).toBe(hash1); // Should be first hash\n      expect(retrieved!.response).toBe(JSON.stringify(response1)); // Should be first response\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle invalid JSON in responses gracefully', () => {\n      const key = 'invalid-json-test';\n      const operation = 'POST /api/test';\n      const requestHash = 'test-hash';\n      \n      // Store with invalid JSON (circular reference)\n      const circularObj: any = {};\n      circularObj.self = circularObj;\n      \n      expect(() => {\n        storeIdempotencyKey(key, operation, requestHash, circularObj);\n      }).toThrow();\n    });\n\n    it('should handle null and undefined responses', () => {\n      const key = 'null-response-test';\n      const operation = 'POST /api/test';\n      const requestHash = 'test-hash';\n      \n      // Should handle null response\n      expect(() => {\n        storeIdempotencyKey(key, operation, requestHash, null);\n      }).not.toThrow();\n      \n      const retrieved = checkIdempotencyKey(key);\n      expect(retrieved).not.toBeNull();\n      expect(retrieved!.response).toBe('null');\n    });\n  });\n\n  describe('Performance Tests', () => {\n    it('should handle multiple concurrent operations', () => {\n      const operations = Array.from({ length: 100 }, (_, i) => {\n        const key = `perf-test-${i}`;\n        const operation = `POST /api/test/${i}`;\n        const requestHash = `hash-${i}`;\n        const response = { success: true, data: { id: i } };\n        \n        return { key, operation, requestHash, response };\n      });\n      \n      // Store all operations\n      operations.forEach(op => {\n        storeIdempotencyKey(op.key, op.operation, op.requestHash, op.response);\n      });\n      \n      // Retrieve all operations\n      operations.forEach(op => {\n        const retrieved = checkIdempotencyKey(op.key);\n        expect(retrieved).not.toBeNull();\n        expect(retrieved!.response).toBe(JSON.stringify(op.response));\n      });\n    });\n\n    it('should handle cleanup efficiently', () => {\n      // Create many keys\n      for (let i = 0; i < 50; i++) {\n        const key = `cleanup-test-${i}`;\n        storeIdempotencyKey(key, 'POST /api/test', 'test-hash', { id: i });\n      }\n      \n      // Cleanup should complete without errors\n      expect(() => {\n        cleanupExpiredIdempotencyKeys();\n      }).not.toThrow();\n    });\n  });\n});\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/tests/retention-cleanup.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1119,1122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1119,1122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test cases for retention cleanup functionality\n */\n\nimport { describe, it, expect } from 'vitest';\n\n// Mock app state for testing\ninterface TestClient {\n  id: string;\n  name: string;\n  archivedAt?: string;\n  deletedAt?: string;\n  plans: TestPlan[];\n  weeklyDocs: Record<string, TestWeeklyDoc>;\n  monthlyReports: Record<string, TestMonthlyReport>;\n  visma: Record<string, TestVismaWeek>;\n}\n\ninterface TestPlan {\n  id: string;\n  title: string;\n  deletedAt?: string;\n}\n\ninterface TestWeeklyDoc {\n  weekId: string;\n  deletedAt?: string;\n}\n\ninterface TestMonthlyReport {\n  monthId: string;\n  deletedAt?: string;\n}\n\ninterface TestVismaWeek {\n  weekId: string;\n  deletedAt?: string;\n}\n\ninterface TestStaff {\n  id: string;\n  name: string;\n  clients: TestClient[];\n}\n\n// Mock implementation of retentionSweep function\nfunction mockRetentionSweep(cutoffDays: number, staff: TestStaff[]) {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - cutoffDays);\n  const cutoffISO = cutoffDate.toISOString();\n  \n  const toRemove: Array<{ type: string; id: string; staffId: string; clientId?: string; data: any; deletedAt: string }> = [];\n  \n  staff.forEach(staffMember => {\n    staffMember.clients.forEach(client => {\n      // Check client-level deletion/archiving\n      if (client.archivedAt && client.archivedAt < cutoffISO) {\n        toRemove.push({\n          type: 'client',\n          id: client.id,\n          staffId: staffMember.id,\n          clientId: client.id,\n          data: client,\n          deletedAt: client.archivedAt\n        });\n      } else if (client.deletedAt && client.deletedAt < cutoffISO) {\n        toRemove.push({\n          type: 'client',\n          id: client.id,\n          staffId: staffMember.id,\n          clientId: client.id,\n          data: client,\n          deletedAt: client.deletedAt\n        });\n      } else {\n        // Check individual items within active clients\n        client.plans.forEach(plan => {\n          if (plan.deletedAt && plan.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'plan',\n              id: plan.id,\n              staffId: staffMember.id,\n              clientId: client.id,\n              data: plan,\n              deletedAt: plan.deletedAt\n            });\n          }\n        });\n        \n        Object.values(client.weeklyDocs).forEach(doc => {\n          if (doc.deletedAt && doc.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'weeklyDoc',\n              id: doc.weekId,\n              staffId: staffMember.id,\n              clientId: client.id,\n              data: doc,\n              deletedAt: doc.deletedAt\n            });\n          }\n        });\n        \n        Object.values(client.monthlyReports).forEach(report => {\n          if (report.deletedAt && report.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'monthlyReport',\n              id: report.monthId,\n              staffId: staffMember.id,\n              clientId: client.id,\n              data: report,\n              deletedAt: report.deletedAt\n            });\n          }\n        });\n        \n        Object.values(client.visma).forEach(visma => {\n          if (visma.deletedAt && visma.deletedAt < cutoffISO) {\n            toRemove.push({\n              type: 'vismaWeek',\n              id: visma.weekId,\n              staffId: staffMember.id,\n              clientId: client.id,\n              data: visma,\n              deletedAt: visma.deletedAt\n            });\n          }\n        });\n      }\n    });\n  });\n  \n  return { toRemove, cutoffDate: cutoffISO };\n}\n\n// Test data\nconst createTestData = () => {\n  const oldDate = new Date();\n  oldDate.setDate(oldDate.getDate() - 200); // 200 days ago\n  \n  const recentDate = new Date();\n  recentDate.setDate(recentDate.getDate() - 50); // 50 days ago\n  \n  return [\n    {\n      id: 'staff1',\n      name: 'Anna Andersson',\n      clients: [\n        {\n          id: 'client1',\n          name: 'Klient A',\n          archivedAt: oldDate.toISOString(), // Old archived client\n          plans: [],\n          weeklyDocs: {},\n          monthlyReports: {},\n          visma: {}\n        },\n        {\n          id: 'client2',\n          name: 'Klient B',\n          deletedAt: recentDate.toISOString(), // Recent soft-deleted client\n          plans: [],\n          weeklyDocs: {},\n          monthlyReports: {},\n          visma: {}\n        },\n        {\n          id: 'client3',\n          name: 'Klient C',\n          plans: [\n            {\n              id: 'plan1',\n              title: 'Gammal plan',\n              deletedAt: oldDate.toISOString() // Old deleted plan\n            },\n            {\n              id: 'plan2',\n              title: 'Ny plan',\n              deletedAt: recentDate.toISOString() // Recent deleted plan\n            }\n          ],\n          weeklyDocs: {\n            '2024-W10': {\n              weekId: '2024-W10',\n              deletedAt: oldDate.toISOString() // Old deleted doc\n            },\n            '2024-W30': {\n              weekId: '2024-W30',\n              deletedAt: recentDate.toISOString() // Recent deleted doc\n            }\n          },\n          monthlyReports: {\n            '2024-03': {\n              monthId: '2024-03',\n              deletedAt: oldDate.toISOString() // Old deleted report\n            }\n          },\n          visma: {\n            '2024-W11': {\n              weekId: '2024-W11',\n              deletedAt: oldDate.toISOString() // Old deleted visma\n            }\n          }\n        }\n      ]\n    }\n  ];\n};\n\ndescribe('Retention Cleanup', () => {\n  \n  it('Test 1: Should identify old archived/deleted items correctly', () => {\n    const testData = createTestData();\n    const result = mockRetentionSweep(180, testData); // 180 days cutoff\n    \n    // Should find 4 old items: 1 client, 1 plan, 1 weekly doc, 1 monthly report, 1 visma week\n    expect(result.toRemove).toHaveLength(5);\n    \n    // Check that old client is included\n    const oldClient = result.toRemove.find(item => item.type === 'client' && item.id === 'client1');\n    expect(oldClient).toBeDefined();\n    \n    // Check that recent client is NOT included\n    const recentClient = result.toRemove.find(item => item.type === 'client' && item.id === 'client2');\n    expect(recentClient).toBeUndefined();\n    \n    // Check that old plan is included but recent plan is not\n    const oldPlan = result.toRemove.find(item => item.type === 'plan' && item.id === 'plan1');\n    const recentPlan = result.toRemove.find(item => item.type === 'plan' && item.id === 'plan2');\n    expect(oldPlan).toBeDefined();\n    expect(recentPlan).toBeUndefined();\n  });\n\n  it('Test 2: Should return empty result when no old items exist', () => {\n    const testData = [{\n      id: 'staff1',\n      name: 'Anna Andersson',\n      clients: [{\n        id: 'client1',\n        name: 'Klient A',\n        deletedAt: new Date().toISOString(), // Today\n        plans: [],\n        weeklyDocs: {},\n        monthlyReports: {},\n        visma: {}\n      }]\n    }];\n    \n    const result = mockRetentionSweep(180, testData);\n    expect(result.toRemove).toHaveLength(0);\n  });\n\n  it('Test 3: Should handle different retention periods correctly', () => {\n    const testData = createTestData();\n    \n    // Test with 100 days - should find old items (200 days old)\n    const result100 = mockRetentionSweep(100, testData);\n    expect(result100.toRemove.length).toBeGreaterThan(0);\n    \n    // Test with 300 days - should find nothing (oldest is 200 days)\n    const result300 = mockRetentionSweep(300, testData);\n    expect(result300.toRemove).toHaveLength(0);\n    \n    // Test with 60 days - should find both old and recent items\n    const result60 = mockRetentionSweep(60, testData);\n    expect(result60.toRemove.length).toBeGreaterThan(result100.toRemove.length);\n  });\n\n  it('Test 4: Should preserve data structure for export', () => {\n    const testData = createTestData();\n    const result = mockRetentionSweep(180, testData);\n    \n    // Check that export data structure is correct\n    const exportData = result.toRemove.map(item => ({\n      type: item.type,\n      id: item.id,\n      staffId: item.staffId,\n      clientId: item.clientId,\n      deletedAt: item.deletedAt,\n      data: JSON.stringify(item.data)\n    }));\n    \n    expect(exportData).toHaveLength(result.toRemove.length);\n    \n    // Verify each export item has required fields\n    exportData.forEach(item => {\n      expect(item.type).toBeDefined();\n      expect(item.id).toBeDefined();\n      expect(item.staffId).toBeDefined();\n      expect(item.deletedAt).toBeDefined();\n      expect(item.data).toBeDefined();\n      expect(typeof item.data).toBe('string'); // Should be JSON string\n    });\n  });\n\n  it('Test 5: Should categorize items correctly for impact summary', () => {\n    const testData = createTestData();\n    const result = mockRetentionSweep(180, testData);\n    \n    // Count items by type\n    const clientCount = result.toRemove.filter(item => item.type === 'client').length;\n    const planCount = result.toRemove.filter(item => item.type === 'plan').length;\n    const weeklyDocCount = result.toRemove.filter(item => item.type === 'weeklyDoc').length;\n    const monthlyReportCount = result.toRemove.filter(item => item.type === 'monthlyReport').length;\n    const vismaWeekCount = result.toRemove.filter(item => item.type === 'vismaWeek').length;\n    \n    // Verify expected counts based on test data\n    expect(clientCount).toBe(1); // 1 old archived client\n    expect(planCount).toBe(1); // 1 old deleted plan\n    expect(weeklyDocCount).toBe(1); // 1 old deleted weekly doc\n    expect(monthlyReportCount).toBe(1); // 1 old deleted monthly report\n    expect(vismaWeekCount).toBe(1); // 1 old deleted visma week\n    \n    // Total should match\n    expect(clientCount + planCount + weeklyDocCount + monthlyReportCount + vismaWeekCount).toBe(result.toRemove.length);\n    \n    // Create impact summary\n    const impactSummary = `Rensar ${clientCount} klienter, ${planCount} planer, ${weeklyDocCount} veckorapporter, ${monthlyReportCount} månadsrapporter, ${vismaWeekCount} Visma-veckor`;\n    expect(impactSummary).toContain('1 klienter');\n    expect(impactSummary).toContain('1 planer');\n    expect(impactSummary).toContain('1 veckorapporter');\n    expect(impactSummary).toContain('1 månadsrapporter');\n    expect(impactSummary).toContain('1 Visma-veckor');\n  });\n\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/tests/soft-delete.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'softDeletedClient' is assigned a value but never used.","line":211,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":211,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Testfall för mjuk-radering via deletedAt\n * \n * Testar att:\n * 1. Alla entiteter får deletedAt?: string\n * 2. UI/KPI filtrerar bort deletedAt != null i \"nuet\"\n * 3. Historik (us:history) lämnas orörd\n * 4. Återställning möjlig för soft-deleted poster (ta bort deletedAt)\n */\n\nimport { Client, GFPPlan, WeeklyDoc, MonthlyReport, VismaWeek, Plan } from '../src/types';\n\n// Mock data för tester\nconst mockClient: Client = {\n  id: 'client-1',\n  name: 'Test Klient',\n  plan: { carePlanDate: undefined, hasGFP: false, staffNotified: false, notes: \"\" },\n  plans: [],\n  weeklyDocs: {},\n  monthlyReports: {},\n  visma: {},\n  createdAt: '2024-01-01'\n};\n\nconst mockGfpPlan: GFPPlan = {\n  id: 'plan-1',\n  title: 'GFP 1',\n  date: '2024-01-01',\n  dueDate: '2024-01-22',\n  note: 'Test plan',\n  staffInformed: true,\n  done: true,\n  status: 'approved'\n};\n\nconst mockWeeklyDoc: WeeklyDoc = {\n  weekId: '2024-W01',\n  days: { mon: true, tue: false, wed: true, thu: false, fri: false, sat: false, sun: false },\n  status: 'approved',\n  note: 'Test vecka'\n};\n\nconst mockMonthlyReport: MonthlyReport = {\n  monthId: '2024-01',\n  sent: true,\n  status: 'approved',\n  note: 'Test månad'\n};\n\nconst mockVismaWeek: VismaWeek = {\n  weekId: '2024-W01',\n  days: { mon: true, tue: false, wed: true, thu: false, fri: false },\n  status: 'approved'\n};\n\nconst mockPlan: Plan = {\n  carePlanDate: '2024-01-01',\n  hasGFP: true,\n  staffNotified: true,\n  notes: 'Test plan',\n  lastUpdated: '2024-01-01T10:00:00.000Z'\n};\n\ndescribe('Mjuk-radering via deletedAt', () => {\n  \n  test('1. Alla entiteter får deletedAt?: string', () => {\n    // Test Client\n    const clientWithDeletedAt: Client = {\n      ...mockClient,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    expect(clientWithDeletedAt.deletedAt).toBeDefined();\n    expect(clientWithDeletedAt.deletedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    \n    // Test GFPPlan\n    const gfpPlanWithDeletedAt: GFPPlan = {\n      ...mockGfpPlan,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    expect(gfpPlanWithDeletedAt.deletedAt).toBeDefined();\n    expect(gfpPlanWithDeletedAt.deletedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    \n    // Test WeeklyDoc\n    const weeklyDocWithDeletedAt: WeeklyDoc = {\n      ...mockWeeklyDoc,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    expect(weeklyDocWithDeletedAt.deletedAt).toBeDefined();\n    expect(weeklyDocWithDeletedAt.deletedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    \n    // Test MonthlyReport\n    const monthlyReportWithDeletedAt: MonthlyReport = {\n      ...mockMonthlyReport,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    expect(monthlyReportWithDeletedAt.deletedAt).toBeDefined();\n    expect(monthlyReportWithDeletedAt.deletedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    \n    // Test VismaWeek\n    const vismaWeekWithDeletedAt: VismaWeek = {\n      ...mockVismaWeek,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    expect(vismaWeekWithDeletedAt.deletedAt).toBeDefined();\n    expect(vismaWeekWithDeletedAt.deletedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    \n    // Test Plan\n    const planWithDeletedAt: Plan = {\n      ...mockPlan,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    expect(planWithDeletedAt.deletedAt).toBeDefined();\n    expect(planWithDeletedAt.deletedAt).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n  });\n\n  test('2. UI/KPI filtrerar bort deletedAt != null i \"nuet\"', () => {\n    const activeClient: Client = {\n      ...mockClient,\n      id: 'client-1',\n      name: 'Aktiv Klient'\n    };\n    \n    const softDeletedClient: Client = {\n      ...mockClient,\n      id: 'client-2',\n      name: 'Borttagen Klient',\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const archivedClient: Client = {\n      ...mockClient,\n      id: 'client-3',\n      name: 'Arkiverad Klient',\n      archivedAt: '2024-01-10T10:00:00.000Z'\n    };\n    \n    const clients = [activeClient, softDeletedClient, archivedClient];\n    \n    // Simulera UI-filtrering för aktiva klienter\n    const activeClients = clients.filter(c => !c.archivedAt && !c.deletedAt);\n    expect(activeClients).toHaveLength(1);\n    expect(activeClients[0]?.id).toBe('client-1');\n    expect(activeClients[0]?.name).toBe('Aktiv Klient');\n    \n    // Simulera KPI-beräkning (bara aktiva klienter)\n    let totalActiveClients = 0;\n    clients.forEach(client => {\n      if (!client.archivedAt && !client.deletedAt) {\n        totalActiveClients += 1;\n      }\n    });\n    \n    expect(totalActiveClients).toBe(1);\n    \n    // Test GFP-planer filtrering\n    const activePlan: GFPPlan = {\n      ...mockGfpPlan,\n      id: 'plan-1',\n      title: 'Aktiv Plan'\n    };\n    \n    const softDeletedPlan: GFPPlan = {\n      ...mockGfpPlan,\n      id: 'plan-2',\n      title: 'Borttagen Plan',\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const plans = [activePlan, softDeletedPlan];\n    const activePlans = plans.filter(p => !p.deletedAt);\n    \n    expect(activePlans).toHaveLength(1);\n    expect(activePlans[0]?.id).toBe('plan-1');\n    expect(activePlans[0]?.title).toBe('Aktiv Plan');\n  });\n\n  test('3. Historik (us:history) lämnas orörd', () => {\n    // Simulera history-data\n    const mockHistory = [\n      {\n        id: 'history-1',\n        periodType: 'week' as const,\n        periodId: '2024-W01',\n        staffId: 'staff-1',\n        clientId: 'client-1',\n        metric: 'weekDoc' as const,\n        status: 'approved' as const,\n        value: 3,\n        ts: '2024-01-01T10:00:00.000Z'\n      },\n      {\n        id: 'history-2',\n        periodType: 'month' as const,\n        periodId: '2024-01',\n        staffId: 'staff-1',\n        clientId: 'client-2',\n        metric: 'monthReport' as const,\n        status: 'approved' as const,\n        value: 1,\n        ts: '2024-01-01T10:00:00.000Z'\n      }\n    ];\n    \n    // Simulera mjuk-radering av klient\n    const softDeletedClient: Client = {\n      ...mockClient,\n      id: 'client-1',\n      name: 'Borttagen Klient',\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    // Historik ska fortfarande finnas kvar\n    const clientHistory = mockHistory.filter(h => h.clientId === 'client-1');\n    expect(clientHistory).toHaveLength(1);\n    expect(clientHistory[0]?.status).toBe('approved');\n    expect(clientHistory[0]?.value).toBe(3);\n    \n    // Historik ska vara tillgänglig för dashboards\n    const weekHistory = mockHistory.filter(h => h.periodType === 'week' && h.periodId === '2024-W01');\n    expect(weekHistory).toHaveLength(1);\n    expect(weekHistory[0]?.metric).toBe('weekDoc');\n    \n    // Historik ska inte påverkas av mjuk-radering\n    const allHistory = mockHistory;\n    expect(allHistory).toHaveLength(2);\n    expect(allHistory.every(h => h.ts)).toBe(true);\n  });\n\n  test('4. Återställning möjlig för soft-deleted poster (ta bort deletedAt)', () => {\n    // Simulera mjuk-raderad klient\n    const softDeletedClient: Client = {\n      ...mockClient,\n      id: 'client-1',\n      name: 'Borttagen Klient',\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    // Simulera återställning (ta bort deletedAt)\n    const restoredClient: Client = {\n      ...softDeletedClient,\n      deletedAt: undefined\n    };\n    \n    expect(restoredClient.deletedAt).toBeUndefined();\n    expect(restoredClient.id).toBe('client-1');\n    expect(restoredClient.name).toBe('Borttagen Klient');\n    expect(restoredClient.createdAt).toBe('2024-01-01');\n    \n    // Test GFP-plan återställning\n    const softDeletedPlan: GFPPlan = {\n      ...mockGfpPlan,\n      id: 'plan-1',\n      title: 'Borttagen Plan',\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const restoredPlan: GFPPlan = {\n      ...softDeletedPlan,\n      deletedAt: undefined\n    };\n    \n    expect(restoredPlan.deletedAt).toBeUndefined();\n    expect(restoredPlan.id).toBe('plan-1');\n    expect(restoredPlan.title).toBe('Borttagen Plan');\n    expect(restoredPlan.status).toBe('approved');\n    \n    // Test veckodokument återställning\n    const softDeletedWeeklyDoc: WeeklyDoc = {\n      ...mockWeeklyDoc,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const restoredWeeklyDoc: WeeklyDoc = {\n      ...softDeletedWeeklyDoc,\n      deletedAt: undefined\n    };\n    \n    expect(restoredWeeklyDoc.deletedAt).toBeUndefined();\n    expect(restoredWeeklyDoc.weekId).toBe('2024-W01');\n    expect(restoredWeeklyDoc.status).toBe('approved');\n    \n    // Test månadsrapport återställning\n    const softDeletedMonthlyReport: MonthlyReport = {\n      ...mockMonthlyReport,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const restoredMonthlyReport: MonthlyReport = {\n      ...softDeletedMonthlyReport,\n      deletedAt: undefined\n    };\n    \n    expect(restoredMonthlyReport.deletedAt).toBeUndefined();\n    expect(restoredMonthlyReport.monthId).toBe('2024-01');\n    expect(restoredMonthlyReport.status).toBe('approved');\n    \n    // Test Visma-vecka återställning\n    const softDeletedVismaWeek: VismaWeek = {\n      ...mockVismaWeek,\n      deletedAt: '2024-01-15T10:00:00.000Z'\n    };\n    \n    const restoredVismaWeek: VismaWeek = {\n      ...softDeletedVismaWeek,\n      deletedAt: undefined\n    };\n    \n    expect(restoredVismaWeek.deletedAt).toBeUndefined();\n    expect(restoredVismaWeek.weekId).toBe('2024-W01');\n    expect(restoredVismaWeek.status).toBe('approved');\n  });\n});\n\nconsole.log('✅ Alla 4 testfall för mjuk-radering är definierade och redo att köras');\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/tests/timezone.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'beforeAll' is defined but never used.","line":6,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'afterAll' is defined but never used.","line":6,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":51}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Timezone Tests\n * Tests for Europe/Stockholm timezone handling\n */\n\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport { \n  nowInStockholm,\n  formatInStockholm,\n  toStockholmTime,\n  toUtc,\n  getCurrentWeekId,\n  getCurrentMonthId,\n  getCurrentDateId,\n  parseWeekId,\n  parseMonthId,\n  isValidWeekId,\n  isValidMonthId,\n  getWeekIdsForYear,\n  getMonthIdsForYear,\n  addDaysInStockholm,\n  formatForDisplay,\n  formatForApi,\n  parseApiDate,\n  STOCKHOLM_TIMEZONE\n} from '../server/utils/timezone.js';\n\ndescribe('Stockholm Timezone Utilities', () => {\n  \n  describe('Current Time Functions', () => {\n    it('should return current time in Stockholm timezone', () => {\n      const now = nowInStockholm();\n      expect(now).toBeInstanceOf(Date);\n      expect(now.getTime()).toBeGreaterThan(0);\n    });\n\n    it('should format current time in Stockholm timezone', () => {\n      const now = new Date();\n      const formatted = formatInStockholm(now, 'yyyy-MM-dd HH:mm:ss');\n      expect(formatted).toMatch(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/);\n    });\n\n    it('should get current week ID in correct format', () => {\n      const weekId = getCurrentWeekId();\n      expect(weekId).toMatch(/^\\d{4}-W\\d{2}$/);\n      \n      // Should be current year\n      const currentYear = new Date().getFullYear();\n      expect(weekId).toContain(currentYear.toString());\n    });\n\n    it('should get current month ID in correct format', () => {\n      const monthId = getCurrentMonthId();\n      expect(monthId).toMatch(/^\\d{4}-\\d{2}$/);\n      \n      // Should be current year\n      const currentYear = new Date().getFullYear();\n      expect(monthId).toContain(currentYear.toString());\n    });\n\n    it('should get current date ID in correct format', () => {\n      const dateId = getCurrentDateId();\n      expect(dateId).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n  });\n\n  describe('Timezone Conversion', () => {\n    it('should convert UTC to Stockholm time', () => {\n      const utcDate = new Date('2024-01-15T12:00:00Z'); // UTC noon\n      const stockholmTime = toStockholmTime(utcDate);\n      \n      // Stockholm is UTC+1 in winter (CET)\n      expect(stockholmTime.getHours()).toBe(13);\n    });\n\n    it('should convert Stockholm time to UTC', () => {\n      const stockholmDate = new Date('2024-01-15T13:00:00'); // Stockholm 1 PM\n      const utcTime = toUtc(stockholmDate);\n      \n      // Should be UTC noon\n      expect(utcTime.getUTCHours()).toBe(12);\n    });\n\n    it('should handle summer time (CEST)', () => {\n      const utcDate = new Date('2024-07-15T12:00:00Z'); // UTC noon in summer\n      const stockholmTime = toStockholmTime(utcDate);\n      \n      // Stockholm is UTC+2 in summer (CEST)\n      expect(stockholmTime.getHours()).toBe(14);\n    });\n  });\n\n  describe('Week ID Parsing', () => {\n    it('should parse valid week IDs', () => {\n      const weekId = '2024-W03';\n      const result = parseWeekId(weekId);\n      \n      expect(result).not.toBeNull();\n      expect(result!.start).toBeInstanceOf(Date);\n      expect(result!.end).toBeInstanceOf(Date);\n      expect(result!.start.getTime()).toBeLessThan(result!.end.getTime());\n    });\n\n    it('should reject invalid week ID formats', () => {\n      expect(parseWeekId('2024-W99')).toBeNull();\n      expect(parseWeekId('2024-W0')).toBeNull();\n      expect(parseWeekId('2024-W53')).toBeNull();\n      expect(parseWeekId('invalid')).toBeNull();\n      expect(parseWeekId('2024-03')).toBeNull();\n    });\n\n    it('should validate week IDs correctly', () => {\n      expect(isValidWeekId('2024-W03')).toBe(true);\n      expect(isValidWeekId('2024-W01')).toBe(true);\n      expect(isValidWeekId('2024-W52')).toBe(true);\n      expect(isValidWeekId('2024-W53')).toBe(false); // Not all years have week 53\n      expect(isValidWeekId('invalid')).toBe(false);\n      expect(isValidWeekId('2024-03')).toBe(false);\n    });\n\n    it('should handle edge cases for week parsing', () => {\n      // Week 1 of 2024 should start on January 1st\n      const week1 = parseWeekId('2024-W01');\n      expect(week1).not.toBeNull();\n      \n      // Week 52 of 2024 should be in December\n      const week52 = parseWeekId('2024-W52');\n      expect(week52).not.toBeNull();\n      expect(week52!.start.getMonth()).toBe(11); // December is month 11\n    });\n  });\n\n  describe('Month ID Parsing', () => {\n    it('should parse valid month IDs', () => {\n      const monthId = '2024-03';\n      const result = parseMonthId(monthId);\n      \n      expect(result).not.toBeNull();\n      expect(result!.start).toBeInstanceOf(Date);\n      expect(result!.end).toBeInstanceOf(Date);\n      expect(result!.start.getTime()).toBeLessThan(result!.end.getTime());\n      \n      // Should be March 2024\n      expect(result!.start.getFullYear()).toBe(2024);\n      expect(result!.start.getMonth()).toBe(2); // March is month 2 (0-indexed)\n    });\n\n    it('should reject invalid month ID formats', () => {\n      expect(parseMonthId('2024-13')).toBeNull();\n      expect(parseMonthId('2024-00')).toBeNull();\n      expect(parseMonthId('invalid')).toBeNull();\n      expect(parseMonthId('2024-3')).toBeNull(); // Should be zero-padded\n    });\n\n    it('should validate month IDs correctly', () => {\n      expect(isValidMonthId('2024-01')).toBe(true);\n      expect(isValidMonthId('2024-12')).toBe(true);\n      expect(isValidMonthId('2024-03')).toBe(true);\n      expect(isValidMonthId('2024-13')).toBe(false);\n      expect(isValidMonthId('2024-00')).toBe(false);\n      expect(isValidMonthId('invalid')).toBe(false);\n    });\n  });\n\n  describe('Year-based Functions', () => {\n    it('should get all week IDs for a year', () => {\n      const weekIds = getWeekIdsForYear(2024);\n      \n      expect(weekIds).toHaveLength(52);\n      expect(weekIds[0]).toMatch(/^2024-W\\d{2}$/);\n      expect(weekIds[51]).toMatch(/^2024-W\\d{2}$/);\n      \n      // Should be in order\n      expect(weekIds[0]).toBe('2024-W01');\n      expect(weekIds[51]).toBe('2024-W52');\n    });\n\n    it('should get all month IDs for a year', () => {\n      const monthIds = getMonthIdsForYear(2024);\n      \n      expect(monthIds).toHaveLength(12);\n      expect(monthIds[0]).toBe('2024-01');\n      expect(monthIds[11]).toBe('2024-12');\n    });\n  });\n\n  describe('Date Manipulation', () => {\n    it('should add days in Stockholm timezone', () => {\n      const baseDate = new Date('2024-01-15T12:00:00Z');\n      const result = addDaysInStockholm(baseDate, 7);\n      \n      expect(result.getTime()).toBeGreaterThan(baseDate.getTime());\n      expect(result.getTime() - baseDate.getTime()).toBe(7 * 24 * 60 * 60 * 1000);\n    });\n\n    it('should handle daylight saving time transitions', () => {\n      // Test spring forward (last Sunday in March)\n      const beforeDST = new Date('2024-03-30T12:00:00Z');\n      const afterDST = addDaysInStockholm(beforeDST, 1);\n      \n      expect(afterDST.getTime()).toBeGreaterThan(beforeDST.getTime());\n      \n      // Test fall back (last Sunday in October)\n      const beforeFall = new Date('2024-10-26T12:00:00Z');\n      const afterFall = addDaysInStockholm(beforeFall, 1);\n      \n      expect(afterFall.getTime()).toBeGreaterThan(beforeFall.getTime());\n    });\n  });\n\n  describe('Formatting Functions', () => {\n    it('should format dates for display', () => {\n      const date = new Date('2024-01-15T14:30:00Z');\n      const formatted = formatForDisplay(date);\n      \n      expect(formatted).toMatch(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/);\n    });\n\n    it('should format dates for API', () => {\n      const date = new Date('2024-01-15T14:30:00Z');\n      const formatted = formatForApi(date);\n      \n      expect(formatted).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\+\\d{2}:\\d{2}$/);\n    });\n\n    it('should parse API date strings', () => {\n      const apiDate = '2024-01-15T14:30:00.000+01:00';\n      const parsed = parseApiDate(apiDate);\n      \n      expect(parsed).toBeInstanceOf(Date);\n      expect(parsed.getTime()).toBeGreaterThan(0);\n    });\n\n    it('should handle invalid dates gracefully', () => {\n      const invalidDate = new Date('invalid');\n      const formatted = formatForDisplay(invalidDate);\n      \n      expect(formatted).toBe('Invalid date');\n    });\n  });\n\n  describe('Stockholm Timezone Constants', () => {\n    it('should have correct timezone constant', () => {\n      expect(STOCKHOLM_TIMEZONE).toBe('Europe/Stockholm');\n    });\n  });\n\n  describe('Integration Tests', () => {\n    it('should handle complete workflow from week ID to dates', () => {\n      const weekId = '2024-W10';\n      \n      // Parse week ID\n      const weekDates = parseWeekId(weekId);\n      expect(weekDates).not.toBeNull();\n      \n      // Format back to display\n      const startFormatted = formatForDisplay(weekDates!.start);\n      const endFormatted = formatForDisplay(weekDates!.end);\n      \n      expect(startFormatted).toMatch(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/);\n      expect(endFormatted).toMatch(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/);\n    });\n\n    it('should handle complete workflow from month ID to dates', () => {\n      const monthId = '2024-03';\n      \n      // Parse month ID\n      const monthDates = parseMonthId(monthId);\n      expect(monthDates).not.toBeNull();\n      \n      // Format back to display\n      const startFormatted = formatForDisplay(monthDates!.start);\n      const endFormatted = formatForDisplay(monthDates!.end);\n      \n      expect(startFormatted).toMatch(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/);\n      expect(endFormatted).toMatch(/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$/);\n    });\n\n    it('should maintain consistency across timezone operations', () => {\n      const originalDate = new Date('2024-01-15T12:00:00Z');\n      \n      // Convert to Stockholm and back\n      const stockholmTime = toStockholmTime(originalDate);\n      const backToUtc = toUtc(stockholmTime);\n      \n      // Should be close to original (within 1 second due to precision)\n      const diff = Math.abs(backToUtc.getTime() - originalDate.getTime());\n      expect(diff).toBeLessThan(1000);\n    });\n  });\n});\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/mirzacelik/Downloads/ungdomsstodet-dashboard 2026/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
